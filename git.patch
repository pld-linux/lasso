diff --git a/INSTALL b/INSTALL
index b4ed0f73..c1544bb4 100644
--- a/INSTALL
+++ b/INSTALL
@@ -26,9 +26,6 @@ In all cases you need to install development packages for dependencies. On Debia
     aptitude install libxml2-dev libxslt1-dev libxmlsec1-dev libxmlsec1-openssl \
       libglib2.0-dev python-all-dev fastjar php5-dev php5-cli python-lxml
 
-Python bindings require the "six" library:
-
-    pip install six
 
 Basic Installation
 ==================
diff --git a/NEWS b/NEWS
index 1d98536d..cc0c3d92 100644
--- a/NEWS
+++ b/NEWS
@@ -1,6 +1,17 @@
 NEWS
 ====
 
+Future
+------
+
+- Fix symbol deprecation of XMLSEC_CRYPTO macro in libxmlsec 1.3.0 (Patch
+  provided by Simo Sorce of RedHat) (#78280)
+- Annotate lasso_*_signature_method functions with LASSO_EXPORT (#86076)
+- Fix implicit function declaration errors, patch provided by Rob Crittenden
+  from RedHat (#85340)
+- Adjust to structured error callback argument change in libxml2 2.12, patch
+  provided by Florian Wiemer of RedHat (#86080)
+
 2.8.2 - March 14th 2023
 -----------------------
 
diff --git a/autogen.sh b/autogen.sh
index bf0e0d3a..7067b634 100755
--- a/autogen.sh
+++ b/autogen.sh
@@ -27,40 +27,26 @@ cd "$srcdir"
 	DIE=1
 }
 
-if automake-1.16 --version < /dev/null > /dev/null 2>&1; then
-    AUTOMAKE=automake-1.16
-    ACLOCAL=aclocal-1.16
-elif automake-1.15 --version < /dev/null > /dev/null 2>&1; then
-    AUTOMAKE=automake-1.15
-    ACLOCAL=aclocal-1.15
-elif automake-1.14 --version < /dev/null > /dev/null 2>&1; then
-    AUTOMAKE=automake-1.14
-    ACLOCAL=aclocal-1.14
-elif automake-1.13 --version < /dev/null > /dev/null 2>&1; then
-    AUTOMAKE=automake-1.13
-    ACLOCAL=aclocal-1.13
-elif automake-1.12 --version < /dev/null > /dev/null 2>&1; then
-    AUTOMAKE=automake-1.12
-    ACLOCAL=aclocal-1.12
-elif automake-1.11 --version < /dev/null > /dev/null 2>&1; then
-    AUTOMAKE=automake-1.11
-    ACLOCAL=aclocal-1.11
-elif automake-1.10 --version < /dev/null > /dev/null 2>&1; then
-    AUTOMAKE=automake-1.10
-    ACLOCAL=aclocal-1.10
-elif automake-1.9 --version < /dev/null > /dev/null 2>&1; then
-    AUTOMAKE=automake-1.9
-    ACLOCAL=aclocal-1.9
-elif automake-1.8 --version < /dev/null > /dev/null 2>&1; then
-    AUTOMAKE=automake-1.8
-    ACLOCAL=aclocal-1.8
-elif automake-1.7 --version < /dev/null > /dev/null 2>&1; then
-    AUTOMAKE=automake-1.7
-    ACLOCAL=aclocal-1.7
-elif automake-1.6 --version < /dev/null > /dev/null 2>&1; then
-    AUTOMAKE=automake-1.6
-    ACLOCAL=aclocal-1.6
-else
+am_versions() {
+	major=$1
+	minor_min=$2
+	minor_max=$3
+	seq "$minor_max" -1 "$minor_min" | xargs -I {} echo "$major.{}"
+}
+
+AM_VERSIONS_SUPPORT=$(am_versions 1 6 17)
+AUTOMAKE=""
+ACLOCAL=""
+for VERSION in $AM_VERSIONS_SUPPORT
+do
+	if which automake-${VERSION} < /dev/null > /dev/null 2>&1; then
+		AUTOMAKE=automake-${VERSION}
+		ACLOCAL=aclocal-${VERSION}
+		break
+	fi
+done
+if [ -z "$AUTOMAKE" ]
+then
 	echo
 	echo "You must have automake installed to compile $PROJECT."
 	echo "Download the appropriate package for your distribution,"
diff --git a/bindings/bindings.py b/bindings/bindings.py
index b8f9d503..ef3f9fbd 100644
--- a/bindings/bindings.py
+++ b/bindings/bindings.py
@@ -23,16 +23,9 @@
 
 import os
 import re
-from six import print_, PY3
 import sys
 from utils import *
 
-if PY3:
-    do_open = lambda *args, **kwargs: open(*args, encoding='utf-8', **kwargs)
-else:
-    do_open = open
-
-
 from optparse import OptionParser
 
 try:
@@ -166,10 +159,10 @@ class BindingData:
             if not 'Makefile.am' in filenames:
                 # not a source dir
                 continue
-            makefile_am = do_open(os.path.join(base, 'Makefile.am')).read()
+            makefile_am = open(os.path.join(base, 'Makefile.am')).read()
             filenames = [x for x in filenames if x.endswith('.c') if x in makefile_am]
             for filename in filenames:
-                s = do_open(os.path.join(base, filename)).read()
+                s = open(os.path.join(base, filename)).read()
                 docstrings = regex.findall(s)
                 for d in docstrings:
                     docstring = '\n'.join([x[3:] for x in d.splitlines()])
@@ -247,7 +240,7 @@ class Function:
                 try:
                     arg = [x for x in self.args if x[1] == param.attrib.get('name')][0]
                 except IndexError:
-                    print_('W: no such param (%s) in function (%s)' % (
+                    print('W: no such param (%s) in function (%s)' % (
                             param.attrib.get('name'), self.name), file=sys.stderr)
                     continue
                 if param.attrib.get('optional') == 'true':
@@ -410,7 +403,7 @@ def parse_header(header_file):
     in_struct_private = False
     in_ifdef_zero = False
 
-    lines = do_open(header_file).readlines()
+    lines = open(header_file).readlines()
     i = 0
     while i < len(lines):
         line = lines[i]
@@ -435,7 +428,7 @@ def parse_header(header_file):
                 enum_name = line[2:].strip().strip(';')
                 binding.enums.append(enum_name)
             else:
-                m = re.match('\s*([a-zA-Z0-9_]+)', line)
+                m = re.match(r'\s*([a-zA-Z0-9_]+)', line)
                 if m:
                     binding.constants.append(('i', m.group(1)))
         elif line.startswith('#define'):
@@ -475,7 +468,7 @@ def parse_header(header_file):
                 if not in_struct.name in binding.structs_toskip:
                     binding.structs.append(in_struct)
                 else:
-                    print_('W: skipping structure %s due to overrides.xml' % in_struct.name, file=sys.stderr)
+                    print('W: skipping structure %s due to overrides.xml' % in_struct.name, file=sys.stderr)
                 in_struct = None
             elif '/*< public >*/' in line:
                 in_struct_private = False
@@ -489,13 +482,13 @@ def parse_header(header_file):
                 # TODO: Add parsing of OFTYPE
                 # Transform struct to typedef
                 # example: "struct _LassoAssertion" -> "LassoAssertion"
-                line = re.sub('\s+struct _', ' ', line)
-                member_match = re.match('\s+(\w+)\s+(\*?\w+)', line)
+                line = re.sub(r'\s+struct _', ' ', line)
+                member_match = re.match(r'\s+(\w+)\s+(\*?\w+)', line)
                 if member_match:
                     member_type, member_name = normalise_var(member_match.group(1), member_match.group(2))
                     field = (member_type, member_name, {})
                     if member_type == 'void*':
-                        print_('W: skipping field %s.%s' % (in_struct.name, member_name), file=sys.stderr)
+                        print('W: skipping field %s.%s' % (in_struct.name, member_name), file=sys.stderr)
                     else:
                         if is_glist(field) or is_hashtable(field):
                             found = re.search(r' of ([^*]*)', line)
@@ -544,13 +537,13 @@ def parse_header(header_file):
                                 type = clean_type(type)
                                 f.args.append(list((type, name, {})))
                             else:
-                                print_('failed to process:', arg, 'in line:', line, file=sys.stderr)
+                                print('failed to process:', arg, 'in line:', line, file=sys.stderr)
                                 f.skip = True
                         f.apply_overrides()
                         if not f.skip:
                             binding.functions.append(f)
                         else:
-                            print_('W: skipping function', f, file=sys.stderr)
+                            print('W: skipping function', f, file=sys.stderr)
 
         i += 1
 
diff --git a/bindings/overrides.xml b/bindings/overrides.xml
index 9bb08e01..ce92fb15 100644
--- a/bindings/overrides.xml
+++ b/bindings/overrides.xml
@@ -23,6 +23,7 @@
   <func name="lasso_registry_default_get_mapping" skip="true"/>
   <!-- LassoProvider -->
   <func name="lasso_provider_get_metadata_list" return_owner="false"/>
+  <func name="lasso_provider_verify_saml_signature" skip="true"/>
   <!-- LassoProfile -->
   <func name="lasso_profile_get_server" skip="true"/>
   <func name="lasso_profile_get_nameIdentifier"
diff --git a/bindings/perl/glist_handling.c b/bindings/perl/glist_handling.c
index 01deb274..f7e24ed6 100644
--- a/bindings/perl/glist_handling.c
+++ b/bindings/perl/glist_handling.c
@@ -70,6 +70,7 @@ xmlnode_to_pv(xmlNode *node, gboolean do_free)
 	} else {
 		pestring = newSVpv((char*)xmlBufferContent(buf), 0);
 	}
+	xmlBufferFree(buf);
 	if (do_free) {
 		lasso_release_xml_node(node);
 	}
diff --git a/bindings/perl/lang.py b/bindings/perl/lang.py
index f412ff95..867e1b0c 100644
--- a/bindings/perl/lang.py
+++ b/bindings/perl/lang.py
@@ -22,20 +22,19 @@ import os
 import os.path
 import sys
 import re
-from six import print_
 from utils import *
 
-class Output(object):
+class Output:
     def __init__(self, filename, indent = 4):
         self.fd = open(filename, 'w')
         self.indent_stack = [0]
         self.indent_size = indent
 
     def pn(self, s = ''):
-        print_((' ' * self.indent_stack[-1]) + s, file=self.fd)
+        print((' ' * self.indent_stack[-1]) + s, file=self.fd)
 
     def p(self, s = ''):
-        print_(s, file=self.fd, end="")
+        print(s, file=self.fd, end="")
 
     def close(self):
         self.fd.close()
@@ -95,8 +94,8 @@ class Binding:
         self.typemap.pn('''
 string_or_null\tT_STRING_OR_NULL
 string_non_null\tT_STRING_NON_NULL
-const gchar *\tT_PV
 gchar *\tT_PV
+const gchar *\tT_PV
 gboolean\tT_IV
 const LassoProvider *\tT_GOBJECT_WRAPPER
 xmlNode*\tT_XMLNODE
@@ -277,7 +276,7 @@ INCLUDE: LassoNode.xs
             try:
                 self.xs.pn(self.glist_type(func.return_arg))
             except:
-                print_('failed', func.return_arg, func, file=sys.stderr)
+                print('failed', func.return_arg, func, file=sys.stderr)
                 raise
         self.xs.p(name + '(')
         arg_list = []
@@ -376,12 +375,24 @@ INCLUDE: LassoNode.xs
             self.xs.pn('''   OUTPUT:
          RETVAL''')
             cleanup.append('lasso_unref(RETVAL);')
-        elif func.return_type and is_object(func.return_type) and not is_int(func.return_type, self.binding_data) and func.return_owner:
-            cleanup.append('lasso_unref(RETVAL);')
         elif is_rc(func.return_arg):
             if name == 'lasso_check_version':
                 cleanup.append('if (RETVAL != 1)')
             cleanup.append('gperl_lasso_error(RETVAL);')
+        elif func.return_type:
+            if is_transfer_full(func.return_arg, default=True):
+                if is_cstring(func.return_arg):
+                    cleanup.append('lasso_release_string(RETVAL);')
+                elif is_int(func.return_type, self.binding_data) or is_boolean(func.return_type):
+                    pass
+                elif is_xml_node(func.return_arg):
+                    pass
+                elif is_glist(func.return_arg):
+                    pass
+                elif is_object(func.return_arg):
+                    cleanup.append('lasso_unref(RETVAL);')
+                else:
+                    raise Exception('Unsupported caller owned return type %s' % ((repr(func.return_arg), func),))
         # Output cleanup code
         if cleanup:
             self.xs.pn('  CLEANUP:')
@@ -448,7 +459,7 @@ INCLUDE: LassoNode.xs
                 kind = "objects"
             else:
                 kind = "strings"
-            self.xs.pn('''
+            self.xs.pn(r'''
 HV*
 %(field)s(%(clss)s* obj, ...)
     PROTOTYPE:
@@ -587,12 +598,12 @@ HV*
                 self.generate_xs_function(func, prefix = prefix)
             for member in struct.members:
                 if arg_type(member) ==  'void*':
-                    print_('Skipping %s' % member)
+                    print('Skipping %s' % member)
                     continue
                 try:
                     self.generate_xs_getter_setter(struct, member)
                 except:
-                    print_('failed', struct, member)
+                    print('failed', struct, member)
                     raise
 
     def generate_wrapper(self):
diff --git a/bindings/php5/php_code.py b/bindings/php5/php_code.py
index 7e94d16e..6794465c 100644
--- a/bindings/php5/php_code.py
+++ b/bindings/php5/php_code.py
@@ -20,7 +20,6 @@
 
 import re
 import sys
-import six
 
 from utils import *
 
@@ -40,7 +39,7 @@ class PhpCode:
         self.generate_footer()
 
     def generate_header(self):
-        six.print_('''\
+        print('''\
 <?php
 
 /* this file has been generated automatically; do not edit */
@@ -108,27 +107,27 @@ function lassoGetRequestTypeFromSoapMsg($mesg) {
         else:
             inheritence = ' extends LassoObject'
 
-        six.print_('/**', file=self.fd)
-        six.print_(' * @package Lasso', file=self.fd)
-        six.print_(' */', file=self.fd)
-        six.print_('class %(class_name)s%(inheritence)s {' % locals(), file=self.fd)
+        print('/**', file=self.fd)
+        print(' * @package Lasso', file=self.fd)
+        print(' */', file=self.fd)
+        print('class %(class_name)s%(inheritence)s {' % locals(), file=self.fd)
 
         if klass.members or klass.methods:
             self.generate_constructors(klass)
             self.generate_getters_and_setters(klass)
             self.generate_methods(klass)
 
-        six.print_('}', file=self.fd)
-        six.print_('', file=self.fd)
+        print('}', file=self.fd)
+        print('', file=self.fd)
 
         # Add a special class to get an object instance without initialising
-        six.print_('/**', file=self.fd)
-        six.print_(' * @package Lasso', file=self.fd)
-        six.print_(' */', file=self.fd)
-        six.print_('class %(class_name)sNoInit extends %(class_name)s {' % locals(), file=self.fd)
-        six.print_('    public function __construct() {}', file=self.fd)
-        six.print_('}', file=self.fd)
-        six.print_('', file=self.fd)
+        print('/**', file=self.fd)
+        print(' * @package Lasso', file=self.fd)
+        print(' */', file=self.fd)
+        print('class %(class_name)sNoInit extends %(class_name)s {' % locals(), file=self.fd)
+        print('    public function __construct() {}', file=self.fd)
+        print('}', file=self.fd)
+        print('', file=self.fd)
 
     def generate_constructors(self, klass):
         method_prefix = format_as_underscored(klass.name) + '_'
@@ -153,13 +152,13 @@ function lassoGetRequestTypeFromSoapMsg($mesg) {
                 c_args = ', '.join(c_args)
                 # XXX: could check $this->_cptr->typename to see if it got the
                 # right class type
-                six.print_('    public $_cptr = null;', file=self.fd)
-                six.print_('', file=self.fd)
-                six.print_('    public function __construct(%s) {' % php_args, file=self.fd)
-                six.print_('        $this->_cptr = %s(%s);' % (m.name, c_args), file=self.fd)
-                six.print_('        if (is_null($this->_cptr)) { throw new Exception("Constructor for ', klass.name, ' failed "); }', file=self.fd)
-                six.print_('    }', file=self.fd)
-                six.print_('', file=self.fd)
+                print('    public $_cptr = null;', file=self.fd)
+                print('', file=self.fd)
+                print('    public function __construct(%s) {' % php_args, file=self.fd)
+                print('        $this->_cptr = %s(%s);' % (m.name, c_args), file=self.fd)
+                print('        if (is_null($this->_cptr)) { throw new Exception("Constructor for ', klass.name, ' failed "); }', file=self.fd)
+                print('    }', file=self.fd)
+                print('', file=self.fd)
 
             elif name.startswith(method_prefix) and m.args \
                     and clean_type(unconstify(m.args[0][0])) != klass.name:
@@ -186,10 +185,10 @@ function lassoGetRequestTypeFromSoapMsg($mesg) {
                         c_args.append('$%s' % arg_name)
                 php_args = ', '.join(php_args)
                 c_args = ', '.join(c_args)
-                six.print_('    public static function %s(%s) {' % (php_name, php_args), file=self.fd)
-                six.print_('        return cptrToPhp(%s(%s));' % (m.name, c_args), file=self.fd)
-                six.print_('    }', file=self.fd)
-                six.print_('', file=self.fd)
+                print('    public static function %s(%s) {' % (php_name, php_args), file=self.fd)
+                print('        return cptrToPhp(%s(%s));' % (m.name, c_args), file=self.fd)
+                print('    }', file=self.fd)
+                print('', file=self.fd)
 
 
 
@@ -201,50 +200,50 @@ function lassoGetRequestTypeFromSoapMsg($mesg) {
             'class': c.name
         }
 
-        six.print_('''\
+        print('''\
     /**
     * @return  %(docstring)s
     */
     protected function get_%(name)s() {''' % d, file=self.fd)
-        six.print_('        $t = %(class)s_%(name)s_get($this->_cptr);' % d, file=self.fd)
+        print('        $t = %(class)s_%(name)s_get($this->_cptr);' % d, file=self.fd)
         if self.is_object(m):
-            six.print_('        $t = cptrToPhp($t);', file=self.fd)
+            print('        $t = cptrToPhp($t);', file=self.fd)
         elif (is_glist(m) or is_hashtable(m)) and self.is_object(element_type(m)):
-                six.print_('        foreach ($t as $key => $item) {', file=self.fd)
-                six.print_('            $t[$key] = cptrToPhp($item);', file=self.fd)
-                six.print_('        }', file=self.fd)
+                print('        foreach ($t as $key => $item) {', file=self.fd)
+                print('            $t[$key] = cptrToPhp($item);', file=self.fd)
+                print('        }', file=self.fd)
         elif is_hashtable(m) or (is_glist(m) and (is_cstring(element_type(m)) \
                 or is_xml_node(element_type(m)))) or is_int(m, self.binding_data) \
                 or is_boolean(m) or is_cstring(m) or is_xml_node(m):
             pass
         else:
             raise Exception('Cannot generate a Php getter %s.%s' % (c,m))
-        six.print_('        return $t;', file=self.fd)
-        six.print_('    }', file=self.fd)
+        print('        return $t;', file=self.fd)
+        print('    }', file=self.fd)
 
     def generate_setter(self, c, m):
         d = { 'type': arg_type(m), 'name': format_as_camelcase(arg_name(m)),
                 'docstring': self.get_docstring_return_type(arg_type(m)), 'class': c.name }
-        six.print_('    protected function set_%(name)s($value) {' % d, file=self.fd)
+        print('    protected function set_%(name)s($value) {' % d, file=self.fd)
         if self.is_object(m):
-            six.print_('        $value = $value->_cptr;', file=self.fd)
+            print('        $value = $value->_cptr;', file=self.fd)
         elif (is_glist(m) or is_hashtable(m)) and self.is_object(element_type(m)):
-            six.print_('        $array = array();', file=self.fd)
-            six.print_('        if (!is_null($value)) {', file=self.fd)
-            six.print_('            foreach ($value as $key => $item) {', file=self.fd)
-            six.print_('                $array[$key] = $item->_cptr;', file=self.fd)
-            six.print_('            }', file=self.fd)
-            six.print_('        }', file=self.fd)
-            six.print_('        $value = $array;', file=self.fd)
+            print('        $array = array();', file=self.fd)
+            print('        if (!is_null($value)) {', file=self.fd)
+            print('            foreach ($value as $key => $item) {', file=self.fd)
+            print('                $array[$key] = $item->_cptr;', file=self.fd)
+            print('            }', file=self.fd)
+            print('        }', file=self.fd)
+            print('        $value = $array;', file=self.fd)
         elif is_hashtable(m) or (is_glist(m) and (is_cstring(element_type(m)) \
                 or is_xml_node(element_type(m)))) or is_int(m, self.binding_data) \
                 or is_boolean(m) or is_cstring(m) or is_xml_node(m):
             pass
         else:
             raise Exception('Cannot generate a Php setter %s.%s' % (c,m))
-        six.print_('        %(class)s_%(name)s_set($this->_cptr, $value);' % d, file=self.fd)
-        six.print_('    }', file=self.fd)
-        six.print_('', file=self.fd)
+        print('        %(class)s_%(name)s_set($this->_cptr, $value);' % d, file=self.fd)
+        print('    }', file=self.fd)
+        print('', file=self.fd)
 
     def generate_getters_and_setters(self, klass):
         for m in klass.members:
@@ -272,27 +271,27 @@ function lassoGetRequestTypeFromSoapMsg($mesg) {
             mname = re.match(r'lasso_.*_get_(\w+)', meth_name).group(1)
             mname = format_as_camelcase(mname)
 
-            six.print_('    /**', file=self.fd)
-            six.print_('     * @return %s' % self.get_docstring_return_type(m.return_type), file=self.fd)
-            six.print_('     */', file=self.fd)
-            six.print_('    protected function get_%s() {' % mname, file=self.fd)
+            print('    /**', file=self.fd)
+            print('     * @return %s' % self.get_docstring_return_type(m.return_type), file=self.fd)
+            print('     */', file=self.fd)
+            print('    protected function get_%s() {' % mname, file=self.fd)
             if self.is_object(m.return_type):
-                six.print_('        $cptr = %s($this->_cptr);' % meth_name, file=self.fd)
-                six.print_('        if (! is_null($cptr)) {', file=self.fd)
-                six.print_('            return cptrToPhp($cptr);', file=self.fd)
-                six.print_('        }', file=self.fd)
-                six.print_('        return null;', file=self.fd)
+                print('        $cptr = %s($this->_cptr);' % meth_name, file=self.fd)
+                print('        if (! is_null($cptr)) {', file=self.fd)
+                print('            return cptrToPhp($cptr);', file=self.fd)
+                print('        }', file=self.fd)
+                print('        return null;', file=self.fd)
             else:
-                six.print_('        return %s($this->_cptr);' % meth_name, file=self.fd)
-            six.print_('    }', file=self.fd)
+                print('        return %s($this->_cptr);' % meth_name, file=self.fd)
+            print('    }', file=self.fd)
             if setter:
-                six.print_('    protected function set_%s($value) {' % mname, file=self.fd)
+                print('    protected function set_%s($value) {' % mname, file=self.fd)
                 if self.is_object(m.return_type):
-                    six.print_('        %s($this->_cptr, $value->_cptr);' % setter.name, file=self.fd)
+                    print('        %s($this->_cptr, $value->_cptr);' % setter.name, file=self.fd)
                 else:
-                    six.print_('        %s($this->_cptr, $value);' % setter.name, file=self.fd)
-                six.print_('    }', file=self.fd)
-            six.print_('', file=self.fd)
+                    print('        %s($this->_cptr, $value);' % setter.name, file=self.fd)
+                print('    }', file=self.fd)
+            print('', file=self.fd)
 
         # second pass on methods, real methods
         method_prefix = format_as_underscored(klass.name) + '_'
@@ -301,7 +300,7 @@ function lassoGetRequestTypeFromSoapMsg($mesg) {
                     m.name.endswith('_new_full'):
                 continue
             if not m.name.startswith(method_prefix):
-                six.print_('W:', m.name, 'vs', method_prefix, file=sys.stderr)
+                print('W:', m.name, 'vs', method_prefix, file=sys.stderr)
                 continue
 
             if m.rename:
@@ -327,7 +326,7 @@ function lassoGetRequestTypeFromSoapMsg($mesg) {
                         elif defval.startswith('b:'): # boolean
                             php_args.append('%s = %s' % (arg_name, defval[2:]))
                         else:
-                            six.print_("E: don't know what to do with %s" % defval, file=sys.stderr)
+                            print("E: don't know what to do with %s" % defval, file=sys.stderr)
                             sys.exit(1)
                     else:
                         php_args.append('%s = null' % arg_name)
@@ -357,26 +356,26 @@ function lassoGetRequestTypeFromSoapMsg($mesg) {
                 c_args = ''
 
             if m.docstring:
-                six.print_(self.generate_docstring(m, mname, 4), file=self.fd)
-            six.print_('    public function %s(%s) {' % (
+                print(self.generate_docstring(m, mname, 4), file=self.fd)
+            print('    public function %s(%s) {' % (
                     format_underscore_as_camelcase(mname), php_args), file=self.fd)
             if m.return_type == 'void':
-                six.print_('        %s($this->_cptr%s);' % (cname, c_args), file=self.fd)
+                print('        %s($this->_cptr%s);' % (cname, c_args), file=self.fd)
             elif is_rc(m.return_type):
-                six.print_('        $rc = %s($this->_cptr%s);' % (cname, c_args), file=self.fd)
-                six.print_('        if ($rc == 0) {', file=self.fd)
-                six.print_('            return 0;', file=self.fd)
-                six.print_('        } else if ($rc > 0) {', file=self.fd) # recoverable error
-                six.print_('            return $rc;', file=self.fd)
-                six.print_('        } else if ($rc < 0) {', file=self.fd) # unrecoverable error
-                six.print_('            LassoError::throw_on_rc($rc);', file=self.fd)
-                six.print_('        }', file=self.fd)
+                print('        $rc = %s($this->_cptr%s);' % (cname, c_args), file=self.fd)
+                print('        if ($rc == 0) {', file=self.fd)
+                print('            return 0;', file=self.fd)
+                print('        } else if ($rc > 0) {', file=self.fd) # recoverable error
+                print('            return $rc;', file=self.fd)
+                print('        } else if ($rc < 0) {', file=self.fd) # unrecoverable error
+                print('            LassoError::throw_on_rc($rc);', file=self.fd)
+                print('        }', file=self.fd)
             else:
-                six.print_('        return %s($this->_cptr%s);' % (cname, c_args), file=self.fd)
-            six.print_('    }', file=self.fd)
-            six.print_('', file=self.fd)
+                print('        return %s($this->_cptr%s);' % (cname, c_args), file=self.fd)
+            print('    }', file=self.fd)
+            print('', file=self.fd)
 
-        six.print_('', file=self.fd)
+        print('', file=self.fd)
 
     def generate_docstring(self, func, method_name, indent):
         docstring = func.docstring.orig_docstring
@@ -393,7 +392,7 @@ function lassoGetRequestTypeFromSoapMsg($mesg) {
             elif type == '%': # %TRUE, %FALSE
                 if var in ('TRUE', 'FALSE'):
                     return var
-                six.print_('W: unknown docstring thingie \'%s\' in \'%s\'' % (s.group(1), func.docstring.orig_docstring),
+                print('W: unknown docstring thingie \'%s\' in \'%s\'' % (s.group(1), func.docstring.orig_docstring),
                            file=sys.stderr)
             elif type == '@':
                 if var == first_arg_name:
@@ -437,7 +436,7 @@ function lassoGetRequestTypeFromSoapMsg($mesg) {
             cat = exc_cat.attrib.get('name')
             done_cats.append(cat)
             parent_cat = exc_cat.attrib.get('parent', '')
-            six.print_('''\
+            print('''\
 /**
  * @package Lasso
  */
@@ -462,7 +461,7 @@ class Lasso%sError extends Lasso%sError {}
                 else:
                     parent_cat = ''
 
-                six.print_('''\
+                print('''\
 /**
  * @package Lasso
  */
@@ -470,7 +469,7 @@ class Lasso%sError extends Lasso%sError {}
 ''' % (cat, parent_cat), file=self.fd)
 
             if detail not in exceptions_dict:
-                six.print_('''\
+                print('''\
 /**
  * @package Lasso
  */
@@ -480,7 +479,7 @@ class Lasso%sError extends Lasso%sError {
 ''' % (detail, cat, c[1]), file=self.fd)
                 exceptions_dict[detail] = c[1]
 
-        six.print_('''\
+        print('''\
 /**
  * @package Lasso
  */
@@ -488,9 +487,9 @@ class LassoError extends Exception {
     private static $exceptions_dict = array(''', file=self.fd)
 
         for k, v in exceptions_dict.items():
-            six.print_('        %s => "Lasso%sError",' % (v, k), file=self.fd)
+            print('        %s => "Lasso%sError",' % (v, k), file=self.fd)
 
-        six.print_('''\
+        print('''\
     );
 
     public static function throw_on_rc($rc) {
@@ -504,6 +503,6 @@ class LassoError extends Exception {
 ''', file=self.fd)
 
     def generate_footer(self):
-        six.print_('''\
+        print('''\
 ?>''', file=self.fd)
 
diff --git a/bindings/php5/wrapper_header.py b/bindings/php5/wrapper_header.py
index 5236571a..22908945 100644
--- a/bindings/php5/wrapper_header.py
+++ b/bindings/php5/wrapper_header.py
@@ -17,7 +17,6 @@
 #
 # You should have received a copy of the GNU General Public License
 # along with this program; if not, see <http://www.gnu.org/licenses/>.
-import six
 
 class WrapperHeader:
     def __init__(self, binding_data, fd, functions_list):
@@ -32,7 +31,7 @@ class WrapperHeader:
 
     def generate_header(self):
         # FIXME: Get the current version and name
-        six.print_('''\
+        print('''\
 /* this file has been generated automatically; do not edit */
 
 #include "../../config.h"
@@ -51,11 +50,11 @@ PHP_MSHUTDOWN_FUNCTION(lasso);
 
     def generate_functions_list(self):
         for m in self.functions_list:
-            six.print_('PHP_FUNCTION(%s);' % m, file=self.fd)
-        six.print_('', file=self.fd)
+            print('PHP_FUNCTION(%s);' % m, file=self.fd)
+        print('', file=self.fd)
 
     def generate_footer(self):
-        six.print_('''\
+        print('''\
 extern zend_module_entry lasso_module_entry;
 #define phpext_lasso_ptr &lasso_module_entry
 
diff --git a/bindings/php5/wrapper_source.py b/bindings/php5/wrapper_source.py
index d84b6fdb..5ddd90e5 100644
--- a/bindings/php5/wrapper_source.py
+++ b/bindings/php5/wrapper_source.py
@@ -20,7 +20,6 @@
 
 import sys
 import os
-import six
 
 from utils import *
 
@@ -53,17 +52,17 @@ class WrapperSource:
         self.functions_list.append('lasso_init')
         self.functions_list.append('lasso_shutdown')
 
-        six.print_('''\
+        print('''\
 /* this file has been generated automatically; do not edit */
 ''', file=self.fd)
 
-        six.print_(open(os.path.join(self.src_dir,'wrapper_source_top.c')).read(), file=self.fd)
+        print(open(os.path.join(self.src_dir,'wrapper_source_top.c')).read(), file=self.fd)
 
         for h in self.binding_data.headers:
-            six.print_('#include <%s>' % h, file=self.fd)
-        six.print_('', file=self.fd)
+            print('#include <%s>' % h, file=self.fd)
+        print('', file=self.fd)
 
-        six.print_('''\
+        print('''\
 PHP_MINIT_FUNCTION(lasso)
 {
     le_lasso_server = zend_register_list_destructors_ex(php_gobject_generic_destructor, NULL, PHP_LASSO_SERVER_RES_NAME, module_number);
@@ -71,25 +70,25 @@ PHP_MINIT_FUNCTION(lasso)
 ''', file=self.fd)
 
     def generate_constants(self):
-        six.print_('    /* Constants (both enums and defines) */', file=self.fd)
+        print('    /* Constants (both enums and defines) */', file=self.fd)
         for c in self.binding_data.constants:
             if c[0] == 'i':
-                six.print_('    REGISTER_LONG_CONSTANT("%s", %s, CONST_CS|CONST_PERSISTENT);' % (c[1], c[1]), file=self.fd)
+                print('    REGISTER_LONG_CONSTANT("%s", %s, CONST_CS|CONST_PERSISTENT);' % (c[1], c[1]), file=self.fd)
             elif c[0] == 's':
-                six.print_('    REGISTER_STRING_CONSTANT("%s", (char*) %s, CONST_CS|CONST_PERSISTENT);' % (c[1], c[1]), file=self.fd)
+                print('    REGISTER_STRING_CONSTANT("%s", (char*) %s, CONST_CS|CONST_PERSISTENT);' % (c[1], c[1]), file=self.fd)
             elif c[0] == 'b':
-                six.print_('''\
+                print('''\
 #ifdef %s
     REGISTER_LONG_CONSTANT("%s", 1, CONST_CS|CONST_PERSISTENT);
 #else
     REGISTER_LONG_CONSTANT("%s", 0, CONST_CS|CONST_PERSISTENT);
 #endif''' % (c[1], c[1], c[1]), file=self.fd)
             else:
-                six.print_('E: unknown constant type: %r' % c[0], file=sys.stderr)
-        six.print_('', file=self.fd)
+                print('E: unknown constant type: %r' % c[0], file=sys.stderr)
+        print('', file=self.fd)
 
     def generate_middle(self):
-        six.print_('''\
+        print('''\
     return SUCCESS;
 }
 
@@ -107,21 +106,21 @@ PHP_MSHUTDOWN_FUNCTION(lasso)
         # first we free the previous value
         p = (zval_name, c_variable)
         q = { 'zval_name' : zval_name, 'c_variable' : c_variable }
-        six.print_('    zval_dtor(%s);' % zval_name, file=self.fd)
+        print('    zval_dtor(%s);' % zval_name, file=self.fd)
         if is_pointer(type):
-            six.print_('    if (! %s) {' % c_variable, file=self.fd)
-            six.print_('       ZVAL_NULL(%s);' % zval_name, file=self.fd)
-            six.print_('    } else {', file=self.fd)
+            print('    if (! %s) {' % c_variable, file=self.fd)
+            print('       ZVAL_NULL(%s);' % zval_name, file=self.fd)
+            print('    } else {', file=self.fd)
         if is_int(type, self.binding_data):
-            six.print_('    ZVAL_LONG(%s, %s);' % p, file=self.fd)
+            print('    ZVAL_LONG(%s, %s);' % p, file=self.fd)
         elif is_boolean(type):
-            six.print_('    ZVAL_BOOL(%s, %s);' % p, file=self.fd)
+            print('    ZVAL_BOOL(%s, %s);' % p, file=self.fd)
         elif is_cstring(type):
-            six.print_('    ZVAL_STRING(%s, (char*)%s, 1);' % p, file=self.fd)
+            print('    ZVAL_STRING(%s, (char*)%s, 1);' % p, file=self.fd)
             if free and not is_const(type):
-                six.print_('g_free(%s)' % c_variable, file=self.fd)
+                print('g_free(%s)' % c_variable, file=self.fd)
         elif arg_type(type) == 'xmlNode*':
-            six.print_('''\
+            print('''\
     {
         char* xmlString = get_string_from_xml_node(%(c_variable)s);
         if (xmlString) {
@@ -146,11 +145,11 @@ PHP_MSHUTDOWN_FUNCTION(lasso)
                 free_function = 'g_list_free(%(c_variable)s);'
             else:
                 raise Exception('unknown element-type: ' + repr(type))
-            six.print_('     %s((GList*)%s, &%s);' % (function, c_variable, zval_name), file=self.fd)
+            print('     %s((GList*)%s, &%s);' % (function, c_variable, zval_name), file=self.fd)
             if free:
-                six.print_('   ', free_function % q, file=self.fd)
+                print('   ', free_function % q, file=self.fd)
         elif is_object(type):
-            six.print_('''\
+            print('''\
     if (G_IS_OBJECT(%(c_variable)s)) {
         PhpGObjectPtr *obj = PhpGObjectPtr_New(G_OBJECT(%(c_variable)s));
         ZEND_REGISTER_RESOURCE(%(zval_name)s, obj, le_lasso_server);
@@ -158,7 +157,7 @@ PHP_MSHUTDOWN_FUNCTION(lasso)
         ZVAL_NULL(%(zval_name)s);
     }''' % q, file=self.fd)
             if free:
-                six.print_('''\
+                print('''\
     if (%(c_variable)s) {
         g_object_unref(%(c_variable)s); // If constructor ref is off by one'
     }''' % q, file=self.fd)
@@ -166,7 +165,7 @@ PHP_MSHUTDOWN_FUNCTION(lasso)
         else:
             raise Exception('unknown type: ' + repr(type) + unconstify(arg_type(type)))
         if is_pointer(type):
-            six.print_('    }', file=self.fd)
+            print('    }', file=self.fd)
 
 
 
@@ -175,20 +174,20 @@ PHP_MSHUTDOWN_FUNCTION(lasso)
             return
 
         if is_boolean(arg):
-            six.print_('    RETVAL_BOOL(return_c_value);', file=self.fd)
+            print('    RETVAL_BOOL(return_c_value);', file=self.fd)
         elif is_int(arg, self.binding_data):
-            six.print_('    RETVAL_LONG(return_c_value);', file=self.fd)
+            print('    RETVAL_LONG(return_c_value);', file=self.fd)
         elif is_cstring(arg):
-            six.print_('''\
+            print('''\
     if (return_c_value) {
         RETVAL_STRING((char*)return_c_value, 1);
     } else {
         RETVAL_NULL();
     }''', file=self.fd)
             if free:
-                six.print_('    free(return_c_value);', file=self.fd)
+                print('    free(return_c_value);', file=self.fd)
         elif is_xml_node(arg):
-            six.print_('''\
+            print('''\
     {
         char* xmlString = get_string_from_xml_node(return_c_value);
         if (xmlString) {
@@ -199,44 +198,44 @@ PHP_MSHUTDOWN_FUNCTION(lasso)
     }
 ''', file=self.fd)
             if free:
-                six.print_('    lasso_release_xml_node(return_c_value);', file=self.fd)
+                print('    lasso_release_xml_node(return_c_value);', file=self.fd)
         elif is_glist(arg):
             el_type = element_type(arg)
             if is_cstring(el_type):
-                six.print_('''\
+                print('''\
     set_array_from_list_of_strings((GList*)return_c_value, &return_value);
 ''', file=self.fd)
                 if free:
-                    six.print_('    lasso_release_list_of_strings(return_c_value);', file=self.fd)
+                    print('    lasso_release_list_of_strings(return_c_value);', file=self.fd)
             elif is_xml_node(el_type):
-                six.print_('''\
+                print('''\
     set_array_from_list_of_xmlnodes((GList*)return_c_value, &return_value);
 ''', file=self.fd)
                 if free or is_transfer_full(arg):
-                    six.print_('    lasso_release_list_of_xml_node(return_c_value);', file=self.fd)
+                    print('    lasso_release_list_of_xml_node(return_c_value);', file=self.fd)
             elif is_object(el_type):
-                six.print_('''\
+                print('''\
     set_array_from_list_of_objects((GList*)return_c_value, &return_value);
 ''', file=self.fd)
                 if free:
-                    six.print_('    lasso_release_list_of_gobjects(return_c_value);', file=self.fd)
+                    print('    lasso_release_list_of_gobjects(return_c_value);', file=self.fd)
             else:
                 raise Exception('cannot return value for %s' % (arg,))
         elif is_hashtable(arg):
             el_type = element_type(arg)
             if is_object(el_type):
-                six.print_('''\
+                print('''\
     set_array_from_hashtable_of_objects(return_c_value, &return_value);
 ''', file=self.fd)
             else:
                 if not is_cstring(arg):
-                    six.print_('W: %s has no explicit string annotation' % (arg,),
+                    print('W: %s has no explicit string annotation' % (arg,),
                                file=sys.stderr)
-                six.print_('''\
+                print('''\
     set_array_from_hashtable_of_strings(return_c_value, &return_value);
 ''', file=self.fd)
         elif is_object(arg):
-            six.print_('''\
+            print('''\
     if (return_c_value) {
         PhpGObjectPtr *self;
         self = PhpGObjectPtr_New(G_OBJECT(return_c_value));
@@ -245,7 +244,7 @@ PHP_MSHUTDOWN_FUNCTION(lasso)
         RETVAL_NULL();
     }''', file=self.fd)
             if free:
-                six.print_('    lasso_release_gobject(return_c_value);', file=self.fd)
+                print('    lasso_release_gobject(return_c_value);', file=self.fd)
         else:
             raise Exception('cannot return value for %s' % (arg,))
 
@@ -257,61 +256,61 @@ PHP_MSHUTDOWN_FUNCTION(lasso)
         else:
             name = m.name
         self.functions_list.append(name)
-        six.print_('''PHP_FUNCTION(%s)
+        print('''PHP_FUNCTION(%s)
 {''' % name, file=self.fd)
         parse_tuple_format = []
         parse_tuple_args = []
         for arg in m.args:
             if is_out(arg):
-                six.print_('   zval *php_out_%s = NULL;' % arg_name(arg), file=self.fd)
-                six.print_('   %s %s;' % (var_type(arg), arg_name(arg)), file=self.fd)
+                print('   zval *php_out_%s = NULL;' % arg_name(arg), file=self.fd)
+                print('   %s %s;' % (var_type(arg), arg_name(arg)), file=self.fd)
                 parse_tuple_format.append('z!')
                 parse_tuple_args.append('&php_out_%s' % arg_name(arg))
             elif is_cstring(arg):
                 parse_tuple_format.append('s!')
                 parse_tuple_args.append('&%s_str, &%s_len' % (arg_name(arg), arg_name(arg)))
-                six.print_('    %s %s = NULL;' % ('char*', arg_name(arg)), file=self.fd)
-                six.print_('    %s %s_str = NULL;' % ('char*', arg_name(arg)), file=self.fd)
-                six.print_('    %s %s_len = 0;' % ('int', arg_name(arg)), file=self.fd)
+                print('    %s %s = NULL;' % ('char*', arg_name(arg)), file=self.fd)
+                print('    %s %s_str = NULL;' % ('char*', arg_name(arg)), file=self.fd)
+                print('    %s %s_len = 0;' % ('int', arg_name(arg)), file=self.fd)
             elif is_int(arg, self.binding_data) or is_boolean(arg):
                 parse_tuple_format.append('l')
                 parse_tuple_args.append('&%s' % arg_name(arg))
-                six.print_('    %s %s;' % ('long', arg_name(arg)), file=self.fd)
+                print('    %s %s;' % ('long', arg_name(arg)), file=self.fd)
             elif is_time_t_pointer(arg):
                 parse_tuple_format.append('l')
                 parse_tuple_args.append('&%s' % (arg_name(arg),))
-                six.print_('    time_t %s = 0;' % (arg_name(arg),), file=self.fd)
+                print('    time_t %s = 0;' % (arg_name(arg),), file=self.fd)
             elif is_xml_node(arg):
                 parse_tuple_format.append('s!')
                 parse_tuple_args.append('&%s_str, &%s_len' % (arg_name(arg), arg_name(arg)))
-                six.print_('    %s %s = NULL;' % ('xmlNode*', arg_name(arg)), file=self.fd)
-                six.print_('    %s %s_str = NULL;'  % ('char*', arg_name(arg)), file=self.fd)
-                six.print_('    %s %s_len = 0;' % ('int', arg_name(arg)), file=self.fd)
+                print('    %s %s = NULL;' % ('xmlNode*', arg_name(arg)), file=self.fd)
+                print('    %s %s_str = NULL;'  % ('char*', arg_name(arg)), file=self.fd)
+                print('    %s %s_len = 0;' % ('int', arg_name(arg)), file=self.fd)
             elif is_glist(arg):
                 parse_tuple_format.append('a!')
                 parse_tuple_args.append('&zval_%s' % arg_name(arg))
-                six.print_('    %s zval_%s = NULL;' % ('zval*', arg_name(arg)), file=self.fd)
-                six.print_('    %s %s = NULL;' % ('GList*', arg_name(arg)), file=self.fd)
+                print('    %s zval_%s = NULL;' % ('zval*', arg_name(arg)), file=self.fd)
+                print('    %s %s = NULL;' % ('GList*', arg_name(arg)), file=self.fd)
             elif is_object(arg):
                 parse_tuple_format.append('r')
                 parse_tuple_args.append('&zval_%s' % arg_name(arg))
-                six.print_('    %s %s = NULL;' % (arg_type(arg), arg_name(arg)), file=self.fd)
-                six.print_('    %s zval_%s = NULL;' % ('zval*', arg_name(arg)), file=self.fd)
-                six.print_('    %s cvt_%s = NULL;' % ('PhpGObjectPtr*', arg_name(arg)), file=self.fd)
+                print('    %s %s = NULL;' % (arg_type(arg), arg_name(arg)), file=self.fd)
+                print('    %s zval_%s = NULL;' % ('zval*', arg_name(arg)), file=self.fd)
+                print('    %s cvt_%s = NULL;' % ('PhpGObjectPtr*', arg_name(arg)), file=self.fd)
             else:
                 raise Exception('Unsupported type %s %s' % (arg, m))
 
         if m.return_type:
-            six.print_('    %s return_c_value;' % m.return_type, file=self.fd)
+            print('    %s return_c_value;' % m.return_type, file=self.fd)
         if m.return_type is not None and self.is_object(m.return_arg):
-            six.print_('    G_GNUC_UNUSED PhpGObjectPtr *self;', file=self.fd)
-        six.print_('', file=self.fd)
+            print('    G_GNUC_UNUSED PhpGObjectPtr *self;', file=self.fd)
+        print('', file=self.fd)
 
         parse_tuple_args = ', '.join(parse_tuple_args)
         if parse_tuple_args:
             parse_tuple_args = ', ' + parse_tuple_args
 
-        six.print_('''\
+        print('''\
     if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "%s"%s) == FAILURE) {
         RETURN_FALSE;
     }
@@ -321,22 +320,22 @@ PHP_MSHUTDOWN_FUNCTION(lasso)
             if is_out(arg):
                 continue
             elif is_xml_node(arg):
-                six.print_('''\
+                print('''\
         %(name)s = get_xml_node_from_string(%(name)s_str);''' % {'name': arg[1]}, file=self.fd)
             elif f.startswith('s'):
-                six.print_('''\
+                print('''\
         %(name)s = %(name)s_str;''' % {'name': arg[1]}, file=self.fd)
             elif f.startswith('r'):
-                six.print_('    ZEND_FETCH_RESOURCE(cvt_%s, PhpGObjectPtr *, &zval_%s, -1, PHP_LASSO_SERVER_RES_NAME, le_lasso_server);' % (arg[1], arg[1]), file=self.fd)
-                six.print_('    %s = (%s)cvt_%s->obj;' % (arg[1], arg[0], arg[1]), file=self.fd)
+                print('    ZEND_FETCH_RESOURCE(cvt_%s, PhpGObjectPtr *, &zval_%s, -1, PHP_LASSO_SERVER_RES_NAME, le_lasso_server);' % (arg[1], arg[1]), file=self.fd)
+                print('    %s = (%s)cvt_%s->obj;' % (arg[1], arg[0], arg[1]), file=self.fd)
             elif f.startswith('a'):
                 el_type = element_type(arg)
                 if is_cstring(el_type):
-                    six.print_('    %(name)s = get_list_from_array_of_strings(zval_%(name)s);' % {'name': arg[1]}, file=self.fd)
+                    print('    %(name)s = get_list_from_array_of_strings(zval_%(name)s);' % {'name': arg[1]}, file=self.fd)
                 elif is_object(el_type):
-                    six.print_('    %(name)s = get_list_from_array_of_objects(zval_%(name)s);' % {'name': arg[1]}, file=self.fd)
+                    print('    %(name)s = get_list_from_array_of_objects(zval_%(name)s);' % {'name': arg[1]}, file=self.fd)
                 else:
-                    six.print_('E: In %(function)s arg %(name)s is of type GList<%(elem)s>' % { 'function': m.name, 'name': arg[1], 'elem': el_type }, file=sys.stderr)
+                    print('E: In %(function)s arg %(name)s is of type GList<%(elem)s>' % { 'function': m.name, 'name': arg[1], 'elem': el_type }, file=sys.stderr)
             elif f == 'l':
                 pass
             else:
@@ -344,17 +343,17 @@ PHP_MSHUTDOWN_FUNCTION(lasso)
 
 
         if m.return_type is not None:
-            six.print_('    return_c_value = ', file=self.fd)
+            print('    return_c_value = ', file=self.fd)
             if 'new' in m.name:
-                six.print_('(%s)' % m.return_type, file=self.fd)
+                print('(%s)' % m.return_type, file=self.fd)
         else:
-            six.print_('   ', file=self.fd)
+            print('   ', file=self.fd)
         def special(x):
             if is_time_t_pointer(x):
                 return '%(name)s ? &%(name)s : NULL' % { 'name': arg_name(x) }
             else:
                 return ref_name(x)
-        six.print_('%s(%s);' % (m.name, ', '.join([special(x) for x in m.args])), file=self.fd)
+        print('%s(%s);' % (m.name, ', '.join([special(x) for x in m.args])), file=self.fd)
         # Free the converted arguments
 
         for f, arg in zip(parse_tuple_format, m.args):
@@ -365,21 +364,21 @@ PHP_MSHUTDOWN_FUNCTION(lasso)
                 self.set_zval('php_out_%s' % argname, argname, unref_type(arg), free = free)
                 pass
             elif argtype == 'xmlNode*':
-                six.print_('    xmlFree(%s);' % argname, file=self.fd)
+                print('    xmlFree(%s);' % argname, file=self.fd)
             elif f.startswith('a'):
                 el_type = element_type(arg)
                 if is_cstring(el_type):
-                    six.print_('    if (%(name)s) {' % { 'name': arg[1] }, file=self.fd)
-                    six.print_('        free_glist(&%(name)s,(GFunc)free);' % { 'name': arg[1] }, file=self.fd)
-                    six.print_('    }', file=self.fd)
+                    print('    if (%(name)s) {' % { 'name': arg[1] }, file=self.fd)
+                    print('        free_glist(&%(name)s,(GFunc)free);' % { 'name': arg[1] }, file=self.fd)
+                    print('    }', file=self.fd)
 
         try:
             self.return_value(m.return_arg, is_transfer_full(m.return_arg, default=True))
         except:
             raise Exception('Cannot return value for function %s' % m)
 
-        six.print_('}', file=self.fd)
-        six.print_('', file=self.fd)
+        print('}', file=self.fd)
+        print('', file=self.fd)
 
     def generate_members(self, c):
         for m in c.members:
@@ -392,16 +391,16 @@ PHP_MSHUTDOWN_FUNCTION(lasso)
         type = arg_type(m)
 
         function_name = '%s_%s_get' % (klassname, format_as_camelcase(name))
-        six.print_('''PHP_FUNCTION(%s)
+        print('''PHP_FUNCTION(%s)
 {''' % function_name, file=self.fd)
         self.functions_list.append(function_name)
 
-        six.print_('    %s return_c_value;' % type, file=self.fd)
-        six.print_('    %s* this;' % klassname, file=self.fd)
-        six.print_('    zval* zval_this;', file=self.fd)
-        six.print_('    PhpGObjectPtr *cvt_this;', file=self.fd)
-        six.print_('', file=self.fd)
-        six.print_('''\
+        print('    %s return_c_value;' % type, file=self.fd)
+        print('    %s* this;' % klassname, file=self.fd)
+        print('    zval* zval_this;', file=self.fd)
+        print('    PhpGObjectPtr *cvt_this;', file=self.fd)
+        print('', file=self.fd)
+        print('''\
     if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "r", &zval_this) == FAILURE) {
         RETURN_FALSE;
     }
@@ -409,23 +408,23 @@ PHP_MSHUTDOWN_FUNCTION(lasso)
     ZEND_FETCH_RESOURCE(cvt_this, PhpGObjectPtr *, &zval_this, -1, PHP_LASSO_SERVER_RES_NAME, le_lasso_server);
     this = (%s*)cvt_this->obj;
 ''' % (klassname), file=self.fd)
-        six.print_('    return_c_value = (%s)this->%s;' % (type, name), file=self.fd)
+        print('    return_c_value = (%s)this->%s;' % (type, name), file=self.fd)
         self.return_value(m)
-        six.print_('}', file=self.fd)
-        six.print_('', file=self.fd)
+        print('}', file=self.fd)
+        print('', file=self.fd)
 
     def generate_setter(self, c, m):
         klassname = c.name
         name = arg_name(m)
         type = arg_type(m)
         function_name = '%s_%s_set' % (klassname, format_as_camelcase(name))
-        six.print_('''PHP_FUNCTION(%s)
+        print('''PHP_FUNCTION(%s)
 {''' % function_name, file=self.fd)
         self.functions_list.append(function_name)
 
-        six.print_('    %s* this;' % klassname, file=self.fd)
-        six.print_('    zval* zval_this;', file=self.fd)
-        six.print_('    PhpGObjectPtr *cvt_this;', file=self.fd)
+        print('    %s* this;' % klassname, file=self.fd)
+        print('    zval* zval_this;', file=self.fd)
+        print('    PhpGObjectPtr *cvt_this;', file=self.fd)
 
         # FIXME: This bloc should be factorised
         parse_tuple_format = ''
@@ -434,41 +433,41 @@ PHP_MSHUTDOWN_FUNCTION(lasso)
             # arg_type = arg_type.replace('const ', '')
             parse_tuple_format += 's'
             parse_tuple_args.append('&%s_str, &%s_len' % (name, name))
-            six.print_('    %s %s_str = NULL;' % ('char*', name), file=self.fd)
-            six.print_('    %s %s_len = 0;' % ('int', name), file=self.fd)
+            print('    %s %s_str = NULL;' % ('char*', name), file=self.fd)
+            print('    %s %s_len = 0;' % ('int', name), file=self.fd)
         elif is_int(m, self.binding_data) or is_boolean(m):
             parse_tuple_format += 'l'
             parse_tuple_args.append('&%s' % name)
-            six.print_('    %s %s;' % ('long', name), file=self.fd)
+            print('    %s %s;' % ('long', name), file=self.fd)
         # Must also handle lists of Objects
         elif is_glist(m) or is_hashtable(m):
             parse_tuple_format += 'a'
             parse_tuple_args.append('&zval_%s' % name)
-            six.print_('    %s zval_%s;' % ('zval*', name), file=self.fd)
+            print('    %s zval_%s;' % ('zval*', name), file=self.fd)
         elif is_object(m):
             parse_tuple_format += 'r'
             parse_tuple_args.append('&zval_%s' % name)
-            six.print_('    %s zval_%s = NULL;' % ('zval*', name), file=self.fd)
-            six.print_('    %s cvt_%s = NULL;' % ('PhpGObjectPtr*', name), file=self.fd)
+            print('    %s zval_%s = NULL;' % ('zval*', name), file=self.fd)
+            print('    %s cvt_%s = NULL;' % ('PhpGObjectPtr*', name), file=self.fd)
         else:
             raise Exception('Cannot make a setter for %s.%s' % (c,m))
 
         if parse_tuple_args:
             parse_tuple_arg = parse_tuple_args[0]
         else:
-            six.print_('}', file=self.fd)
-            six.print_('', file=self.fd)
+            print('}', file=self.fd)
+            print('', file=self.fd)
             return
 
-        six.print_('', file=self.fd)
-        six.print_('''\
+        print('', file=self.fd)
+        print('''\
     if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "r%s", &zval_this, %s) == FAILURE) {
         return;
     }
 ''' % (parse_tuple_format, parse_tuple_arg), file=self.fd)
 
         # Get 'this' object
-        six.print_('''\
+        print('''\
     ZEND_FETCH_RESOURCE(cvt_this, PhpGObjectPtr *, &zval_this, -1, PHP_LASSO_SERVER_RES_NAME, le_lasso_server);
     this = (%s*)cvt_this->obj;
 ''' % klassname, file=self.fd)
@@ -476,51 +475,51 @@ PHP_MSHUTDOWN_FUNCTION(lasso)
         # Set new value
         d = { 'name': name, 'type': type }
         if is_int(m, self.binding_data) or is_boolean(m):
-            six.print_('    this->%s = %s;' % (name, name), file=self.fd)
+            print('    this->%s = %s;' % (name, name), file=self.fd)
         elif is_cstring(m):
-            six.print_('    lasso_assign_string(this->%(name)s, %(name)s_str);' % d, file=self.fd)
+            print('    lasso_assign_string(this->%(name)s, %(name)s_str);' % d, file=self.fd)
         elif is_xml_node(m):
-            six.print_('    lasso_assign_new_xml_node(this->%(name)s, get_xml_node_from_string(%(name)s_str));' % d, file=self.fd)
+            print('    lasso_assign_new_xml_node(this->%(name)s, get_xml_node_from_string(%(name)s_str));' % d, file=self.fd)
         elif is_glist(m):
             el_type = element_type(m)
             if is_cstring(el_type):
-                six.print_('    lasso_assign_new_list_of_strings(this->%(name)s, get_list_from_array_of_strings(zval_%(name)s));' % d, file=self.fd)
+                print('    lasso_assign_new_list_of_strings(this->%(name)s, get_list_from_array_of_strings(zval_%(name)s));' % d, file=self.fd)
             elif is_xml_node(el_type):
-                six.print_('    lasso_assign_new_list_of_xml_node(this->%(name)s, get_list_from_array_of_xmlnodes(zval_%(name)s))' % d, file=self.fd)
+                print('    lasso_assign_new_list_of_xml_node(this->%(name)s, get_list_from_array_of_xmlnodes(zval_%(name)s))' % d, file=self.fd)
             elif is_object(el_type):
-                six.print_('    lasso_assign_new_list_of_gobjects(this->%(name)s, get_list_from_array_of_objects(zval_%(name)s));' % d, file=self.fd)
+                print('    lasso_assign_new_list_of_gobjects(this->%(name)s, get_list_from_array_of_objects(zval_%(name)s));' % d, file=self.fd)
             else:
                 raise Exception('Cannot create C setter for %s.%s' % (c,m))
         elif is_hashtable(m):
             el_type = element_type(m)
-            six.print_('''\
+            print('''\
         {
             GHashTable *oldhash = this->%(name)s;''' % d, file=self.fd)
             if is_object(el_type):
-                six.print_('            this->%(name)s = get_hashtable_from_array_of_objects(zval_%(name)s);' % d, file=self.fd)
+                print('            this->%(name)s = get_hashtable_from_array_of_objects(zval_%(name)s);' % d, file=self.fd)
             else:
-                six.print_('            this->%(name)s = get_hashtable_from_array_of_strings(zval_%(name)s);' % d, file=self.fd)
-            six.print_('            g_hash_table_destroy(oldhash);', file=self.fd)
-            six.print_('        }', file=self.fd)
+                print('            this->%(name)s = get_hashtable_from_array_of_strings(zval_%(name)s);' % d, file=self.fd)
+            print('            g_hash_table_destroy(oldhash);', file=self.fd)
+            print('        }', file=self.fd)
         elif is_object(m):
-            six.print_('    ZEND_FETCH_RESOURCE(cvt_%(name)s, PhpGObjectPtr*, &zval_%(name)s, -1, PHP_LASSO_SERVER_RES_NAME, le_lasso_server);' % d, file=self.fd)
-            six.print_('    lasso_assign_gobject(this->%(name)s, cvt_%(name)s->obj);' % d, file=self.fd)
+            print('    ZEND_FETCH_RESOURCE(cvt_%(name)s, PhpGObjectPtr*, &zval_%(name)s, -1, PHP_LASSO_SERVER_RES_NAME, le_lasso_server);' % d, file=self.fd)
+            print('    lasso_assign_gobject(this->%(name)s, cvt_%(name)s->obj);' % d, file=self.fd)
 
-        six.print_('}', file=self.fd)
-        six.print_('', file=self.fd)
+        print('}', file=self.fd)
+        print('', file=self.fd)
 
     def generate_functions_list(self):
-        six.print_('''\
+        print('''\
 static zend_function_entry lasso_functions[] = {''', file=self.fd)
         for m in self.functions_list:
-            six.print_('    PHP_FE(%s, NULL)' % m, file=self.fd)
-        six.print_('''\
+            print('    PHP_FE(%s, NULL)' % m, file=self.fd)
+        print('''\
     {NULL, NULL, NULL, 0, 0}
 };
 ''', file=self.fd)
 
     def generate_footer(self):
-        six.print_('''\
+        print('''\
 zend_module_entry lasso_module_entry = {
 #if ZEND_MODULE_API_NO >= 20010901
     STANDARD_MODULE_HEADER,
diff --git a/bindings/php7/php_code.py b/bindings/php7/php_code.py
index a4eaf929..3f7b1a36 100644
--- a/bindings/php7/php_code.py
+++ b/bindings/php7/php_code.py
@@ -20,7 +20,6 @@
 
 import re
 import sys
-import six
 
 from utils import *
 
@@ -40,7 +39,7 @@ class PhpCode:
         self.generate_footer()
 
     def generate_header(self):
-        six.print_('''\
+        print('''\
 <?php
 
 /* this file has been generated automatically; do not edit */
@@ -107,27 +106,27 @@ function lassoGetRequestTypeFromSoapMsg($mesg) {
         else:
             inheritence = ' extends LassoObject'
 
-        six.print_('/**', file=self.fd)
-        six.print_(' * @package Lasso', file=self.fd)
-        six.print_(' */', file=self.fd)
-        six.print_('class %(class_name)s%(inheritence)s {' % locals(), file=self.fd)
+        print('/**', file=self.fd)
+        print(' * @package Lasso', file=self.fd)
+        print(' */', file=self.fd)
+        print('class %(class_name)s%(inheritence)s {' % locals(), file=self.fd)
 
         if klass.members or klass.methods:
             self.generate_constructors(klass)
             self.generate_getters_and_setters(klass)
             self.generate_methods(klass)
 
-        six.print_('}', file=self.fd)
-        six.print_('', file=self.fd)
+        print('}', file=self.fd)
+        print('', file=self.fd)
 
         # Add a special class to get an object instance without initialising
-        six.print_('/**', file=self.fd)
-        six.print_(' * @package Lasso', file=self.fd)
-        six.print_(' */', file=self.fd)
-        six.print_('class %(class_name)sNoInit extends %(class_name)s {' % locals(), file=self.fd)
-        six.print_('    public function __construct() {}', file=self.fd)
-        six.print_('}', file=self.fd)
-        six.print_('', file=self.fd)
+        print('/**', file=self.fd)
+        print(' * @package Lasso', file=self.fd)
+        print(' */', file=self.fd)
+        print('class %(class_name)sNoInit extends %(class_name)s {' % locals(), file=self.fd)
+        print('    public function __construct() {}', file=self.fd)
+        print('}', file=self.fd)
+        print('', file=self.fd)
 
     def generate_constructors(self, klass):
         method_prefix = format_as_underscored(klass.name) + '_'
@@ -152,13 +151,13 @@ function lassoGetRequestTypeFromSoapMsg($mesg) {
                 c_args = ', '.join(c_args)
                 # XXX: could check $this->_cptr->typename to see if it got the
                 # right class type
-                six.print_('    public $_cptr = null;', file=self.fd)
-                six.print_('', file=self.fd)
-                six.print_('    public function __construct(%s) {' % php_args, file=self.fd)
-                six.print_('        $this->_cptr = %s(%s);' % (m.name, c_args), file=self.fd)
-                six.print_('        if (is_null($this->_cptr)) { throw new Exception("Constructor for ', klass.name, ' failed "); }', file=self.fd)
-                six.print_('    }', file=self.fd)
-                six.print_('', file=self.fd)
+                print('    public $_cptr = null;', file=self.fd)
+                print('', file=self.fd)
+                print('    public function __construct(%s) {' % php_args, file=self.fd)
+                print('        $this->_cptr = %s(%s);' % (m.name, c_args), file=self.fd)
+                print('        if (is_null($this->_cptr)) { throw new Exception("Constructor for ', klass.name, ' failed "); }', file=self.fd)
+                print('    }', file=self.fd)
+                print('', file=self.fd)
 
             elif name.startswith(method_prefix) and m.args \
                     and clean_type(unconstify(m.args[0][0])) != klass.name:
@@ -185,10 +184,10 @@ function lassoGetRequestTypeFromSoapMsg($mesg) {
                         c_args.append('$%s' % arg_name)
                 php_args = ', '.join(php_args)
                 c_args = ', '.join(c_args)
-                six.print_('    public static function %s(%s) {' % (php_name, php_args), file=self.fd)
-                six.print_('        return cptrToPhp(%s(%s));' % (m.name, c_args), file=self.fd)
-                six.print_('    }', file=self.fd)
-                six.print_('', file=self.fd)
+                print('    public static function %s(%s) {' % (php_name, php_args), file=self.fd)
+                print('        return cptrToPhp(%s(%s));' % (m.name, c_args), file=self.fd)
+                print('    }', file=self.fd)
+                print('', file=self.fd)
 
 
 
@@ -200,50 +199,50 @@ function lassoGetRequestTypeFromSoapMsg($mesg) {
             'class': c.name
         }
 
-        six.print_('''\
+        print('''\
     /**
     * @return  %(docstring)s
     */
     protected function get_%(name)s() {''' % d, file=self.fd)
-        six.print_('        $t = %(class)s_%(name)s_get($this->_cptr);' % d, file=self.fd)
+        print('        $t = %(class)s_%(name)s_get($this->_cptr);' % d, file=self.fd)
         if self.is_object(m):
-            six.print_('        $t = cptrToPhp($t);', file=self.fd)
+            print('        $t = cptrToPhp($t);', file=self.fd)
         elif (is_glist(m) or is_hashtable(m)) and self.is_object(element_type(m)):
-                six.print_('        foreach ($t as $key => $item) {', file=self.fd)
-                six.print_('            $t[$key] = cptrToPhp($item);', file=self.fd)
-                six.print_('        }', file=self.fd)
+                print('        foreach ($t as $key => $item) {', file=self.fd)
+                print('            $t[$key] = cptrToPhp($item);', file=self.fd)
+                print('        }', file=self.fd)
         elif is_hashtable(m) or (is_glist(m) and (is_cstring(element_type(m)) \
                 or is_xml_node(element_type(m)))) or is_int(m, self.binding_data) \
                 or is_boolean(m) or is_cstring(m) or is_xml_node(m):
             pass
         else:
             raise Exception('Cannot generate a Php getter %s.%s' % (c,m))
-        six.print_('        return $t;', file=self.fd)
-        six.print_('    }', file=self.fd)
+        print('        return $t;', file=self.fd)
+        print('    }', file=self.fd)
 
     def generate_setter(self, c, m):
         d = { 'type': arg_type(m), 'name': format_as_camelcase(arg_name(m)),
                 'docstring': self.get_docstring_return_type(arg_type(m)), 'class': c.name }
-        six.print_('    protected function set_%(name)s($value) {' % d, file=self.fd)
+        print('    protected function set_%(name)s($value) {' % d, file=self.fd)
         if self.is_object(m):
-            six.print_('        $value = $value->_cptr;', file=self.fd)
+            print('        $value = $value->_cptr;', file=self.fd)
         elif (is_glist(m) or is_hashtable(m)) and self.is_object(element_type(m)):
-            six.print_('        $array = array();', file=self.fd)
-            six.print_('        if (!is_null($value)) {', file=self.fd)
-            six.print_('            foreach ($value as $key => $item) {', file=self.fd)
-            six.print_('                $array[$key] = $item->_cptr;', file=self.fd)
-            six.print_('            }', file=self.fd)
-            six.print_('        }', file=self.fd)
-            six.print_('        $value = $array;', file=self.fd)
+            print('        $array = array();', file=self.fd)
+            print('        if (!is_null($value)) {', file=self.fd)
+            print('            foreach ($value as $key => $item) {', file=self.fd)
+            print('                $array[$key] = $item->_cptr;', file=self.fd)
+            print('            }', file=self.fd)
+            print('        }', file=self.fd)
+            print('        $value = $array;', file=self.fd)
         elif is_hashtable(m) or (is_glist(m) and (is_cstring(element_type(m)) \
                 or is_xml_node(element_type(m)))) or is_int(m, self.binding_data) \
                 or is_boolean(m) or is_cstring(m) or is_xml_node(m):
             pass
         else:
             raise Exception('Cannot generate a Php setter %s.%s' % (c,m))
-        six.print_('        %(class)s_%(name)s_set($this->_cptr, $value);' % d, file=self.fd)
-        six.print_('    }', file=self.fd)
-        six.print_('', file=self.fd)
+        print('        %(class)s_%(name)s_set($this->_cptr, $value);' % d, file=self.fd)
+        print('    }', file=self.fd)
+        print('', file=self.fd)
 
     def generate_getters_and_setters(self, klass):
         for m in klass.members:
@@ -271,27 +270,27 @@ function lassoGetRequestTypeFromSoapMsg($mesg) {
             mname = re.match(r'lasso_.*_get_(\w+)', meth_name).group(1)
             mname = format_as_camelcase(mname)
 
-            six.print_('    /**', file=self.fd)
-            six.print_('     * @return %s' % self.get_docstring_return_type(m.return_type), file=self.fd)
-            six.print_('     */', file=self.fd)
-            six.print_('    protected function get_%s() {' % mname, file=self.fd)
+            print('    /**', file=self.fd)
+            print('     * @return %s' % self.get_docstring_return_type(m.return_type), file=self.fd)
+            print('     */', file=self.fd)
+            print('    protected function get_%s() {' % mname, file=self.fd)
             if self.is_object(m.return_type):
-                six.print_('        $cptr = %s($this->_cptr);' % meth_name, file=self.fd)
-                six.print_('        if (! is_null($cptr)) {', file=self.fd)
-                six.print_('            return cptrToPhp($cptr);', file=self.fd)
-                six.print_('        }', file=self.fd)
-                six.print_('        return null;', file=self.fd)
+                print('        $cptr = %s($this->_cptr);' % meth_name, file=self.fd)
+                print('        if (! is_null($cptr)) {', file=self.fd)
+                print('            return cptrToPhp($cptr);', file=self.fd)
+                print('        }', file=self.fd)
+                print('        return null;', file=self.fd)
             else:
-                six.print_('        return %s($this->_cptr);' % meth_name, file=self.fd)
-            six.print_('    }', file=self.fd)
+                print('        return %s($this->_cptr);' % meth_name, file=self.fd)
+            print('    }', file=self.fd)
             if setter:
-                six.print_('    protected function set_%s($value) {' % mname, file=self.fd)
+                print('    protected function set_%s($value) {' % mname, file=self.fd)
                 if self.is_object(m.return_type):
-                    six.print_('        %s($this->_cptr, $value->_cptr);' % setter.name, file=self.fd)
+                    print('        %s($this->_cptr, $value->_cptr);' % setter.name, file=self.fd)
                 else:
-                    six.print_('        %s($this->_cptr, $value);' % setter.name, file=self.fd)
-                six.print_('    }', file=self.fd)
-            six.print_('', file=self.fd)
+                    print('        %s($this->_cptr, $value);' % setter.name, file=self.fd)
+                print('    }', file=self.fd)
+            print('', file=self.fd)
 
         # second pass on methods, real methods
         method_prefix = format_as_underscored(klass.name) + '_'
@@ -356,26 +355,26 @@ function lassoGetRequestTypeFromSoapMsg($mesg) {
                 c_args = ''
 
             if m.docstring:
-                six.print_(self.generate_docstring(m, mname, 4), file=self.fd)
-            six.print_('    public function %s(%s) {' % (
+                print(self.generate_docstring(m, mname, 4), file=self.fd)
+            print('    public function %s(%s) {' % (
                     format_underscore_as_camelcase(mname), php_args), file=self.fd)
             if m.return_type == 'void':
-                six.print_('        %s($this->_cptr%s);' % (cname, c_args), file=self.fd)
+                print('        %s($this->_cptr%s);' % (cname, c_args), file=self.fd)
             elif is_rc(m.return_type):
-                six.print_('        $rc = %s($this->_cptr%s);' % (cname, c_args), file=self.fd)
-                six.print_('        if ($rc == 0) {', file=self.fd)
-                six.print_('            return 0;', file=self.fd)
-                six.print_('        } else if ($rc > 0) {', file=self.fd) # recoverable error
-                six.print_('            return $rc;', file=self.fd)
-                six.print_('        } else if ($rc < 0) {', file=self.fd) # unrecoverable error
-                six.print_('            LassoError::throw_on_rc($rc);', file=self.fd)
-                six.print_('        }', file=self.fd)
+                print('        $rc = %s($this->_cptr%s);' % (cname, c_args), file=self.fd)
+                print('        if ($rc == 0) {', file=self.fd)
+                print('            return 0;', file=self.fd)
+                print('        } else if ($rc > 0) {', file=self.fd) # recoverable error
+                print('            return $rc;', file=self.fd)
+                print('        } else if ($rc < 0) {', file=self.fd) # unrecoverable error
+                print('            LassoError::throw_on_rc($rc);', file=self.fd)
+                print('        }', file=self.fd)
             else:
-                six.print_('        return %s($this->_cptr%s);' % (cname, c_args), file=self.fd)
-            six.print_('    }', file=self.fd)
-            six.print_('', file=self.fd)
+                print('        return %s($this->_cptr%s);' % (cname, c_args), file=self.fd)
+            print('    }', file=self.fd)
+            print('', file=self.fd)
 
-        six.print_('', file=self.fd)
+        print('', file=self.fd)
 
     def generate_docstring(self, func, method_name, indent):
         docstring = func.docstring.orig_docstring
@@ -435,7 +434,7 @@ function lassoGetRequestTypeFromSoapMsg($mesg) {
             cat = exc_cat.attrib.get('name')
             done_cats.append(cat)
             parent_cat = exc_cat.attrib.get('parent', '')
-            six.print_('''\
+            print('''\
 /**
  * @package Lasso
  */
@@ -460,7 +459,7 @@ class Lasso%sError extends Lasso%sError {}
                 else:
                     parent_cat = ''
 
-                six.print_('''\
+                print('''\
 /**
  * @package Lasso
  */
@@ -468,7 +467,7 @@ class Lasso%sError extends Lasso%sError {}
 ''' % (cat, parent_cat), file=self.fd)
 
             if detail not in exceptions_dict:
-                six.print_('''\
+                print('''\
 /**
  * @package Lasso
  */
@@ -478,7 +477,7 @@ class Lasso%sError extends Lasso%sError {
 ''' % (detail, cat, c[1]), file=self.fd)
                 exceptions_dict[detail] = c[1]
 
-        six.print_('''\
+        print('''\
 /**
  * @package Lasso
  */
@@ -486,9 +485,9 @@ class LassoError extends Exception {
     private static $exceptions_dict = array(''', file=self.fd)
 
         for k, v in exceptions_dict.items():
-            six.print_('        %s => "Lasso%sError",' % (v, k), file=self.fd)
+            print('        %s => "Lasso%sError",' % (v, k), file=self.fd)
 
-        six.print_('''\
+        print('''\
     );
 
     public static function throw_on_rc($rc) {
@@ -502,6 +501,6 @@ class LassoError extends Exception {
 ''', file=self.fd)
 
     def generate_footer(self):
-        six.print_('''\
+        print('''\
 ?>''', file=self.fd)
 
diff --git a/bindings/php7/wrapper_header.py b/bindings/php7/wrapper_header.py
index 5236571a..22908945 100644
--- a/bindings/php7/wrapper_header.py
+++ b/bindings/php7/wrapper_header.py
@@ -17,7 +17,6 @@
 #
 # You should have received a copy of the GNU General Public License
 # along with this program; if not, see <http://www.gnu.org/licenses/>.
-import six
 
 class WrapperHeader:
     def __init__(self, binding_data, fd, functions_list):
@@ -32,7 +31,7 @@ class WrapperHeader:
 
     def generate_header(self):
         # FIXME: Get the current version and name
-        six.print_('''\
+        print('''\
 /* this file has been generated automatically; do not edit */
 
 #include "../../config.h"
@@ -51,11 +50,11 @@ PHP_MSHUTDOWN_FUNCTION(lasso);
 
     def generate_functions_list(self):
         for m in self.functions_list:
-            six.print_('PHP_FUNCTION(%s);' % m, file=self.fd)
-        six.print_('', file=self.fd)
+            print('PHP_FUNCTION(%s);' % m, file=self.fd)
+        print('', file=self.fd)
 
     def generate_footer(self):
-        six.print_('''\
+        print('''\
 extern zend_module_entry lasso_module_entry;
 #define phpext_lasso_ptr &lasso_module_entry
 
diff --git a/bindings/php7/wrapper_source.py b/bindings/php7/wrapper_source.py
index c429e563..3d434402 100644
--- a/bindings/php7/wrapper_source.py
+++ b/bindings/php7/wrapper_source.py
@@ -20,7 +20,6 @@
 
 import sys
 import os
-import six
 
 from utils import *
 
@@ -53,17 +52,17 @@ class WrapperSource:
         self.functions_list.append('lasso_init')
         self.functions_list.append('lasso_shutdown')
 
-        six.print_('''\
+        print('''\
 /* this file has been generated automatically; do not edit */
 ''', file=self.fd)
 
-        six.print_(open(os.path.join(self.src_dir,'wrapper_source_top.c')).read(), file=self.fd)
+        print(open(os.path.join(self.src_dir,'wrapper_source_top.c')).read(), file=self.fd)
 
         for h in self.binding_data.headers:
-            six.print_('#include <%s>' % h, file=self.fd)
-        six.print_('', file=self.fd)
+            print('#include <%s>' % h, file=self.fd)
+        print('', file=self.fd)
 
-        six.print_('''\
+        print('''\
 PHP_MINIT_FUNCTION(lasso)
 {
     le_lasso_server = zend_register_list_destructors_ex(php_gobject_generic_destructor, NULL, PHP_LASSO_SERVER_RES_NAME, module_number);
@@ -71,25 +70,25 @@ PHP_MINIT_FUNCTION(lasso)
 ''', file=self.fd)
 
     def generate_constants(self):
-        six.print_('    /* Constants (both enums and defines) */', file=self.fd)
+        print('    /* Constants (both enums and defines) */', file=self.fd)
         for c in self.binding_data.constants:
             if c[0] == 'i':
-                six.print_('    REGISTER_LONG_CONSTANT("%s", %s, CONST_CS|CONST_PERSISTENT);' % (c[1], c[1]), file=self.fd)
+                print('    REGISTER_LONG_CONSTANT("%s", %s, CONST_CS|CONST_PERSISTENT);' % (c[1], c[1]), file=self.fd)
             elif c[0] == 's':
-                six.print_('    REGISTER_STRING_CONSTANT("%s", (char*) %s, CONST_CS|CONST_PERSISTENT);' % (c[1], c[1]), file=self.fd)
+                print('    REGISTER_STRING_CONSTANT("%s", (char*) %s, CONST_CS|CONST_PERSISTENT);' % (c[1], c[1]), file=self.fd)
             elif c[0] == 'b':
-                six.print_('''\
+                print('''\
 #ifdef %s
     REGISTER_LONG_CONSTANT("%s", 1, CONST_CS|CONST_PERSISTENT);
 #else
     REGISTER_LONG_CONSTANT("%s", 0, CONST_CS|CONST_PERSISTENT);
 #endif''' % (c[1], c[1], c[1]), file=self.fd)
             else:
-                six.print_('E: unknown constant type: %r' % c[0], file=sys.stderr)
-        six.print_('', file=self.fd)
+                print('E: unknown constant type: %r' % c[0], file=sys.stderr)
+        print('', file=self.fd)
 
     def generate_middle(self):
-        six.print_('''\
+        print('''\
     return SUCCESS;
 }
 
@@ -107,21 +106,21 @@ PHP_MSHUTDOWN_FUNCTION(lasso)
         # first we free the previous value
         p = (zval_name, c_variable)
         q = { 'zval_name' : zval_name, 'c_variable' : c_variable }
-        six.print_('    zval_dtor(%s);' % zval_name, file=self.fd)
+        print('    zval_dtor(%s);' % zval_name, file=self.fd)
         if is_pointer(type):
-            six.print_('    if (! %s) {' % c_variable, file=self.fd)
-            six.print_('       ZVAL_NULL(%s);' % zval_name, file=self.fd)
-            six.print_('    } else {', file=self.fd)
+            print('    if (! %s) {' % c_variable, file=self.fd)
+            print('       ZVAL_NULL(%s);' % zval_name, file=self.fd)
+            print('    } else {', file=self.fd)
         if is_int(type, self.binding_data):
-            six.print_('    ZVAL_LONG(%s, %s);' % p, file=self.fd)
+            print('    ZVAL_LONG(%s, %s);' % p, file=self.fd)
         elif is_boolean(type):
-            six.print_('    ZVAL_BOOL(%s, %s);' % p, file=self.fd)
+            print('    ZVAL_BOOL(%s, %s);' % p, file=self.fd)
         elif is_cstring(type):
-            six.print_('    ZVAL_STRING(%s, (char*)%s);' % p, file=self.fd)
+            print('    ZVAL_STRING(%s, (char*)%s);' % p, file=self.fd)
             if free and not is_const(type):
-                six.print_('g_free(%s)' % c_variable, file=self.fd)
+                print('g_free(%s)' % c_variable, file=self.fd)
         elif arg_type(type) == 'xmlNode*':
-            six.print_('''\
+            print('''\
     {
         char* xmlString = get_string_from_xml_node(%(c_variable)s);
         if (xmlString) {
@@ -146,11 +145,11 @@ PHP_MSHUTDOWN_FUNCTION(lasso)
                 free_function = 'g_list_free(%(c_variable)s);'
             else:
                 raise Exception('unknown element-type: ' + repr(type))
-            six.print_('     %s((GList*)%s, &%s);' % (function, c_variable, zval_name), file=self.fd)
+            print('     %s((GList*)%s, &%s);' % (function, c_variable, zval_name), file=self.fd)
             if free:
-                six.print_('   ', free_function % q, file=self.fd)
+                print('   ', free_function % q, file=self.fd)
         elif is_object(type):
-            six.print_('''\
+            print('''\
     if (G_IS_OBJECT(%(c_variable)s)) {
         PhpGObjectPtr *obj = PhpGObjectPtr_New(G_OBJECT(%(c_variable)s));
         zend_resource *res = zend_register_resource(obj, le_lasso_server);
@@ -159,7 +158,7 @@ PHP_MSHUTDOWN_FUNCTION(lasso)
         ZVAL_NULL(%(zval_name)s);
     }''' % q, file=self.fd)
             if free:
-                six.print_('''\
+                print('''\
     if (%(c_variable)s) {
         g_object_unref(%(c_variable)s); // If constructor ref is off by one'
     }''' % q, file=self.fd)
@@ -167,7 +166,7 @@ PHP_MSHUTDOWN_FUNCTION(lasso)
         else:
             raise Exception('unknown type: ' + repr(type) + unconstify(arg_type(type)))
         if is_pointer(type):
-            six.print_('    }', file=self.fd)
+            print('    }', file=self.fd)
 
 
 
@@ -176,20 +175,20 @@ PHP_MSHUTDOWN_FUNCTION(lasso)
             return
 
         if is_boolean(arg):
-            six.print_('    RETVAL_BOOL(return_c_value);', file=self.fd)
+            print('    RETVAL_BOOL(return_c_value);', file=self.fd)
         elif is_int(arg, self.binding_data):
-            six.print_('    RETVAL_LONG(return_c_value);', file=self.fd)
+            print('    RETVAL_LONG(return_c_value);', file=self.fd)
         elif is_cstring(arg):
-            six.print_('''\
+            print('''\
     if (return_c_value) {
         RETVAL_STRING((char*)return_c_value);
     } else {
         RETVAL_NULL();
     }''', file=self.fd)
             if free:
-                six.print_('    free(return_c_value);', file=self.fd)
+                print('    free(return_c_value);', file=self.fd)
         elif is_xml_node(arg):
-            six.print_('''\
+            print('''\
     {
         char* xmlString = get_string_from_xml_node(return_c_value);
         if (xmlString) {
@@ -200,43 +199,43 @@ PHP_MSHUTDOWN_FUNCTION(lasso)
     }
 ''', file=self.fd)
             if free:
-                six.print_('    lasso_release_xml_node(return_c_value);', file=self.fd)
+                print('    lasso_release_xml_node(return_c_value);', file=self.fd)
         elif is_glist(arg):
             el_type = element_type(arg)
             if is_cstring(el_type):
-                six.print_('''\
+                print('''\
     set_array_from_list_of_strings((GList*)return_c_value, &return_value);
 ''', file=self.fd)
                 if free:
-                    six.print_('    lasso_release_list_of_strings(return_c_value);', file=self.fd)
+                    print('    lasso_release_list_of_strings(return_c_value);', file=self.fd)
             elif is_xml_node(el_type):
-                six.print_('''\
+                print('''\
     set_array_from_list_of_xmlnodes((GList*)return_c_value, &return_value);
 ''', file=self.fd)
                 if free or is_transfer_full(arg):
-                    six.print_('    lasso_release_list_of_xml_node(return_c_value);', file=self.fd)
+                    print('    lasso_release_list_of_xml_node(return_c_value);', file=self.fd)
             elif is_object(el_type):
-                six.print_('''\
+                print('''\
     set_array_from_list_of_objects((GList*)return_c_value, &return_value);
 ''', file=self.fd)
                 if free:
-                    six.print_('    lasso_release_list_of_gobjects(return_c_value);', file=self.fd)
+                    print('    lasso_release_list_of_gobjects(return_c_value);', file=self.fd)
             else:
                 raise Exception('cannot return value for %s' % (arg,))
         elif is_hashtable(arg):
             el_type = element_type(arg)
             if is_object(el_type):
-                six.print_('''\
+                print('''\
     set_array_from_hashtable_of_objects(return_c_value, &return_value);
 ''', file=self.fd)
             else:
                 if not is_cstring(arg):
                     print >>sys.stderr, 'W: %s has no explicit string annotation' % (arg,)
-                six.print_('''\
+                print('''\
     set_array_from_hashtable_of_strings(return_c_value, &return_value);
 ''', file=self.fd)
         elif is_object(arg):
-            six.print_('''\
+            print('''\
     if (return_c_value) {
         PhpGObjectPtr *self;
         self = PhpGObjectPtr_New(G_OBJECT(return_c_value));
@@ -246,7 +245,7 @@ PHP_MSHUTDOWN_FUNCTION(lasso)
         RETVAL_NULL();
     }''', file=self.fd)
             if free:
-                six.print_('    lasso_release_gobject(return_c_value);', file=self.fd)
+                print('    lasso_release_gobject(return_c_value);', file=self.fd)
         else:
             raise Exception('cannot return value for %s' % (arg,))
 
@@ -258,26 +257,26 @@ PHP_MSHUTDOWN_FUNCTION(lasso)
         else:
             name = m.name
         self.functions_list.append(name)
-        six.print_('''PHP_FUNCTION(%s)
+        print('''PHP_FUNCTION(%s)
 {''' % name, file=self.fd)
         parse_tuple_format = []
         parse_tuple_args = []
         for arg in m.args:
             if is_out(arg):
-                six.print_('   zval *php_out_%s = NULL;' % arg_name(arg), file=self.fd)
-                six.print_('   %s %s;' % (var_type(arg), arg_name(arg)), file=self.fd)
+                print('   zval *php_out_%s = NULL;' % arg_name(arg), file=self.fd)
+                print('   %s %s;' % (var_type(arg), arg_name(arg)), file=self.fd)
                 parse_tuple_format.append('z!')
                 parse_tuple_args.append('&php_out_%s' % arg_name(arg))
             elif is_cstring(arg):
                 parse_tuple_format.append('s!')
                 parse_tuple_args.append('&%s_str, &%s_len' % (arg_name(arg), arg_name(arg)))
-                six.print_('    %s %s = NULL;' % ('char*', arg_name(arg)), file=self.fd)
-                six.print_('    %s %s_str = NULL;' % ('char*', arg_name(arg)), file=self.fd)
-                six.print_('    %s %s_len = 0;' % ('size_t', arg_name(arg)), file=self.fd)
+                print('    %s %s = NULL;' % ('char*', arg_name(arg)), file=self.fd)
+                print('    %s %s_str = NULL;' % ('char*', arg_name(arg)), file=self.fd)
+                print('    %s %s_len = 0;' % ('size_t', arg_name(arg)), file=self.fd)
             elif is_int(arg, self.binding_data) or is_boolean(arg):
                 parse_tuple_format.append('l')
                 parse_tuple_args.append('&%s' % arg_name(arg))
-                six.print_('    %s %s;' % ('long', arg_name(arg)), file=self.fd)
+                print('    %s %s;' % ('long', arg_name(arg)), file=self.fd)
             elif is_time_t_pointer(arg):
                 parse_tuple_format.append('l')
                 parse_tuple_args.append('&%s' % (arg_name(arg),))
@@ -285,34 +284,34 @@ PHP_MSHUTDOWN_FUNCTION(lasso)
             elif is_xml_node(arg):
                 parse_tuple_format.append('s!')
                 parse_tuple_args.append('&%s_str, &%s_len' % (arg_name(arg), arg_name(arg)))
-                six.print_('    %s %s = NULL;' % ('xmlNode*', arg_name(arg)), file=self.fd)
-                six.print_('    %s %s_str = NULL;'  % ('char*', arg_name(arg)), file=self.fd)
-                six.print_('    %s %s_len = 0;' % ('size_t', arg_name(arg)), file=self.fd)
+                print('    %s %s = NULL;' % ('xmlNode*', arg_name(arg)), file=self.fd)
+                print('    %s %s_str = NULL;'  % ('char*', arg_name(arg)), file=self.fd)
+                print('    %s %s_len = 0;' % ('size_t', arg_name(arg)), file=self.fd)
             elif is_glist(arg):
                 parse_tuple_format.append('a!')
                 parse_tuple_args.append('&zval_%s' % arg_name(arg))
-                six.print_('    %s zval_%s = NULL;' % ('zval*', arg_name(arg)), file=self.fd)
-                six.print_('    %s %s = NULL;' % ('GList*', arg_name(arg)), file=self.fd)
+                print('    %s zval_%s = NULL;' % ('zval*', arg_name(arg)), file=self.fd)
+                print('    %s %s = NULL;' % ('GList*', arg_name(arg)), file=self.fd)
             elif is_object(arg):
                 parse_tuple_format.append('r')
                 parse_tuple_args.append('&zval_%s' % arg_name(arg))
-                six.print_('    %s %s = NULL;' % (arg_type(arg), arg_name(arg)), file=self.fd)
-                six.print_('    %s zval_%s = NULL;' % ('zval*', arg_name(arg)), file=self.fd)
-                six.print_('    %s cvt_%s = NULL;' % ('PhpGObjectPtr*', arg_name(arg)), file=self.fd)
+                print('    %s %s = NULL;' % (arg_type(arg), arg_name(arg)), file=self.fd)
+                print('    %s zval_%s = NULL;' % ('zval*', arg_name(arg)), file=self.fd)
+                print('    %s cvt_%s = NULL;' % ('PhpGObjectPtr*', arg_name(arg)), file=self.fd)
             else:
                 raise Exception('Unsupported type %s %s' % (arg, m))
 
         if m.return_type:
-            six.print_('    %s return_c_value;' % m.return_type, file=self.fd)
+            print('    %s return_c_value;' % m.return_type, file=self.fd)
         if m.return_type is not None and self.is_object(m.return_arg):
-            six.print_('    G_GNUC_UNUSED PhpGObjectPtr *self;', file=self.fd)
-        six.print_('', file=self.fd)
+            print('    G_GNUC_UNUSED PhpGObjectPtr *self;', file=self.fd)
+        print('', file=self.fd)
 
         parse_tuple_args = ', '.join(parse_tuple_args)
         if parse_tuple_args:
             parse_tuple_args = ', ' + parse_tuple_args
 
-        six.print_('''\
+        print('''\
     if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "%s"%s) == FAILURE) {
         RETURN_FALSE;
     }
@@ -322,24 +321,24 @@ PHP_MSHUTDOWN_FUNCTION(lasso)
             if is_out(arg):
                 continue
             elif is_xml_node(arg):
-                six.print_('''\
+                print('''\
         %(name)s = get_xml_node_from_string(%(name)s_str);''' % {'name': arg[1]}, file=self.fd)
             elif f.startswith('s'):
-                six.print_('''\
+                print('''\
         %(name)s = %(name)s_str;''' % {'name': arg[1]}, file=self.fd)
             elif f.startswith('r'):
-                six.print_('    if ((cvt_%s = (PhpGObjectPtr *)zend_fetch_resource(Z_RES_P(zval_%s), PHP_LASSO_SERVER_RES_NAME, le_lasso_server)) == NULL) {' % (arg[1], arg[1]), file=self.fd)
-                six.print_('        RETURN_FALSE;', file=self.fd)
-                six.print_('    }', file=self.fd)
-                six.print_('    %s = (%s)cvt_%s->obj;' % (arg[1], arg[0], arg[1]), file=self.fd)
+                print('    if ((cvt_%s = (PhpGObjectPtr *)zend_fetch_resource(Z_RES_P(zval_%s), PHP_LASSO_SERVER_RES_NAME, le_lasso_server)) == NULL) {' % (arg[1], arg[1]), file=self.fd)
+                print('        RETURN_FALSE;', file=self.fd)
+                print('    }', file=self.fd)
+                print('    %s = (%s)cvt_%s->obj;' % (arg[1], arg[0], arg[1]), file=self.fd)
             elif f.startswith('a'):
                 el_type = element_type(arg)
                 if is_cstring(el_type):
-                    six.print_('    %(name)s = get_list_from_array_of_strings(zval_%(name)s);' % {'name': arg[1]}, file=self.fd)
+                    print('    %(name)s = get_list_from_array_of_strings(zval_%(name)s);' % {'name': arg[1]}, file=self.fd)
                 elif is_object(el_type):
-                    six.print_('    %(name)s = get_list_from_array_of_objects(zval_%(name)s);' % {'name': arg[1]}, file=self.fd)
+                    print('    %(name)s = get_list_from_array_of_objects(zval_%(name)s);' % {'name': arg[1]}, file=self.fd)
                 else:
-                    six.print_('E: In %(function)s arg %(name)s is of type GList<%(elem)s>' % { 'function': m.name, 'name': arg[1], 'elem': el_type }, file=sys.stderr)
+                    print('E: In %(function)s arg %(name)s is of type GList<%(elem)s>' % { 'function': m.name, 'name': arg[1], 'elem': el_type }, file=sys.stderr)
             elif f == 'l':
                 pass
             else:
@@ -347,17 +346,17 @@ PHP_MSHUTDOWN_FUNCTION(lasso)
 
 
         if m.return_type is not None:
-            six.print_('    return_c_value = ', file=self.fd)
+            print('    return_c_value = ', file=self.fd)
             if 'new' in m.name:
-                six.print_('(%s)' % m.return_type, file=self.fd)
+                print('(%s)' % m.return_type, file=self.fd)
         else:
-            six.print_('   ', file=self.fd)
+            print('   ', file=self.fd)
         def special(x):
             if is_time_t_pointer(x):
                 return '%(name)s ? &%(name)s : NULL' % { 'name': arg_name(x) }
             else:
                 return ref_name(x)
-        six.print_('%s(%s);' % (m.name, ', '.join([special(x) for x in m.args])), file=self.fd)
+        print('%s(%s);' % (m.name, ', '.join([special(x) for x in m.args])), file=self.fd)
         # Free the converted arguments
 
         for f, arg in zip(parse_tuple_format, m.args):
@@ -368,21 +367,21 @@ PHP_MSHUTDOWN_FUNCTION(lasso)
                 self.set_zval('php_out_%s' % argname, argname, unref_type(arg), free = free)
                 pass
             elif argtype == 'xmlNode*':
-                six.print_('    xmlFree(%s);' % argname, file=self.fd)
+                print('    xmlFree(%s);' % argname, file=self.fd)
             elif f.startswith('a'):
                 el_type = element_type(arg)
                 if is_cstring(el_type):
-                    six.print_('    if (%(name)s) {' % { 'name': arg[1] }, file=self.fd)
-                    six.print_('        free_glist(&%(name)s,(GFunc)free);' % { 'name': arg[1] }, file=self.fd)
-                    six.print_('    }', file=self.fd)
+                    print('    if (%(name)s) {' % { 'name': arg[1] }, file=self.fd)
+                    print('        free_glist(&%(name)s,(GFunc)free);' % { 'name': arg[1] }, file=self.fd)
+                    print('    }', file=self.fd)
 
         try:
             self.return_value(m.return_arg, is_transfer_full(m.return_arg, default=True))
         except:
             raise Exception('Cannot return value for function %s' % m)
 
-        six.print_('}', file=self.fd)
-        six.print_('', file=self.fd)
+        print('}', file=self.fd)
+        print('', file=self.fd)
 
     def generate_members(self, c):
         for m in c.members:
@@ -395,16 +394,16 @@ PHP_MSHUTDOWN_FUNCTION(lasso)
         type = arg_type(m)
 
         function_name = '%s_%s_get' % (klassname, format_as_camelcase(name))
-        six.print_('''PHP_FUNCTION(%s)
+        print('''PHP_FUNCTION(%s)
 {''' % function_name, file=self.fd)
         self.functions_list.append(function_name)
 
-        six.print_('    %s return_c_value;' % type, file=self.fd)
-        six.print_('    %s* this;' % klassname, file=self.fd)
-        six.print_('    zval* zval_this;', file=self.fd)
-        six.print_('    PhpGObjectPtr *cvt_this;', file=self.fd)
-        six.print_('', file=self.fd)
-        six.print_('''\
+        print('    %s return_c_value;' % type, file=self.fd)
+        print('    %s* this;' % klassname, file=self.fd)
+        print('    zval* zval_this;', file=self.fd)
+        print('    PhpGObjectPtr *cvt_this;', file=self.fd)
+        print('', file=self.fd)
+        print('''\
     if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "r", &zval_this) == FAILURE) {
         RETURN_FALSE;
     }
@@ -414,23 +413,23 @@ PHP_MSHUTDOWN_FUNCTION(lasso)
     }
     this = (%s*)cvt_this->obj;
 ''' % (klassname), file=self.fd)
-        six.print_('    return_c_value = (%s)this->%s;' % (type, name), file=self.fd)
+        print('    return_c_value = (%s)this->%s;' % (type, name), file=self.fd)
         self.return_value(m)
-        six.print_('}', file=self.fd)
-        six.print_('', file=self.fd)
+        print('}', file=self.fd)
+        print('', file=self.fd)
 
     def generate_setter(self, c, m):
         klassname = c.name
         name = arg_name(m)
         type = arg_type(m)
         function_name = '%s_%s_set' % (klassname, format_as_camelcase(name))
-        six.print_('''PHP_FUNCTION(%s)
+        print('''PHP_FUNCTION(%s)
 {''' % function_name, file=self.fd)
         self.functions_list.append(function_name)
 
-        six.print_('    %s* this;' % klassname, file=self.fd)
-        six.print_('    zval* zval_this;', file=self.fd)
-        six.print_('    PhpGObjectPtr *cvt_this;', file=self.fd)
+        print('    %s* this;' % klassname, file=self.fd)
+        print('    zval* zval_this;', file=self.fd)
+        print('    PhpGObjectPtr *cvt_this;', file=self.fd)
 
         # FIXME: This bloc should be factorised
         parse_tuple_format = ''
@@ -439,41 +438,41 @@ PHP_MSHUTDOWN_FUNCTION(lasso)
             # arg_type = arg_type.replace('const ', '')
             parse_tuple_format += 's'
             parse_tuple_args.append('&%s_str, &%s_len' % (name, name))
-            six.print_('    %s %s_str = NULL;' % ('char*', name), file=self.fd)
-            six.print_('    %s %s_len = 0;' % ('size_t', name), file=self.fd)
+            print('    %s %s_str = NULL;' % ('char*', name), file=self.fd)
+            print('    %s %s_len = 0;' % ('size_t', name), file=self.fd)
         elif is_int(m, self.binding_data) or is_boolean(m):
             parse_tuple_format += 'l'
             parse_tuple_args.append('&%s' % name)
-            six.print_('    %s %s;' % ('long', name), file=self.fd)
+            print('    %s %s;' % ('long', name), file=self.fd)
         # Must also handle lists of Objects
         elif is_glist(m) or is_hashtable(m):
             parse_tuple_format += 'a'
             parse_tuple_args.append('&zval_%s' % name)
-            six.print_('    %s zval_%s;' % ('zval*', name), file=self.fd)
+            print('    %s zval_%s;' % ('zval*', name), file=self.fd)
         elif is_object(m):
             parse_tuple_format += 'r'
             parse_tuple_args.append('&zval_%s' % name)
-            six.print_('    %s zval_%s = NULL;' % ('zval*', name), file=self.fd)
-            six.print_('    %s cvt_%s = NULL;' % ('PhpGObjectPtr*', name), file=self.fd)
+            print('    %s zval_%s = NULL;' % ('zval*', name), file=self.fd)
+            print('    %s cvt_%s = NULL;' % ('PhpGObjectPtr*', name), file=self.fd)
         else:
             raise Exception('Cannot make a setter for %s.%s' % (c,m))
 
         if parse_tuple_args:
             parse_tuple_arg = parse_tuple_args[0]
         else:
-            six.print_('}', file=self.fd)
-            six.print_('', file=self.fd)
+            print('}', file=self.fd)
+            print('', file=self.fd)
             return
 
-        six.print_('', file=self.fd)
-        six.print_('''\
+        print('', file=self.fd)
+        print('''\
     if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "r%s", &zval_this, %s) == FAILURE) {
         return;
     }
 ''' % (parse_tuple_format, parse_tuple_arg), file=self.fd)
 
         # Get 'this' object
-        six.print_('''\
+        print('''\
     if ((cvt_this = (PhpGObjectPtr *)zend_fetch_resource(Z_RES_P(zval_this), PHP_LASSO_SERVER_RES_NAME, le_lasso_server)) == NULL) {
         RETURN_FALSE;
     }
@@ -483,53 +482,53 @@ PHP_MSHUTDOWN_FUNCTION(lasso)
         # Set new value
         d = { 'name': name, 'type': type }
         if is_int(m, self.binding_data) or is_boolean(m):
-            six.print_('    this->%s = %s;' % (name, name), file=self.fd)
+            print('    this->%s = %s;' % (name, name), file=self.fd)
         elif is_cstring(m):
-            six.print_('    lasso_assign_string(this->%(name)s, %(name)s_str);' % d, file=self.fd)
+            print('    lasso_assign_string(this->%(name)s, %(name)s_str);' % d, file=self.fd)
         elif is_xml_node(m):
-            six.print_('    lasso_assign_new_xml_node(this->%(name)s, get_xml_node_from_string(%(name)s_str));' % d, file=self.fd)
+            print('    lasso_assign_new_xml_node(this->%(name)s, get_xml_node_from_string(%(name)s_str));' % d, file=self.fd)
         elif is_glist(m):
             el_type = element_type(m)
             if is_cstring(el_type):
-                six.print_('    lasso_assign_new_list_of_strings(this->%(name)s, get_list_from_array_of_strings(zval_%(name)s));' % d, file=self.fd)
+                print('    lasso_assign_new_list_of_strings(this->%(name)s, get_list_from_array_of_strings(zval_%(name)s));' % d, file=self.fd)
             elif is_xml_node(el_type):
-                six.print_('    lasso_assign_new_list_of_xml_node(this->%(name)s, get_list_from_array_of_xmlnodes(zval_%(name)s))' % d, file=self.fd)
+                print('    lasso_assign_new_list_of_xml_node(this->%(name)s, get_list_from_array_of_xmlnodes(zval_%(name)s))' % d, file=self.fd)
             elif is_object(el_type):
-                six.print_('    lasso_assign_new_list_of_gobjects(this->%(name)s, get_list_from_array_of_objects(zval_%(name)s));' % d, file=self.fd)
+                print('    lasso_assign_new_list_of_gobjects(this->%(name)s, get_list_from_array_of_objects(zval_%(name)s));' % d, file=self.fd)
             else:
                 raise Exception('Cannot create C setter for %s.%s' % (c,m))
         elif is_hashtable(m):
             el_type = element_type(m)
-            six.print_('''\
+            print('''\
         {
             GHashTable *oldhash = this->%(name)s;''' % d, file=self.fd)
             if is_object(el_type):
-                six.print_('            this->%(name)s = get_hashtable_from_array_of_objects(zval_%(name)s);' % d, file=self.fd)
+                print('            this->%(name)s = get_hashtable_from_array_of_objects(zval_%(name)s);' % d, file=self.fd)
             else:
-                six.print_('            this->%(name)s = get_hashtable_from_array_of_strings(zval_%(name)s);' % d, file=self.fd)
-            six.print_('            g_hash_table_destroy(oldhash);', file=self.fd)
-            six.print_('        }', file=self.fd)
+                print('            this->%(name)s = get_hashtable_from_array_of_strings(zval_%(name)s);' % d, file=self.fd)
+            print('            g_hash_table_destroy(oldhash);', file=self.fd)
+            print('        }', file=self.fd)
         elif is_object(m):
-            six.print_('    if ((cvt_%(name)s = (PhpGObjectPtr*)zend_fetch_resource(Z_RES_P(zval_%(name)s), PHP_LASSO_SERVER_RES_NAME, le_lasso_server)) == NULL) {' % d, file=self.fd)
-            six.print_('        RETURN_FALSE;', file=self.fd)
-            six.print_('    }', file=self.fd)
-            six.print_('    lasso_assign_gobject(this->%(name)s, cvt_%(name)s->obj);' % d, file=self.fd)
+            print('    if ((cvt_%(name)s = (PhpGObjectPtr*)zend_fetch_resource(Z_RES_P(zval_%(name)s), PHP_LASSO_SERVER_RES_NAME, le_lasso_server)) == NULL) {' % d, file=self.fd)
+            print('        RETURN_FALSE;', file=self.fd)
+            print('    }', file=self.fd)
+            print('    lasso_assign_gobject(this->%(name)s, cvt_%(name)s->obj);' % d, file=self.fd)
 
-        six.print_('}', file=self.fd)
-        six.print_('', file=self.fd)
+        print('}', file=self.fd)
+        print('', file=self.fd)
 
     def generate_functions_list(self):
-        six.print_('''\
+        print('''\
 static zend_function_entry lasso_functions[] = {''', file=self.fd)
         for m in self.functions_list:
-            six.print_('    PHP_FE(%s, NULL)' % m, file=self.fd)
-        six.print_('''\
+            print('    PHP_FE(%s, NULL)' % m, file=self.fd)
+        print('''\
     {NULL, NULL, NULL, 0, 0}
 };
 ''', file=self.fd)
 
     def generate_footer(self):
-        six.print_('''\
+        print('''\
 zend_module_entry lasso_module_entry = {
 #if ZEND_MODULE_API_NO >= 20010901
     STANDARD_MODULE_HEADER,
diff --git a/bindings/python/examples/get_attributes_from_assertion.py b/bindings/python/examples/get_attributes_from_assertion.py
index 8f37a337..87236b91 100644
--- a/bindings/python/examples/get_attributes_from_assertion.py
+++ b/bindings/python/examples/get_attributes_from_assertion.py
@@ -1,10 +1,9 @@
 # Example SP Python code to get attributes from an assertion
 
-from six import print_
 
 for attribute in assertion.attributeStatement[0].attribute:
     if attribute.name == lasso.SAML2_ATTRIBUTE_NAME_EPR:
         continue
-    print_('attribute : ' + attribute.name)
+    print('attribute : ' + attribute.name)
     for value in attribute.attributeValue:
-        print_('  value : ' + value.any[0].content)
+        print('  value : ' + value.any[0].content)
diff --git a/bindings/python/lang.py b/bindings/python/lang.py
index 5ba4265c..1e7b36e1 100644
--- a/bindings/python/lang.py
+++ b/bindings/python/lang.py
@@ -19,7 +19,6 @@
 # along with this program; if not, see <http://www.gnu.org/licenses/>.
 
 import os
-from six import print_
 import sys
 import re
 import textwrap
@@ -34,9 +33,9 @@ def remove_bad_optional(args):
         if not '=' in x:
             non_opt = True
         elif non_opt:
-            print_('W: changed', x, file=sys.stderr, end=' ')
+            print('W: changed', x, file=sys.stderr, end=' ')
             x = re.sub(' *=.*', '', x)
-            print_('to', x, file=sys.stderr)
+            print('to', x, file=sys.stderr)
         new_args.append(x)
     new_args.reverse()
     return new_args
@@ -73,17 +72,17 @@ class Binding:
         if not name:
             raise Exception('Cannot free, missing a name')
         if is_cstring(type):
-            print_('    lasso_release_string(%s);' % name, file=fd)
+            print('    lasso_release_string(%s);' % name, file=fd)
         elif is_int(type, self.binding_data) or is_boolean(type):
             pass
         elif is_xml_node(type):
-            print_('    lasso_release_xml_node(%s);' % name, file=fd)
+            print('    lasso_release_xml_node(%s);' % name, file=fd)
         elif is_glist(type):
             etype = element_type(type)
             if is_cstring(etype):
-                print_('    lasso_release_list_of_strings(%s);' % name, file=fd)
+                print('    lasso_release_list_of_strings(%s);' % name, file=fd)
             elif is_object(etype):
-                print_('    lasso_release_list_of_gobjects(%s);' % name, file=fd)
+                print('    lasso_release_list_of_gobjects(%s);' % name, file=fd)
             else:
                 raise Exception('Unsupported caller owned return type %s' % ((repr(type), name),))
         elif is_hashtable(type):
@@ -91,11 +90,11 @@ class Binding:
             k_type = key_type(type)
             v_type = value_type(type)
             if is_cstring(el_type) or (is_cstring(k_type) and is_cstring(v_type)):
-                print_('    if (%s) { g_hash_table_destroy(%s); }' % (name, name), file=fd)
+                print('    if (%s) { g_hash_table_destroy(%s); }' % (name, name), file=fd)
             else:
                 raise Exception('Unsupported free value of type GHashTable: %s' % type)
         elif is_object(type):
-            print_('    if (return_value) g_object_unref(%s);' % name, file=fd)
+            print('    if (return_value) g_object_unref(%s);' % name, file=fd)
         else:
             raise Exception('Unsupported caller owned return type %s' % ((repr(type), name),))
 
@@ -116,7 +115,7 @@ class Binding:
         fd.close()
 
     def generate_header(self, fd):
-        print_('''\
+        print('''\
 # this file has been generated automatically; do not edit
 
 import _lasso
@@ -172,7 +171,7 @@ class frozendict(dict):
 
     def generate_exceptions(self, fd):
         done_cats = []
-        print_('''\
+        print('''\
 class Error(Exception):
     code = None
 
@@ -206,7 +205,7 @@ class Error(Exception):
             cat = exc_cat.attrib.get('name')
             done_cats.append(cat)
             parent_cat = exc_cat.attrib.get('parent', '')
-            print_('''\
+            print('''\
 class %sError(%sError):
     pass
 ''' % (cat, parent_cat), file=fd)
@@ -229,7 +228,7 @@ class %sError(%sError):
                 else:
                     parent_cat = ''
 
-                print_('''\
+                print('''\
 class %sError(%sError):
     pass
 ''' % (cat, parent_cat), file=fd)
@@ -247,19 +246,19 @@ class %sError(%sError):
                 # ordering would change)
                 continue
 
-            print_('''\
+            print('''\
 class %sError(%sError):
     pass
 ''' % (detail, cat), file=fd)
 
-        print_('exceptions_dict = {', file=fd)
+        print('exceptions_dict = {', file=fd)
         for k, v in exceptions_dict.items():
-            print_('    _lasso.%s: %sError,' % (v, k), file=fd)
-        print_('}', file=fd)
-        print_('', file=fd)
+            print('    _lasso.%s: %sError,' % (v, k), file=fd)
+        print('}', file=fd)
+        print('', file=fd)
 
     def generate_footer(self, fd):
-        print_('''
+        print('''
 
 def _profileGetIssuer(cls, *args, **kwargs):
     return profileGetIssuer(*args, **kwargs)
@@ -304,19 +303,19 @@ StringDict = dict
 ''', file=fd)
 
     def generate_constants(self, fd):
-        print_('### Constants (both enums and defines)', file=fd)
+        print('### Constants (both enums and defines)', file=fd)
         for c in self.binding_data.constants:
-            print_('%s = _lasso.%s' % (c[1][6:], c[1][6:]), file=fd)
+            print('%s = _lasso.%s' % (c[1][6:], c[1][6:]), file=fd)
         for c in self.binding_data.overrides.findall('constant'):
             name = c.attrib.get('name')
             if c.attrib.get('value'):
                 name = name[6:] # dropping LASSO_
                 value = c.attrib.get('value')
                 if value == 'True':
-                    print_('%s = True' % name, file=fd)
+                    print('%s = True' % name, file=fd)
                 else:
-                    print_('E: unknown value for constant: %r' % value, file=sys.stderr)
-        print_('', file=fd)
+                    print('E: unknown value for constant: %r' % value, file=sys.stderr)
+        print('', file=fd)
 
     def generate_class(self, clss, fd):
         klassname = clss.name[5:] # remove Lasso from class name
@@ -325,7 +324,7 @@ StringDict = dict
         else:
             parentname = clss.parent[5:]
 
-        print_('''class %(klassname)s(%(parentname)s):''' % locals(), file=fd)
+        print('''class %(klassname)s(%(parentname)s):''' % locals(), file=fd)
 
         methods = clss.methods[:]
         # constructor(s)
@@ -348,14 +347,14 @@ StringDict = dict
 
                 c_args = ', '.join(c_args)
                 py_args = ', ' + ', '.join(py_args)
-                print_('    def __init__(self%s):' % py_args, file=fd)
+                print('    def __init__(self%s):' % py_args, file=fd)
                 # XXX: could check self._cptr.typename to see if it got the
                 # right class type
-                print_('        self._cptr = _lasso.%s(%s)' % (
+                print('        self._cptr = _lasso.%s(%s)' % (
                         m.name[6:], c_args), file=fd)
-                print_('        if self._cptr is None:', file=fd)
-                print_('            raise Error(\'failed to create object\')', file=fd)
-                print_('', file=fd)
+                print('        if self._cptr is None:', file=fd)
+                print('            raise Error(\'failed to create object\')', file=fd)
+                print('', file=fd)
 
         for m in self.binding_data.functions:
             if m.name.startswith(method_prefix + 'new_'):
@@ -379,13 +378,13 @@ StringDict = dict
                     if '=' in x:
                         opt = True
                     elif opt:
-                        print_('W: non-optional follows optional,', m, file=sys.stderr)
+                        print('W: non-optional follows optional,', m, file=sys.stderr)
                 c_args = ', '.join(c_args)
                 py_args = ', ' + ', '.join(py_args)
-                print_('    @classmethod', file=fd)
-                print_('    def %s(cls%s):' % (constructor_name, py_args), file=fd)
-                print_('         return cptrToPy(_lasso.%s(%s))' % (m.name[6:], c_args), file=fd)
-                print_('', file=fd)
+                print('    @classmethod', file=fd)
+                print('    def %s(cls%s):' % (constructor_name, py_args), file=fd)
+                print('         return cptrToPy(_lasso.%s(%s))' % (m.name[6:], c_args), file=fd)
+                print('', file=fd)
 
         # create properties for members
         for m in clss.members:
@@ -393,13 +392,13 @@ StringDict = dict
             mname = format_as_camelcase(m[1])
             options = m[2]
             # getter
-            print_('    def get_%s(self):' % mname, file=fd)
-            print_('        t = _lasso.%s_%s_get(self._cptr)' % (
+            print('    def get_%s(self):' % mname, file=fd)
+            print('        t = _lasso.%s_%s_get(self._cptr)' % (
                     klassname, mname), file=fd)
             if is_int(m, self.binding_data) or is_xml_node(m) or is_cstring(m) or is_boolean(m):
                 pass
             elif is_object(m):
-                print_('        t = cptrToPy(t)', file=fd)
+                print('        t = cptrToPy(t)', file=fd)
             elif is_glist(m):
                 el_type = element_type(m)
                 if is_cstring(el_type):
@@ -407,54 +406,54 @@ StringDict = dict
                 elif is_xml_node(el_type):
                     pass
                 elif is_object(el_type):
-                    print_('        if not t: return t', file=fd)
-                    print_('        t = tuple([cptrToPy(x) for x in t])', file=fd)
+                    print('        if not t: return t', file=fd)
+                    print('        t = tuple([cptrToPy(x) for x in t])', file=fd)
                 else:
                     raise Exception('Unsupported python getter %s.%s' % (clss, m))
             elif is_hashtable(m):
                 el_type = element_type(m)
-                print_('        if not t: return t', file=fd)
+                print('        if not t: return t', file=fd)
                 if is_object(el_type):
-                    print_('        d2 = {}', file=fd)
-                    print_('        for k, v in t.items():', file=fd)
-                    print_('            d2[k] = cptrToPy(v)', file=fd)
-                    print_('        t = frozendict(d2)', file=fd)
+                    print('        d2 = {}', file=fd)
+                    print('        for k, v in t.items():', file=fd)
+                    print('            d2[k] = cptrToPy(v)', file=fd)
+                    print('        t = frozendict(d2)', file=fd)
                 else:
-                    print_('        t = frozendict(t)', file=fd)
+                    print('        t = frozendict(t)', file=fd)
             elif is_boolean(m) or is_int(m, self.binding_data) or is_xml_node(m) or is_cstring(m):
                 pass
             else:
                 raise Exception('Unsupported python getter %s.%s' % (clss, m))
-            print_('        return t;', file=fd)
+            print('        return t;', file=fd)
             # setter
-            print_('    def set_%s(self, value):' % mname, file=fd)
+            print('    def set_%s(self, value):' % mname, file=fd)
             if is_int(m, self.binding_data) or is_xml_node(m) or is_boolean(m):
                 pass
             elif is_cstring(m):
-                print_('        value = str2lasso(value)', file=fd)
+                print('        value = str2lasso(value)', file=fd)
             elif is_object(m):
-                print_('        if value is not None:', file=fd)
-                print_('            value = value and value._cptr', file=fd)
+                print('        if value is not None:', file=fd)
+                print('            value = value and value._cptr', file=fd)
             elif is_glist(m):
                 el_type = element_type(m)
                 if is_cstring(el_type) or is_xml_node(el_type):
                     pass
                 elif is_object(el_type):
-                    print_('        if value is not None:', file=fd)
-                    print_('            value = tuple([x._cptr for x in value])', file=fd)
+                    print('        if value is not None:', file=fd)
+                    print('            value = tuple([x._cptr for x in value])', file=fd)
                 else:
                     raise Exception('Unsupported python setter %s.%s' % (clss, m))
             elif is_hashtable(m):
-                print_('W: unsupported setter for hashtable %s' % (m,), file=sys.stderr)
+                print('W: unsupported setter for hashtable %s' % (m,), file=sys.stderr)
             else:
-                print_('W: unsupported setter for %s' % (m,), file=sys.stderr)
-            print_('        _lasso.%s_%s_set(self._cptr, value)' % (
+                print('W: unsupported setter for %s' % (m,), file=sys.stderr)
+            print('        _lasso.%s_%s_set(self._cptr, value)' % (
                     klassname, mname), file=fd)
-            print_('    %s = property(get_%s, set_%s)' % (mname, mname, mname), file=fd)
+            print('    %s = property(get_%s, set_%s)' % (mname, mname, mname), file=fd)
             old_mname = old_format_as_camelcase(m[1])
             if mname != old_mname:
-                print_('    %s = %s' % (old_mname, mname), file=fd)
-            print_('', file=fd)
+                print('    %s = %s' % (old_mname, mname), file=fd)
+            print('', file=fd)
 
         # first pass on methods, getting accessors
         # second pass on methods, real methods
@@ -464,7 +463,7 @@ StringDict = dict
                     m.name.endswith('_new_full'):
                 continue
             if not m.name.startswith(method_prefix):
-                print_('W:', m.name, 'vs', method_prefix, file=sys.stderr)
+                print('W:', m.name, 'vs', method_prefix, file=sys.stderr)
                 continue
 
             if m.rename:
@@ -501,7 +500,7 @@ StringDict = dict
                 if '=' in x:
                     opt = True
                 elif opt:
-                    print_('W: non-optional follow optional,', m, file=sys.stderr)
+                    print('W: non-optional follow optional,', m, file=sys.stderr)
 
             if py_args:
                 py_args = ', ' + ', '.join(py_args)
@@ -512,51 +511,51 @@ StringDict = dict
             else:
                 c_args = ''
 
-            print_('    def %s(self%s):' % (
+            print('    def %s(self%s):' % (
                     format_underscore_as_camelcase(mname), py_args), file=fd)
             if m.docstring:
-                print_("        '''", file=fd)
-                print_(self.format_docstring(m, mname, 8), file=fd)
-                print_("        '''", file=fd)
+                print("        '''", file=fd)
+                print(self.format_docstring(m, mname, 8), file=fd)
+                print("        '''", file=fd)
 
             if outarg:
-                print_("        %s = list((None,))" % outvar, file=fd)
+                print("        %s = list((None,))" % outvar, file=fd)
             return_type = m.return_type
             return_type_qualifier = m.return_type_qualifier
             assert is_int(make_arg(return_type),self.binding_data) or not outarg
             if return_type in (None, 'void'):
-                print_('        _lasso.%s(self._cptr%s)' % (
+                print('        _lasso.%s(self._cptr%s)' % (
                         function_name, c_args), file=fd)
             elif is_rc(m.return_arg):
-                print_('        rc = _lasso.%s(self._cptr%s)' % (
+                print('        rc = _lasso.%s(self._cptr%s)' % (
                         function_name, c_args), file=fd)
-                print_('        Error.raise_on_rc(rc)', file=fd)
+                print('        Error.raise_on_rc(rc)', file=fd)
             elif (is_int(m.return_arg, self.binding_data) or is_xml_node(m.return_arg) or
                     is_cstring(m.return_arg) or is_boolean(m.return_arg) or
                     is_hashtable(m.return_arg)):
-                print_('        return _lasso.%s(self._cptr%s)' % (
+                print('        return _lasso.%s(self._cptr%s)' % (
                         function_name, c_args), file=fd)
             elif is_glist(m.return_arg):
                 el_type = element_type(m.return_arg)
                 if is_object(el_type):
-                    print_('        value = _lasso.%s(self._cptr%s)' % (
+                    print('        value = _lasso.%s(self._cptr%s)' % (
                             function_name, c_args), file=fd)
-                    print_('        if value is not None:', file=fd)
-                    print_('            value = tuple([cptrToPy(x) for x in value])', file=fd)
-                    print_('        return value', file=fd)
+                    print('        if value is not None:', file=fd)
+                    print('            value = tuple([cptrToPy(x) for x in value])', file=fd)
+                    print('        return value', file=fd)
                 elif is_cstring(el_type) or is_xml_node(el_type):
-                    print_('        return _lasso.%s(self._cptr%s)' % (
+                    print('        return _lasso.%s(self._cptr%s)' % (
                             function_name, c_args), file=fd)
                 else:
                     raise Exception('Return Type GList<%s> is not supported' % el_type)
             elif is_object(m.return_arg):
-                print_('        return cptrToPy(_lasso.%s(self._cptr%s))' % (
+                print('        return cptrToPy(_lasso.%s(self._cptr%s))' % (
                         function_name, c_args), file=fd)
             else:
                 raise Exception('Return type %s is unsupported' % (m.return_arg,))
             if outarg:
-                print_('        return %s[0]' % outvar, file=fd)
-            print_('', file=fd)
+                print('        return %s[0]' % outvar, file=fd)
+            print('', file=fd)
         # transform methods to properties
         for m in methods:
             if len(m.args) > 1:
@@ -564,7 +563,7 @@ StringDict = dict
             name = m.rename or m.name
             suffix = name[len(method_prefix)+len('get_'):]
             if clss.getMember(suffix):
-                print_('W: method %s and member %s clashes' % (m.name, arg_name(clss.getMember(suffix))), file=sys.stderr)
+                print('W: method %s and member %s clashes' % (m.name, arg_name(clss.getMember(suffix))), file=sys.stderr)
                 continue
             if not name.startswith(method_prefix) or not name[len(method_prefix):].startswith('get_'):
                 continue
@@ -576,13 +575,13 @@ StringDict = dict
             pname = format_as_camelcase(name[len(method_prefix)+len('get_'):])
             fname = format_as_camelcase(name[len(method_prefix):])
             if not setter:
-                print_('    %s = property(%s)' % (pname, fname), file=fd)
+                print('    %s = property(%s)' % (pname, fname), file=fd)
             else:
                 f2name = format_as_camelcase(setter.name[len(method_prefix):])
-                print_('    %s = property(%s, %s)' % (pname, fname, f2name), file=fd)
+                print('    %s = property(%s, %s)' % (pname, fname, f2name), file=fd)
         if empty:
-            print_('    pass', file=fd)
-        print_('', file=fd)
+            print('    pass', file=fd)
+        print('', file=fd)
 
     def format_docstring(self, func, method_name, indent):
         if func.args:
@@ -601,7 +600,7 @@ StringDict = dict
                     return 'True'
                 if var == 'FALSE':
                     return 'False'
-                print_('W: unknown docstring thingie: %s' % s.group(1), file=sys.stderr)
+                print('W: unknown docstring thingie: %s' % s.group(1), file=sys.stderr)
             elif type == '@':
                 if var == first_arg_name:
                     var = 'self'
@@ -686,14 +685,14 @@ StringDict = dict
             else:
                 name = m.name[6:]
                 pname = format_as_camelcase(name)
-            print_('%s = _lasso.%s' % (pname, name), file=fd)
+            print('%s = _lasso.%s' % (pname, name), file=fd)
 
 
     def generate_wrapper(self, fd):
-        print_(open(os.path.join(self.src_dir,'wrapper_top.c')).read(), file=fd)
+        print(open(os.path.join(self.src_dir,'wrapper_top.c')).read(), file=fd)
         for h in self.binding_data.headers:
-            print_('#include <%s>' % h, file=fd)
-        print_('', file=fd)
+            print('#include <%s>' % h, file=fd)
+        print('', file=fd)
 
         self.generate_constants_wrapper(fd)
 
@@ -705,33 +704,33 @@ StringDict = dict
             for m in c.methods:
                 self.generate_function_wrapper(m, fd)
         self.generate_wrapper_list(fd)
-        print_(open(os.path.join(self.src_dir,'wrapper_bottom.c')).read(), file=fd)
+        print(open(os.path.join(self.src_dir,'wrapper_bottom.c')).read(), file=fd)
 
     def generate_constants_wrapper(self, fd):
-        print_('''static void
+        print('''static void
 register_constants(PyObject *d)
 {
     PyObject *obj;
 ''', file=fd)
         for c in self.binding_data.constants:
             if c[0] == 'i':
-                print_('    obj = PyInt_FromLong(%s);' % c[1], file=fd)
+                print('    obj = PyInt_FromLong(%s);' % c[1], file=fd)
             elif c[0] == 's':
-                print_('    obj = PyString_FromString((char*)%s);' % c[1], file=fd)
+                print('    obj = PyString_FromString((char*)%s);' % c[1], file=fd)
             elif c[0] == 'b':
-                print_('''\
+                print('''\
 #ifdef %s
     obj = Py_True;
 #else
     obj = Py_False;
 #endif''' % c[1], file=fd)
             else:
-                print_('E: unknown constant type: %r' % c[0], file=sys.stderr)
-            print_('    PyDict_SetItemString(d, "%s", obj);' % c[1][6:], file=fd)
+                print('E: unknown constant type: %r' % c[0], file=sys.stderr)
+            print('    PyDict_SetItemString(d, "%s", obj);' % c[1][6:], file=fd)
             if c[0] != 'b':  # refcount of Py_True/False should not be changed
-                print_('    Py_DECREF(obj);', file=fd)
-        print_('}', file=fd)
-        print_('', file=fd)
+                print('    Py_DECREF(obj);', file=fd)
+        print('}', file=fd)
+        print('', file=fd)
 
 
     def generate_member_wrapper(self, c, fd):
@@ -740,7 +739,7 @@ register_constants(PyObject *d)
             name = arg_name(m)
             mname = format_as_camelcase(arg_name(m))
             # getter
-            print_('''static PyObject*
+            print('''static PyObject*
 %s_%s_get(G_GNUC_UNUSED PyObject *self, PyObject *args)
 {''' % (klassname[5:], mname), file=fd)
             self.wrapper_list.append('%s_%s_get' % (klassname[5:], mname))
@@ -748,140 +747,140 @@ register_constants(PyObject *d)
             ftype = arg_type(m)
             if is_cstring(m):
                 ftype = 'char*'
-            print_('    %s return_value;' % ftype, file=fd)
-            print_('    PyObject* return_pyvalue;', file=fd)
-            print_('    PyGObjectPtr* cvt_this;', file=fd)
-            print_('    %s* this;' % klassname, file=fd)
-            print_('', file=fd)
-            print_('    if (! PyArg_ParseTuple(args, "O", &cvt_this)) return NULL;', file=fd)
-            print_('    this = (%s*)cvt_this->obj;' % klassname, file=fd)
-            print_('    return_value = this->%s;' % arg_name(m), file=fd)
+            print('    %s return_value;' % ftype, file=fd)
+            print('    PyObject* return_pyvalue;', file=fd)
+            print('    PyGObjectPtr* cvt_this;', file=fd)
+            print('    %s* this;' % klassname, file=fd)
+            print('', file=fd)
+            print('    if (! PyArg_ParseTuple(args, "O", &cvt_this)) return NULL;', file=fd)
+            print('    this = (%s*)cvt_this->obj;' % klassname, file=fd)
+            print('    return_value = this->%s;' % arg_name(m), file=fd)
             try:
                 self.return_value(fd, m)
             except:
-                print_('W: cannot make an assignment for', c, m, file=sys.stderr)
+                print('W: cannot make an assignment for', c, m, file=sys.stderr)
                 raise
-            print_('    return return_pyvalue;', file=fd)
-            print_('}', file=fd)
-            print_('', file=fd)
+            print('    return return_pyvalue;', file=fd)
+            print('}', file=fd)
+            print('', file=fd)
 
             # setter
-            print_('''static PyObject*
+            print('''static PyObject*
 %s_%s_set(G_GNUC_UNUSED PyObject *self, PyObject *args)
 {''' % (klassname[5:], mname), file=fd)
             self.wrapper_list.append('%s_%s_set' % (klassname[5:], mname))
 
-            print_('    PyGObjectPtr* cvt_this;', file=fd)
-            print_('    %s* this;' % klassname, file=fd)
+            print('    PyGObjectPtr* cvt_this;', file=fd)
+            print('    %s* this;' % klassname, file=fd)
             type = m[0]
             # Determine type class
             if is_cstring(m):
                 type = type.replace('const ', '')
                 parse_format = 'z'
                 parse_arg = '&value'
-                print_('    %s value;' % type, file=fd)
+                print('    %s value;' % type, file=fd)
             elif is_int(m, self.binding_data):
                 parse_format = 'l'
                 parse_arg = '&value'
-                print_('    long value;', file=fd)
+                print('    long value;', file=fd)
             elif is_glist(m) or is_hashtable(m) or is_xml_node(m) or is_boolean(m):
                 parse_format = 'O'
-                print_('    PyObject *cvt_value;', file=fd)
+                print('    PyObject *cvt_value;', file=fd)
                 parse_arg = '&cvt_value'
             elif is_object(m):
                 parse_format = 'O'
-                print_('    PyGObjectPtr *cvt_value;', file=fd)
+                print('    PyGObjectPtr *cvt_value;', file=fd)
                 parse_arg = '&cvt_value'
             else:
                 raise Exception('Unsupported field: %s' % (m,))
             # Get GObject
-            print_('    if (! PyArg_ParseTuple(args, "O%s", &cvt_this, %s)) return NULL;' % (
+            print('    if (! PyArg_ParseTuple(args, "O%s", &cvt_this, %s)) return NULL;' % (
                     parse_format, parse_arg), file=fd)
-            print_('    this = (%s*)cvt_this->obj;' % klassname, file=fd)
+            print('    this = (%s*)cvt_this->obj;' % klassname, file=fd)
             # Change value
             if is_int(m, self.binding_data):
-                print_('    this->%s = value;' % name, file=fd)
+                print('    this->%s = value;' % name, file=fd)
             elif is_boolean(m):
-                print_('    this->%s = PyInt_AS_LONG(cvt_value) ? TRUE : FALSE;' % name, file=fd)
+                print('    this->%s = PyInt_AS_LONG(cvt_value) ? TRUE : FALSE;' % name, file=fd)
             elif is_cstring(m):
-                print_('    lasso_assign_string(this->%s, value);' % name, file=fd)
+                print('    lasso_assign_string(this->%s, value);' % name, file=fd)
             elif is_xml_node(m):
-                print_('    if (this->%s) xmlFreeNode(this->%s);' % (name, name), file=fd)
-                print_('    this->%s = get_xml_node_from_pystring(cvt_value);' % name, file=fd)
+                print('    if (this->%s) xmlFreeNode(this->%s);' % (name, name), file=fd)
+                print('    this->%s = get_xml_node_from_pystring(cvt_value);' % name, file=fd)
             elif is_glist(m):
                 el_type = element_type(m)
                 if is_cstring(el_type):
-                    print_('    RETURN_IF_FAIL(set_list_of_strings(&this->%s, cvt_value));' % name, file=fd)
+                    print('    RETURN_IF_FAIL(set_list_of_strings(&this->%s, cvt_value));' % name, file=fd)
                 elif is_xml_node(el_type):
-                    print_('    RETURN_IF_FAIL(set_list_of_xml_nodes(&this->%s, cvt_value));' % name, file=fd)
+                    print('    RETURN_IF_FAIL(set_list_of_xml_nodes(&this->%s, cvt_value));' % name, file=fd)
                 elif is_object(el_type):
-                    print_('    RETURN_IF_FAIL(set_list_of_pygobject(&this->%s, cvt_value));' % name, file=fd)
+                    print('    RETURN_IF_FAIL(set_list_of_pygobject(&this->%s, cvt_value));' % name, file=fd)
                 else:
                     raise Exception('Unsupported setter for %s' % (m,))
             elif is_hashtable(m):
                 el_type = element_type(m)
                 if is_object(el_type):
-                    print_('    RETURN_IF_FAIL(set_hashtable_of_pygobject(this->%s, cvt_value));' % name, file=fd)
+                    print('    RETURN_IF_FAIL(set_hashtable_of_pygobject(this->%s, cvt_value));' % name, file=fd)
                 else:
-                    print_('    RETURN_IF_FAIL(set_hashtable_of_strings(this->%s, cvt_value));' % name, file=fd)
+                    print('    RETURN_IF_FAIL(set_hashtable_of_strings(this->%s, cvt_value));' % name, file=fd)
             elif is_object(m):
-                print_('    set_object_field((GObject**)&this->%s, cvt_value);' % name, file=fd)
+                print('    set_object_field((GObject**)&this->%s, cvt_value);' % name, file=fd)
             else:
                 raise Exception('Unsupported member %s.%s' % (klassname, m))
-            print_('    return noneRef();', file=fd)
-            print_('}', file=fd)
-            print_('', file=fd)
+            print('    return noneRef();', file=fd)
+            print('}', file=fd)
+            print('', file=fd)
 
 
     def return_value(self, fd, arg, return_var_name = 'return_value', return_pyvar_name = 'return_pyvalue'):
         if is_boolean(arg):
-            print_('    if (%s) {' % return_var_name, file=fd)
-            print_('        Py_INCREF(Py_True);', file=fd)
-            print_('        %s = Py_True;' % return_pyvar_name, file=fd)
-            print_('    } else {', file=fd)
-            print_('        Py_INCREF(Py_False);', file=fd)
-            print_('        %s = Py_False;' % return_pyvar_name, file=fd)
-            print_('    }', file=fd)
+            print('    if (%s) {' % return_var_name, file=fd)
+            print('        Py_INCREF(Py_True);', file=fd)
+            print('        %s = Py_True;' % return_pyvar_name, file=fd)
+            print('    } else {', file=fd)
+            print('        Py_INCREF(Py_False);', file=fd)
+            print('        %s = Py_False;' % return_pyvar_name, file=fd)
+            print('    }', file=fd)
         elif is_int(arg, self.binding_data):
-            print_('    %s = PyInt_FromLong(%s);' % (return_pyvar_name, return_var_name), file=fd)
+            print('    %s = PyInt_FromLong(%s);' % (return_pyvar_name, return_var_name), file=fd)
         elif is_cstring(arg) and is_transfer_full(arg):
-            print_('    if (%s) {' % return_var_name, file=fd)
-            print_('        %s = PyString_FromString(%s);' % (return_pyvar_name, return_var_name), file=fd)
-            print_('    } else {', file=fd)
-            print_('        %s = noneRef();' % return_pyvar_name, file=fd)
-            print_('    }', file=fd)
+            print('    if (%s) {' % return_var_name, file=fd)
+            print('        %s = PyString_FromString(%s);' % (return_pyvar_name, return_var_name), file=fd)
+            print('    } else {', file=fd)
+            print('        %s = noneRef();' % return_pyvar_name, file=fd)
+            print('    }', file=fd)
         elif is_cstring(arg):
-            print_('    if (%s) {' % return_var_name, file=fd)
-            print_('        %s = PyString_FromString(%s);' % (return_pyvar_name, return_var_name), file=fd)
-            print_('    } else {', file=fd)
-            print_('        %s = noneRef();' % return_pyvar_name, file=fd)
-            print_('    }', file=fd)
+            print('    if (%s) {' % return_var_name, file=fd)
+            print('        %s = PyString_FromString(%s);' % (return_pyvar_name, return_var_name), file=fd)
+            print('    } else {', file=fd)
+            print('        %s = noneRef();' % return_pyvar_name, file=fd)
+            print('    }', file=fd)
         elif is_glist(arg):
             el_type = element_type(arg)
             if is_object(el_type):
-                print_('    %s = get_list_of_pygobject(%s);' % (return_pyvar_name, return_var_name), file=fd)
+                print('    %s = get_list_of_pygobject(%s);' % (return_pyvar_name, return_var_name), file=fd)
             elif is_cstring(el_type):
-                print_('    %s = get_list_of_strings(%s);' % (return_pyvar_name, return_var_name), file=fd)
+                print('    %s = get_list_of_strings(%s);' % (return_pyvar_name, return_var_name), file=fd)
             elif is_xml_node(el_type):
-                print_('    %s = get_list_of_xml_nodes(%s);' % (return_pyvar_name, return_var_name), file=fd)
+                print('    %s = get_list_of_xml_nodes(%s);' % (return_pyvar_name, return_var_name), file=fd)
             else:
                 raise Exception('failed to make an assignment for %s' % (arg,))
         elif is_hashtable(arg):
             el_type = element_type(arg)
             if is_object(el_type):
-                print_('    %s = get_dict_from_hashtable_of_objects(%s);' % (return_pyvar_name, return_var_name), file=fd)
+                print('    %s = get_dict_from_hashtable_of_objects(%s);' % (return_pyvar_name, return_var_name), file=fd)
             else:
-                print_('    %s = get_dict_from_hashtable_of_strings(%s);' % (return_pyvar_name, return_var_name), file=fd)
+                print('    %s = get_dict_from_hashtable_of_strings(%s);' % (return_pyvar_name, return_var_name), file=fd)
         elif is_xml_node(arg):
             # convert xmlNode* to strings
-            print_('    if (%s) {' % return_var_name, file=fd)
-            print_('        %s = get_pystring_from_xml_node(%s);' % (return_pyvar_name, return_var_name), file=fd)
-            print_('    } else {', file=fd)
-            print_('        %s = noneRef();' % return_pyvar_name, file=fd)
-            print_('    }', file=fd)
+            print('    if (%s) {' % return_var_name, file=fd)
+            print('        %s = get_pystring_from_xml_node(%s);' % (return_pyvar_name, return_var_name), file=fd)
+            print('    } else {', file=fd)
+            print('        %s = noneRef();' % return_pyvar_name, file=fd)
+            print('    }', file=fd)
         elif is_object(arg):
             # return a PyGObjectPtr (wrapper around GObject)
-            print_('''\
+            print('''\
     if (%s) {
         %s = PyGObjectPtr_New(G_OBJECT(%s));
     } else {
@@ -899,7 +898,7 @@ register_constants(PyObject *d)
         else:
             name = m.name[6:]
         self.wrapper_list.append(name)
-        print_('''static PyObject*
+        print('''static PyObject*
 %s(G_GNUC_UNUSED PyObject *self, PyObject *args)
 {
     int ok = 1;''' % name, file=fd)
@@ -951,21 +950,21 @@ register_constants(PyObject *d)
                 parse_tuple_args.pop()
                 parse_tuple_args.append('&cvt_%s_out' % aname)
                 python_cvt_def = '    PyObject *cvt_%s_out = NULL;' % aname
-                print_('    PyObject *out_pyvalue = NULL;', file=fd)
-            print_(arg_def, file=fd)
+                print('    PyObject *out_pyvalue = NULL;', file=fd)
+            print(arg_def, file=fd)
             if python_cvt_def:
-                print_(python_cvt_def, file=fd)
+                print(python_cvt_def, file=fd)
 
         if m.return_type:
-            print_('    %s return_value;' % m.return_type, file=fd)
-            print_('    PyObject* return_pyvalue = NULL;', file=fd)
-        print_('', file=fd)
+            print('    %s return_value;' % m.return_type, file=fd)
+            print('    PyObject* return_pyvalue = NULL;', file=fd)
+        print('', file=fd)
 
         parse_tuple_args = ', '.join(parse_tuple_args)
         if parse_tuple_args:
             parse_tuple_args = ', ' + parse_tuple_args
 
-        print_('    if (! PyArg_ParseTuple(args, "%s"%s)) return NULL;' % (
+        print('    if (! PyArg_ParseTuple(args, "%s"%s)) return NULL;' % (
                 ''.join(parse_tuple_format), parse_tuple_args), file=fd)
 
         for f, arg in zip([ x for x in parse_tuple_format if x != '|'], m.args):
@@ -974,48 +973,48 @@ register_constants(PyObject *d)
             if is_list(arg):
                 qualifier = element_type(arg)
                 if is_cstring(qualifier):
-                    print_('    EXIT_IF_FAIL(set_list_of_strings(&%s, cvt_%s));' % (arg[1], arg[1]), file=fd)
+                    print('    EXIT_IF_FAIL(set_list_of_strings(&%s, cvt_%s));' % (arg[1], arg[1]), file=fd)
                 elif is_xml_node(qualifier):
-                    print_('    EXIT_IF_FAIL(set_list_of_xml_nodes(&%s, cvt_%s));' % (arg[1], arg[1]), file=fd)
+                    print('    EXIT_IF_FAIL(set_list_of_xml_nodes(&%s, cvt_%s));' % (arg[1], arg[1]), file=fd)
                 elif isinstance(qualifier, str) and qualifier.startswith('Lasso'):
-                    print_('    EXIT_IF_FAIL(set_list_of_pygobject(&%s, cvt_%s));' % (arg[1], arg[1]), file=fd)
+                    print('    EXIT_IF_FAIL(set_list_of_pygobject(&%s, cvt_%s));' % (arg[1], arg[1]), file=fd)
                 else:
-                    print_('E: unqualified GList argument in', name, qualifier, arg, file=sys.stderr)
+                    print('E: unqualified GList argument in', name, qualifier, arg, file=sys.stderr)
             elif is_xml_node(arg):
-                print_('    %s = get_xml_node_from_pystring(cvt_%s);' % (arg[1], arg[1]), file=fd)
+                print('    %s = get_xml_node_from_pystring(cvt_%s);' % (arg[1], arg[1]), file=fd)
             elif is_time_t_pointer(arg):
-                print_('    %s = get_time_t(cvt_%s);' % (arg[1], arg[1]), file=fd)
+                print('    %s = get_time_t(cvt_%s);' % (arg[1], arg[1]), file=fd)
             elif is_hashtable(arg):
                 el_type = element_type(arg)
                 k_type = key_type(arg)
                 v_type = value_type(arg)
                 if is_cstring(el_type) or (is_cstring(k_type) and is_cstring(v_type)):
 
-                    print_('    %s = g_hash_table_new_full(g_str_hash, g_str_equal, g_free, g_free);' % arg[1], file=fd)
-                    print_('    EXIT_IF_FAIL(set_hashtable_of_strings(%s, cvt_%s));' % (arg[1], arg[1]), file=fd)
+                    print('    %s = g_hash_table_new_full(g_str_hash, g_str_equal, g_free, g_free);' % arg[1], file=fd)
+                    print('    EXIT_IF_FAIL(set_hashtable_of_strings(%s, cvt_%s));' % (arg[1], arg[1]), file=fd)
             elif f == 'O':
                 if is_optional(arg):
-                    print_('    if (PyObject_TypeCheck((PyObject*)cvt_%s, &PyGObjectPtrType)) {' % arg[1], file=fd)
-                    print_('        %s = (%s)cvt_%s->obj;' % (arg[1], arg[0], arg[1]), file=fd)
-                    print_('    } else {', file=fd)
-                    print_('        %s = NULL;' % arg[1], file=fd)
-                    print_('    }', file=fd)
+                    print('    if (PyObject_TypeCheck((PyObject*)cvt_%s, &PyGObjectPtrType)) {' % arg[1], file=fd)
+                    print('        %s = (%s)cvt_%s->obj;' % (arg[1], arg[0], arg[1]), file=fd)
+                    print('    } else {', file=fd)
+                    print('        %s = NULL;' % arg[1], file=fd)
+                    print('    }', file=fd)
                 else:
-                    print_('    if (PyObject_TypeCheck((PyObject*)cvt_%s, &PyGObjectPtrType)) {' % arg[1], file=fd)
-                    print_('        %s = (%s)cvt_%s->obj;' % (arg[1], arg[0], arg[1]), file=fd)
-                    print_('    } else {', file=fd)
-                    print_('        PyErr_SetString(PyExc_TypeError, "value should be a PyGObject");', file=fd)
-                    print_('        return NULL;', file=fd)
-                    print_('    }', file=fd)
+                    print('    if (PyObject_TypeCheck((PyObject*)cvt_%s, &PyGObjectPtrType)) {' % arg[1], file=fd)
+                    print('        %s = (%s)cvt_%s->obj;' % (arg[1], arg[0], arg[1]), file=fd)
+                    print('    } else {', file=fd)
+                    print('        PyErr_SetString(PyExc_TypeError, "value should be a PyGObject");', file=fd)
+                    print('        return NULL;', file=fd)
+                    print('    }', file=fd)
 
 
         if m.return_type:
-            print_('    return_value = ', file=fd, end='')
+            print('    return_value = ', file=fd, end='')
             if 'new' in m.name:
-                print_('(%s)' % m.return_type, file=fd)
+                print('(%s)' % m.return_type, file=fd)
         else:
-            print_('    ', file=fd, end='')
-        print_('%s(%s);' % (m.name, ', '.join([ref_name(x) for x in m.args])), file=fd)
+            print('    ', file=fd, end='')
+        print('%s(%s);' % (m.name, ', '.join([ref_name(x) for x in m.args])), file=fd)
 
         if m.return_type:
             # Constructor so decrease refcount (it was incremented by PyGObjectPtr_New called
@@ -1023,7 +1022,7 @@ register_constants(PyObject *d)
             try:
                 self.return_value(fd, m.return_arg)
             except:
-                print_('W: cannot assign return value of', m, file=sys.stderr)
+                print('W: cannot assign return value of', m, file=sys.stderr)
                 raise
 
             if is_transfer_full(m.return_arg, default=True):
@@ -1033,48 +1032,48 @@ register_constants(PyObject *d)
             if is_out(arg):
                 self.return_value(fd, arg, return_var_name = arg[1], return_pyvar_name = 'out_pyvalue')
 
-                print_('    EXIT_IF_FAIL(%s);' % arg[1], file=fd)
-                print_('    if (PyList_SetItem(cvt_%s_out, 0, out_pyvalue) == -1) {' % arg[1], file=fd)
-                print_('        ok = 0;', file=fd)
-                print_('        Py_XDECREF(out_pyvalue);', file=fd)
-                print_('    }', file=fd)
+                print('    EXIT_IF_FAIL(%s);' % arg[1], file=fd)
+                print('    if (PyList_SetItem(cvt_%s_out, 0, out_pyvalue) == -1) {' % arg[1], file=fd)
+                print('        ok = 0;', file=fd)
+                print('        Py_XDECREF(out_pyvalue);', file=fd)
+                print('    }', file=fd)
             elif arg[0] == 'GList*':
                 qualifier = arg[2].get('element-type')
                 if is_cstring(qualifier):
-                    print_('    free_list(&%s, (GFunc)g_free);' % arg[1], file=fd)
+                    print('    free_list(&%s, (GFunc)g_free);' % arg[1], file=fd)
                 elif is_xml_node(qualifier):
-                    print_('    free_list(&%s, (GFunc)xmlFreeNode);' % arg[1], file=fd)
+                    print('    free_list(&%s, (GFunc)xmlFreeNode);' % arg[1], file=fd)
                 elif is_object(qualifier):
-                    print_('    free_list(&%s, (GFunc)g_object_unref);' % arg[1], file=fd)
+                    print('    free_list(&%s, (GFunc)g_object_unref);' % arg[1], file=fd)
             elif is_time_t_pointer(arg):
-                print_('    if (%s) free(%s);' % (arg[1], arg[1]), file=fd)
+                print('    if (%s) free(%s);' % (arg[1], arg[1]), file=fd)
             elif not is_transfer_full(arg) and is_hashtable(arg):
                 self.free_value(fd, arg)
             elif not is_transfer_full(arg) and is_xml_node(arg):
                 self.free_value(fd, arg)
 
-        print_('failure:', file=fd)
+        print('failure:', file=fd)
 
         if not m.return_type:
-            print_('    if (ok) {', file=fd)
-            print_('        return noneRef();', file=fd)
+            print('    if (ok) {', file=fd)
+            print('        return noneRef();', file=fd)
         else:
-            print_('    if (ok && return_pyvalue) {', file=fd)
-            print_('        return return_pyvalue;', file=fd)
-        print_('    } else {', file=fd)
+            print('    if (ok && return_pyvalue) {', file=fd)
+            print('        return return_pyvalue;', file=fd)
+        print('    } else {', file=fd)
         if m.return_type:
-            print_('        Py_XDECREF(return_pyvalue);', file=fd)
-        print_('        return NULL;', file=fd)
-        print_('    }', file=fd)
-        print_('}', file=fd)
-        print_('', file=fd)
+            print('        Py_XDECREF(return_pyvalue);', file=fd)
+        print('        return NULL;', file=fd)
+        print('    }', file=fd)
+        print('}', file=fd)
+        print('', file=fd)
 
     def generate_wrapper_list(self, fd):
-        print_('''
+        print('''
 static PyMethodDef lasso_methods[] = {''', file=fd)
         for m in self.wrapper_list:
-            print_('    {"%s", %s, METH_VARARGS, NULL},' % (m, m), file=fd)
-        print_('    {NULL, NULL, 0, NULL}', file=fd)
-        print_('};', file=fd)
-        print_('', file=fd)
+            print('    {"%s", %s, METH_VARARGS, NULL},' % (m, m), file=fd)
+        print('    {NULL, NULL, 0, NULL}', file=fd)
+        print('};', file=fd)
+        print('', file=fd)
 
diff --git a/bindings/python/tests/XmlTestRunner.py b/bindings/python/tests/XmlTestRunner.py
index 7a4150b4..d27d7da0 100644
--- a/bindings/python/tests/XmlTestRunner.py
+++ b/bindings/python/tests/XmlTestRunner.py
@@ -1,4 +1,3 @@
-# -*- coding: utf-8 -*-
 #
 # $Id: XmlTestRunner.py 3254 2007-06-05 21:23:57Z fpeters $
 #
@@ -25,7 +24,6 @@
 import unittest
 import time
 import sys
-from six import print_
 
 def xml(text):
     if not text:
@@ -34,14 +32,14 @@ def xml(text):
 
 class XmlTestResult(unittest.TestResult):
     def addSuccess(self, test):
-        print_("""    <test result="success">
+        print("""    <test result="success">
       <id>%s</id>
       <description>%s</description>
     </test>""" % (test.id(), xml(test.shortDescription())))
 
     def addError(self, test, err):
         unittest.TestResult.addError(self, test, err)
-        print_("""    <test result="error">
+        print("""    <test result="error">
       <id>%s</id>
       <description>%s</description>
     </test>""" % (test.id(), xml(test.shortDescription())))
@@ -49,7 +47,7 @@ class XmlTestResult(unittest.TestResult):
 
     def addFailure(self, test, err):
         unittest.TestResult.addFailure(self, test, err)
-        print_("""    <test result="failure">
+        print("""    <test result="failure">
       <id>%s</id>
       <description>%s</description>
     </test>""" % (test.id(), xml(test.shortDescription())))
@@ -61,14 +59,14 @@ class XmlTestRunner:
         return XmlTestResult()
 
     def run(self, test):
-        print_("<suite>")
+        print("<suite>")
         result = self._makeResult()
         startTime = time.time()
         test(result)
         stopTime = time.time()
         timeTaken = float(stopTime - startTime)
-        print_("  <duration>%s</duration>" % timeTaken)
-        print_("</suite>")
+        print("  <duration>%s</duration>" % timeTaken)
+        print("</suite>")
 
         return result
 
diff --git a/bindings/python/tests/binding_tests.py b/bindings/python/tests/binding_tests.py
index 4fe7fde6..e074b893 100755
--- a/bindings/python/tests/binding_tests.py
+++ b/bindings/python/tests/binding_tests.py
@@ -254,10 +254,13 @@ class BindingTestCase(unittest.TestCase):
     def test07(self):
         '''Check reference counting'''
         s = lasso.Samlp2AuthnRequest()
-        cptr = s._cptr
+        # Starting with Python 3.14 some reference count changes
+        # are avoided.
+        # Creating a reference in a dict still increments refcount
+        data = {'cptr': s._cptr}
         a = sys.getrefcount(s._cptr)
         del(s)
-        b = sys.getrefcount(cptr)
+        b = sys.getrefcount(data['cptr'])
         self.assertEqual(b, a-1)
 
     def test08(self):
@@ -339,6 +342,12 @@ class BindingTestCase(unittest.TestCase):
         self.assertEqual(str(cm.exception),
                          '<lasso.XmlSchemaInvalidFragmentError(17): An XML tree does not respect at least an XML schema of its namespaces.>')
 
+    def test_provider_get_key_encryption_method(self):
+        # check getKeyEncryptionMethod is a Provider method #101250
+        with self.assertRaises(AttributeError):
+            getattr(lasso, 'providerGetKeyEncryptionMethod')
+        getattr(lasso.Provider, 'getKeyEncryptionMethod')
+
     def test_set_list_of_strings(self):
         node = lasso.Samlp2RequestedAuthnContext()
         with self.assertRaises(TypeError, msg='value should be a tuple of strings'):
@@ -353,7 +362,91 @@ class BindingTestCase(unittest.TestCase):
         with self.assertRaises(TypeError, msg='value should be a tuple of PyGobject'):
             node.attributeValue = value
 
-bindingSuite = unittest.makeSuite(BindingTestCase, 'test')
+    def test_saml1_soap_attributes(self):
+        # Test AttributeStatement AttributeValue text extraction
+        # Example SAML 1.1 validation response taken from
+        # https://github.com/apereo/cas/blob/master/docs/cas-server-documentation/protocol/CAS-Protocol-Specification.md
+        soap_content = """ 
+<SOAP-ENV:Envelope xmlns:SOAP-ENV=\"http://schemas.xmlsoap.org/soap/envelope/\">
+  <SOAP-ENV:Header />
+  <SOAP-ENV:Body>
+    <Response xmlns=\"urn:oasis:names:tc:SAML:1.0:protocol\" xmlns:saml=\"urn:oasis:names:tc:SAML:1.0:assertion\"
+    xmlns:samlp=\"urn:oasis:names:tc:SAML:1.0:protocol\" xmlns:xsd=\"http://www.w3.org/2001/XMLSchema\"
+    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" IssueInstant=\"2008-12-10T14:12:14.817Z\"
+    MajorVersion=\"1\" MinorVersion=\"1\" Recipient=\"https://eiger.iad.vt.edu/dat/home.do\"
+    ResponseID=\"_5c94b5431c540365e5a70b2874b75996\">
+      <Status>
+        <StatusCode Value=\"samlp:Success\">
+        </StatusCode>
+      </Status>
+      <Assertion xmlns=\"urn:oasis:names:tc:SAML:1.0:assertion\" AssertionID=\"_e5c23ff7a3889e12fa01802a47331653\"
+      IssueInstant=\"2008-12-10T14:12:14.817Z\" Issuer=\"localhost\" MajorVersion=\"1\"
+      MinorVersion=\"1\">
+        <Conditions NotBefore=\"2008-12-10T14:12:14.817Z\" NotOnOrAfter=\"2008-12-10T14:12:44.817Z\">
+          <AudienceRestrictionCondition>
+            <Audience>
+              https://some-service.example.com/app/
+            </Audience>
+          </AudienceRestrictionCondition>
+        </Conditions>
+        <AttributeStatement>
+          <Subject>
+            <NameIdentifier>johnq</NameIdentifier>
+            <SubjectConfirmation>
+              <ConfirmationMethod>
+                urn:oasis:names:tc:SAML:1.0:cm:artifact
+              </ConfirmationMethod>
+            </SubjectConfirmation>
+          </Subject>
+          <Attribute AttributeName=\"uid\" AttributeNamespace=\"http://www.ja-sig.org/products/cas/\">
+            <AttributeValue>12345</AttributeValue>
+          </Attribute>
+          <Attribute AttributeName=\"groupMembership\" AttributeNamespace=\"http://www.ja-sig.org/products/cas/\">
+            <AttributeValue>
+              uugid=middleware.staff,ou=Groups,dc=vt,dc=edu
+            </AttributeValue>
+          </Attribute>
+          <Attribute AttributeName=\"eduPersonAffiliation\" AttributeNamespace=\"http://www.ja-sig.org/products/cas/\">
+            <AttributeValue>staff</AttributeValue>
+          </Attribute>
+          <Attribute AttributeName=\"accountState\" AttributeNamespace=\"http://www.ja-sig.org/products/cas/\">
+            <AttributeValue>ACTIVE</AttributeValue>
+          </Attribute>
+        </AttributeStatement>
+        <AuthenticationStatement AuthenticationInstant=\"2008-12-10T14:12:14.741Z\"
+        AuthenticationMethod=\"urn:oasis:names:tc:SAML:1.0:am:password\">
+          <Subject>
+            <NameIdentifier>johnq</NameIdentifier>
+            <SubjectConfirmation>
+              <ConfirmationMethod>
+                urn:oasis:names:tc:SAML:1.0:cm:artifact
+              </ConfirmationMethod>
+            </SubjectConfirmation>
+          </Subject>
+        </AuthenticationStatement>
+      </Assertion>
+    </Response>
+  </SOAP-ENV:Body>
+</SOAP-ENV:Envelope>
+"""
+        expt_attrs = {'uid': '12345',
+                      'groupMembership': 'uugid=middleware.staff,ou=Groups,dc=vt,dc=edu',
+                      'eduPersonAffiliation': 'staff',
+                      'accountState': 'ACTIVE'}
+        node = lasso.Node.newFromSoap(soap_content)
+        assert len(node.assertion) == 1
+        assertion = node.assertion[0]
+        for attribute in assertion.attributeStatement.attribute:
+            attr_name = attribute.attributeName
+            with self.subTest(name=attr_name):
+                self.assertEqual(len(attribute.attributeValue), 1)
+                value = attribute.attributeValue[0]
+                self.assertEqual(len(value.any), 1)
+                content = value.any[0].content
+                self.assertIn(attr_name, expt_attrs)
+                self.assertEqual(expt_attrs[attr_name], content.strip())
+
+bindingSuite = unittest.defaultTestLoader.loadTestsFromTestCase(BindingTestCase)
 
 allTests = unittest.TestSuite((bindingSuite, ))
 
diff --git a/bindings/python/tests/profiles_tests.py b/bindings/python/tests/profiles_tests.py
index 03f33ea9..8679d663 100755
--- a/bindings/python/tests/profiles_tests.py
+++ b/bindings/python/tests/profiles_tests.py
@@ -330,6 +330,12 @@ class LoginTestCase(unittest.TestCase):
             sp_login.setSignatureVerifyHint(lasso.PROFILE_SIGNATURE_VERIFY_HINT_FORCE)
             sp_login.processAuthnResponseMsg(idp_login.msgBody)
             sp_login.acceptSso()
+
+            if key_encryption_method:
+                expected_key_encryption_method = key_encryption_method
+            else:
+                expected_key_encryption_method = lasso.getDefaultKeyEncryptionMethod()
+            assert provider.getKeyEncryptionMethod() == expected_key_encryption_method
             return sp_login.response.debug()
 
         os.environ['LASSO_DEFAULT_KEY_ENCRYPTION_METHOD'] = 'rsa-pkcs1'
@@ -543,12 +549,12 @@ class AttributeAuthorityTestCase(unittest.TestCase):
         assert aq.response.assertion[0].attributeStatement[0].attribute[0]
         assert aq.response.assertion[0].attributeStatement[0].attribute[0].attributeValue[0]
 
-serverSuite = unittest.makeSuite(ServerTestCase, 'test')
-loginSuite = unittest.makeSuite(LoginTestCase, 'test')
-logoutSuite = unittest.makeSuite(LogoutTestCase, 'test')
-defederationSuite = unittest.makeSuite(DefederationTestCase, 'test')
-identitySuite = unittest.makeSuite(IdentityTestCase, 'test')
-attributeSuite = unittest.makeSuite(AttributeAuthorityTestCase, 'test')
+serverSuite = unittest.defaultTestLoader.loadTestsFromTestCase(ServerTestCase)
+loginSuite = unittest.defaultTestLoader.loadTestsFromTestCase(LoginTestCase)
+logoutSuite = unittest.defaultTestLoader.loadTestsFromTestCase(LogoutTestCase)
+defederationSuite = unittest.defaultTestLoader.loadTestsFromTestCase(DefederationTestCase)
+identitySuite = unittest.defaultTestLoader.loadTestsFromTestCase(IdentityTestCase)
+attributeSuite = unittest.defaultTestLoader.loadTestsFromTestCase(AttributeAuthorityTestCase)
 
 allTests = unittest.TestSuite((serverSuite, loginSuite, logoutSuite, defederationSuite,
                                identitySuite, attributeSuite))
diff --git a/bindings/python/tests/tests.py b/bindings/python/tests/tests.py
index efed53d1..5f2f0c8d 100755
--- a/bindings/python/tests/tests.py
+++ b/bindings/python/tests/tests.py
@@ -1,5 +1,4 @@
 #! /usr/bin/env python
-# -*- coding: utf-8 -*-
 #
 # $Id: tests.py 3425 2007-10-10 09:31:03Z dlaniel $
 #
@@ -31,7 +30,6 @@ import os
 import sys
 import time
 import unittest
-from six import print_
 
 from XmlTestRunner import XmlTestRunner
 
@@ -61,10 +59,10 @@ parser.add_option(
 __builtin__.__dict__['dataDir'] = os.path.join(options.srcDir, '../../../tests/data')
 
 if options.xmlMode:
-    print_('<?xml version="1.0"?>')
-    print_('<testsuites xmlns="http://check.sourceforge.net/ns">')
-    print_('  <title>Python Bindings</title>')
-    print_('  <datetime>%s</datetime>' % time.strftime('%Y-%m-%d %H:%M:%S', time.localtime()))
+    print('<?xml version="1.0"?>')
+    print('<testsuites xmlns="http://check.sourceforge.net/ns">')
+    print('  <title>Python Bindings</title>')
+    print('  <datetime>%s</datetime>' % time.strftime('%Y-%m-%d %H:%M:%S', time.localtime()))
 
 success = True
 for testSuite in testSuites:
@@ -75,7 +73,7 @@ for testSuite in testSuites:
         if fp:
             fp.close()
     if not module:
-        print_('Unable to load test suite:', testSuite, file=sys.stderr)
+        print('Unable to load test suite:', testSuite, file=sys.stderr)
         continue
 
     if module.__doc__:
@@ -88,13 +86,13 @@ for testSuite in testSuites:
     else:
         runner = unittest.TextTestRunner(verbosity=2)
         print
-        print_('-' * len(doc))
-        print_(doc)
-        print_('-' * len(doc))
+        print('-' * len(doc))
+        print(doc)
+        print('-' * len(doc))
     result = runner.run(module.allTests)
     success = success and result.wasSuccessful()
 
 if options.xmlMode:
-    print_('</testsuites>')
+    print('</testsuites>')
 
 sys.exit(not success)
diff --git a/configure.ac b/configure.ac
index 79d06985..cb9be5d5 100644
--- a/configure.ac
+++ b/configure.ac
@@ -90,6 +90,7 @@ fi
 dnl
 dnl Check for programs
 dnl
+CFLAGS="$CFLAGS -Werror=undef -Werror=implicit-function-declaration"
 AC_PROG_CC
 AM_CFLAGS=""
 AC_HEADER_STDC
@@ -133,7 +134,7 @@ AC_CHECK_PROGS(PHP5, php5 php)
 AC_CHECK_PROGS(PHP5_CONFIG, php-config5 php-config)
 AC_CHECK_PROGS(PHP7, php7.4 php7.3 php7.2 php7.1 php7.0 php7 php)
 AC_CHECK_PROGS(PHP7_CONFIG, php-config7.4 php-config7.3 php-config7.2 php-config7.1 php-config7.0 php-config7 php-config)
-AC_CHECK_PROGS(PYTHON, python3 python python2)
+AC_CHECK_PROGS(PYTHON, python3 python)
 AC_CHECK_PROGS(SWIG, swig)
 
 dnl Make sure we have an ANSI compiler
@@ -325,25 +326,49 @@ if test "X$with_python" != "X"; then
     PYTHON=$with_python
 fi
 
+test "x$PYTHON" != "x" || AC_MSG_ERROR(Python must be installed to compile lasso)
 
 dnl need to change quotes to allow square brackets
 changequote(<<, >>)dnl
-PYTHON_VERSION=`$PYTHON -c 'from distutils import sysconfig ; print(sysconfig.get_config_var("VERSION"))'`
+PYTHON_VERSION=`$PYTHON -c '
+try:
+  import sysconfig
+except ImportError:
+  from distutils import sysconfig
+print(sysconfig.get_config_var("VERSION"))'`
 changequote([, ])dnl
 
-test "x$PYTHON" != "x" || AC_MSG_ERROR(Python must be installed to compile lasso)
-
 AC_MSG_CHECKING(for Python development files)
 dnl Check if we were be able to extract a good version number.
 if test "X$PYTHON_VERSION" != "X"; then
     changequote(<<, >>)dnl
-    PYTHON_INC=`$PYTHON -c 'from distutils import sysconfig ; print(sysconfig.get_python_inc())'`
-    PYTHON_LIB=`$PYTHON -c 'from distutils import sysconfig ; print(sysconfig.get_python_lib(1))'`
+    PYTHON_INC=`$PYTHON -c '
+try:
+  import sysconfig
+  print(sysconfig.get_path("include"))
+except ImportError:
+  from distutils import sysconfig
+  print(sysconfig.get_python_inc())
+'`
+    PYTHON_LIB=`$PYTHON -c '
+try:
+  import sysconfig
+  print(sysconfig.get_path("platlib"))
+except ImportError:
+  from distutils import sysconfig
+  print(sysconfig.get_python_lib(True))
+'`
     changequote([, ])dnl
     PYTHON_H=$PYTHON_INC/Python.h
     if test -f $PYTHON_H; then
             PY_CFLAGS="-I$PYTHON_INC"
-            PY_MAKEFILE=`$PYTHON -c 'from distutils import sysconfig ; print(sysconfig.get_makefile_filename())'`
+	    PY_MAKEFILE=`$PYTHON -c '
+try:
+  import sysconfig
+except ImportError:
+  from distutils import sysconfig
+print(sysconfig.get_makefile_filename())
+'`
             PY_OTHER_LIBS=`$SED -n -e 's/^LIBS=\(.*\)/\1/p' $PY_MAKEFILE`
             PY_EXTRA_LIBS="$PY_LOCALMODLIBS $PY_BASEMODLIBS $PY_OTHER_LIBS"
             dnl this extracts the $libdir out of python lib directory,
diff --git a/lasso/build_strerror.py b/lasso/build_strerror.py
index 908638d5..041c23a2 100644
--- a/lasso/build_strerror.py
+++ b/lasso/build_strerror.py
@@ -4,14 +4,14 @@ import glob
 import re
 import sys
 import os
-from six import print_, StringIO
+from io import StringIO
 
 srcdir = sys.argv[1]
 
 messages = dict()
 description = ''
 
-with open('%s/errors.h' % srcdir,'r') as f:
+with open('%s/errors.h' % srcdir) as f:
     for line in f:
         m = re.match(r'^ \* LASSO.*ERROR', line)
         if m:
@@ -30,13 +30,13 @@ with open('%s/errors.h' % srcdir,'r') as f:
             if m:
                 messages[m.group(1)] = m.group(1)
 
-with open('%s/errors.c.in' % srcdir,'r') as f:
+with open('%s/errors.c.in' % srcdir) as f:
     for line in f:
         if '@ERROR_CASES@' in line:
             keys = sorted(messages.keys())
             for k in keys:
-                print_('		case %s:\n'
+                print('		case %s:\n'
                        '			return "%s";' %
                        (k,messages[k].rstrip('\n')))
         else:
-            print_(line, end="")
+            print(line, end="")
diff --git a/lasso/extract_sections.py b/lasso/extract_sections.py
index a03d8551..0130480d 100644
--- a/lasso/extract_sections.py
+++ b/lasso/extract_sections.py
@@ -5,7 +5,6 @@ import re
 import sys
 import os
 import os.path
-from six import print_
 
 if len(sys.argv) == 2:
     srcdir = sys.argv[1]
@@ -19,21 +18,21 @@ for root, dirs, files in os.walk(srcdir):
             prefixes.append(os.path.splitext(file)[0])
     for prefix in prefixes:
         try:
-            header = io.open(os.path.join(root, prefix + '.h'), encoding='utf-8').read()
-            implementation = io.open(os.path.join(root, prefix + '.c'), encoding='utf-8').read()
-            exported_functions = re.findall('LASSO_EXPORT.*(lasso_\w*)', header)
+            header = open(os.path.join(root, prefix + '.h'), encoding='utf-8').read()
+            implementation = open(os.path.join(root, prefix + '.c'), encoding='utf-8').read()
+            exported_functions = re.findall(r'LASSO_EXPORT.*(lasso_\w*)', header)
             normal_functions = sorted ([ x for x in exported_functions if not x.endswith('get_type') ])
             get_type = [ x for x in exported_functions if x.endswith('get_type') ][0]
             file_name = re.findall('lasso_(.*)_get_type', get_type)[0]
             try:
-                macro_type = re.findall('LASSO_(\w*)_CLASS\(', header)[0]
+                macro_type = re.findall(r'LASSO_(\w*)_CLASS\(', header)[0]
             except:
                 macro_type = None
             try:
                 type = re.findall(r'^struct _(Lasso\w*)', header, re.MULTILINE)[0]
             except:
                 type = None
-            types = re.findall('^} (Lasso\w*);', header)
+            types = re.findall(r'^} (Lasso\w*);', header)
             def convert(x):
                 if '%s' in x:
                     return x % macro_type
@@ -41,17 +40,17 @@ for root, dirs, files in os.walk(srcdir):
                     return x
             if type and macro_type:
                 standard_decl = [ convert(x) for x in [ 'LASSO_%s', 'LASSO_IS_%s', 'LASSO_TYPE_%s', get_type, 'LASSO_%s_CLASS', 'LASSO_IS_%s_CLASS', 'LASSO_%s_GET_CLASS' ] ]
-                print_('')
-                print_('<SECTION>')
-                print_('<FILE>%s</FILE>' % file_name)
-                print_('<TITLE>%s</TITLE>' % type)
-                print_(type)
+                print('')
+                print('<SECTION>')
+                print('<FILE>%s</FILE>' % file_name)
+                print('<TITLE>%s</TITLE>' % type)
+                print(type)
                 for x in types + normal_functions:
-                    print_(x)
-                print_('<SUBSECTION Standard>')
+                    print(x)
+                print('<SUBSECTION Standard>')
                 for x in standard_decl:
-                    print_(x)
-                print_('</SECTION>')
+                    print(x)
+                print('</SECTION>')
         except:
             continue
 
diff --git a/lasso/extract_symbols.py b/lasso/extract_symbols.py
index fc34e405..3bbe6160 100644
--- a/lasso/extract_symbols.py
+++ b/lasso/extract_symbols.py
@@ -4,7 +4,6 @@ import io
 import glob
 import re
 import sys
-import six
 
 if len(sys.argv) == 2:
     srcdir = sys.argv[1]
@@ -17,8 +16,8 @@ symbols = []
 for header_file in glob.glob('%s/*/*.h' % srcdir) + glob.glob('%s/*.h' % srcdir) + \
         glob.glob('%s/*/*/*.h' % srcdir):
     assert not ('/id-wsf/' in header_file or '/id-wsf-2.0' in header_file)
-    symbols.extend(regex.findall(io.open(header_file, encoding='utf-8').read().replace('\\\n', '')))
+    symbols.extend(regex.findall(open(header_file, encoding='utf-8').read().replace('\\\n', '')))
 
 for s in symbols:
-    six.print_(s)
+    print(s)
 
diff --git a/lasso/extract_types.py b/lasso/extract_types.py
index f1ac26e2..9c0a12be 100644
--- a/lasso/extract_types.py
+++ b/lasso/extract_types.py
@@ -4,7 +4,6 @@ import io
 import glob
 import re
 import sys
-import six
 
 if len(sys.argv) == 2:
     srcdir = sys.argv[1]
@@ -14,30 +13,30 @@ else:
 
 fd = io.StringIO()
 
-six.print_(u"/* This file has been autogenerated; changes will be lost */", file=fd)
-six.print_(u"", file=fd)
-six.print_(u"typedef GType (*type_function) ();", file=fd)
-six.print_(u"", file=fd)
+print("/* This file has been autogenerated; changes will be lost */", file=fd)
+print("", file=fd)
+print("typedef GType (*type_function) ();", file=fd)
+print("", file=fd)
 
 header_files = []
 for header_file in sorted(glob.glob('%s/*/*.h' % srcdir) + glob.glob('%s/*/*/*.h' % srcdir)):
     assert not ('/id-wsf/' in header_file or '/id-wsf-2.0' in header_file)
     header_files.append(header_file)
     try:
-        type = re.findall('lasso_.*get_type', io.open(header_file, encoding='utf-8').read())[0]
+        type = re.findall('lasso_.*get_type', open(header_file, encoding='utf-8').read())[0]
     except IndexError:
         continue
-    six.print_("extern GType %s();" % type, file=fd)
+    print("extern GType %s();" % type, file=fd)
 
-six.print_(u"", file=fd)
-six.print_(u"type_function functions[] = {", file=fd)
+print("", file=fd)
+print("type_function functions[] = {", file=fd)
 for header_file in header_files:
     try:
-        type = re.findall('lasso_.*get_type', io.open(header_file, encoding='utf-8').read())[0]
+        type = re.findall('lasso_.*get_type', open(header_file, encoding='utf-8').read())[0]
     except IndexError:
         continue
-    six.print_(u"\t%s," % type, file=fd)
-six.print_(u"\tNULL", file=fd)
-six.print_(u"};", file=fd)
+    print("\t%s," % type, file=fd)
+print("\tNULL", file=fd)
+print("};", file=fd)
 
-io.open('types.c', 'w', encoding='utf-8').write(fd.getvalue())
+open('types.c', 'w', encoding='utf-8').write(fd.getvalue())
diff --git a/lasso/id-ff/login.c b/lasso/id-ff/login.c
index bc3b2249..09b0b1bb 100644
--- a/lasso/id-ff/login.c
+++ b/lasso/id-ff/login.c
@@ -270,9 +270,8 @@
 #include "../saml-2.0/loginprivate.h"
 #include "../lasso_config.h"
 
-#define LASSO_LOGIN_GET_PRIVATE(o) \
-	   (G_TYPE_INSTANCE_GET_PRIVATE ((o), LASSO_TYPE_LOGIN, LassoLoginPrivate))
 
+G_DEFINE_TYPE_WITH_PRIVATE(LassoLogin, lasso_login, LASSO_TYPE_PROFILE);
 
 static void lasso_login_build_assertion_artifact(LassoLogin *login);
 
@@ -623,6 +622,7 @@ lasso_login_process_response_status_and_assertion(LassoLogin *login)
 	LassoSamlSubjectStatementAbstract *sssa = NULL;
 	LassoSamlSubjectStatementAbstract *sas = NULL;
 	int rc = 0;
+	LassoLoginPrivate *private_data = lasso_login_get_instance_private(login);
 
 	g_return_val_if_fail(LASSO_IS_LOGIN(login), LASSO_PARAM_ERROR_BAD_TYPE_OR_NULL_OBJ);
 
@@ -672,7 +672,7 @@ lasso_login_process_response_status_and_assertion(LassoLogin *login)
 
 		/* Validate AuthnRequest RequestID and InResponseTo */
 		{
-			char *previous_reqid = login->private_data->request_id;
+			char *previous_reqid = private_data->request_id;
 			if (previous_reqid) {
 				if (lib_assertion == NULL ||
 					lib_assertion->InResponseTo == NULL ||
@@ -852,7 +852,7 @@ lasso_login_build_assertion_artifact(LassoLogin *login)
 	b64_samlArt = xmlSecBase64Encode(samlArt, 42, 0);
 
 	lasso_assign_string(login->assertionArtifact, (char*)b64_samlArt);
-	lasso_assign_string(login->parent.private_data->artifact,
+	lasso_profile_set_artifact(&login->parent,
 			(char*)b64_samlArt);
 	lasso_release_xml_string(b64_samlArt);
 }
@@ -1024,13 +1024,12 @@ lasso_login_build_artifact_msg(LassoLogin *login, LassoHttpMethod http_method)
 				profile->remote_providerID,
 				profile->response));
 	/* comply with the new way of storing artifacts */
-	lasso_assign_string(profile->private_data->artifact,
-			login->assertionArtifact);
+	lasso_profile_set_artifact(profile, login->assertionArtifact);
 	/* Artifact profile for ID-FF 1.2 is special, this is not the full message which is relayed
 	 * but only its assertion content, the Response container is changed from a
 	 * lib:AuthnResponse to a samlp:Response.
 	 */
-	lasso_assign_new_string(profile->private_data->artifact_message,
+	lasso_profile_set_new_artifact_message(profile,
 			lasso_node_export_to_xml((LassoNode*)login->assertion));
 cleanup:
 	lasso_release_string(url);
@@ -1380,6 +1379,7 @@ lasso_login_build_response_msg(LassoLogin *login, gchar *remote_providerID)
 	LassoProvider *remote_provider = NULL;
 	LassoProfile *profile = NULL;
 	lasso_error_t rc = 0;
+	LassoLoginPrivate *private_data = lasso_login_get_instance_private(login);
 
 	g_return_val_if_fail(LASSO_IS_LOGIN(login), LASSO_PARAM_ERROR_BAD_TYPE_OR_NULL_OBJ);
 	profile = LASSO_PROFILE(login);
@@ -1402,9 +1402,9 @@ lasso_login_build_response_msg(LassoLogin *login, gchar *remote_providerID)
 		lasso_assign_string(profile->remote_providerID, remote_providerID);
 		remote_provider = lasso_server_get_provider(profile->server, profile->remote_providerID);
 		rc = lasso_provider_verify_signature(remote_provider,
-				login->private_data->soap_request_msg,
+				private_data->soap_request_msg,
 				"RequestID", LASSO_MESSAGE_FORMAT_SOAP);
-		lasso_release_string(login->private_data->soap_request_msg);
+		lasso_release_string(private_data->soap_request_msg);
 
 		/* lasso_profile_set_session_from_dump has not been called */
 		if (profile->session == NULL) {
@@ -1440,9 +1440,9 @@ lasso_login_build_response_msg(LassoLogin *login, gchar *remote_providerID)
 				lasso_profile_set_response_status(profile,
 						LASSO_SAML_STATUS_CODE_SUCCESS);
 				lasso_session_remove_status(profile->session, remote_providerID);
-			} else if (profile->private_data->artifact_message) {
+			} else if (lasso_profile_get_artifact_message(profile)) {
 				xmlDoc *doc;
-				char *artifact_message = profile->private_data->artifact_message;
+				const char *artifact_message = lasso_profile_get_artifact_message(profile);
 				doc = lasso_xml_parse_memory(artifact_message,
 						strlen(artifact_message));
 				lasso_profile_set_response_status(profile,
@@ -1519,6 +1519,7 @@ lasso_login_init_authn_request(LassoLogin *login, const gchar *remote_providerID
 	LassoServer *server = NULL;
 	LassoSamlpRequestAbstract *request;
 	lasso_error_t rc = 0;
+	LassoLoginPrivate *private_data = lasso_login_get_instance_private(login);
 
 	g_return_val_if_fail(LASSO_IS_LOGIN(login), LASSO_PARAM_ERROR_BAD_TYPE_OR_NULL_OBJ);
 
@@ -1569,7 +1570,7 @@ lasso_login_init_authn_request(LassoLogin *login, const gchar *remote_providerID
 
 	request = LASSO_SAMLP_REQUEST_ABSTRACT(profile->request);
 	request->RequestID = lasso_build_unique_id(32);
-	lasso_assign_string(login->private_data->request_id, request->RequestID);
+	lasso_assign_string(private_data->request_id, request->RequestID);
 	request->MajorVersion = LASSO_LIB_MAJOR_VERSION_N;
 	request->MinorVersion = LASSO_LIB_MINOR_VERSION_N;
 	if (remote_provider &&
@@ -2241,6 +2242,7 @@ lasso_login_process_request_msg(LassoLogin *login, gchar *request_msg)
 {
 	gint ret = 0;
 	LassoProfile *profile = LASSO_PROFILE(login);
+	LassoLoginPrivate *private_data = lasso_login_get_instance_private(login);
 
 	g_return_val_if_fail(LASSO_IS_LOGIN(login), LASSO_PARAM_ERROR_BAD_TYPE_OR_NULL_OBJ);
 	g_return_val_if_fail(request_msg != NULL, LASSO_PARAM_ERROR_INVALID_VALUE);
@@ -2257,13 +2259,12 @@ lasso_login_process_request_msg(LassoLogin *login, gchar *request_msg)
 	/* get AssertionArtifact */
 	lasso_assign_string(login->assertionArtifact,
 			LASSO_SAMLP_REQUEST(profile->request)->AssertionArtifact);
-	lasso_assign_string(login->parent.private_data->artifact,
-			login->assertionArtifact);
+	lasso_profile_set_artifact(&login->parent, login->assertionArtifact);
 
 	/* Keep a copy of request msg so signature can be verified when we get
 	 * the providerId in lasso_login_build_response_msg()
 	 */
-	lasso_assign_string(login->private_data->soap_request_msg, request_msg);
+	lasso_assign_string(private_data->soap_request_msg, request_msg);
 
 	return ret;
 }
@@ -2441,10 +2442,11 @@ static void
 dispose(GObject *object)
 {
 	LassoLogin *login = LASSO_LOGIN(object);
+	LassoLoginPrivate *private_data = lasso_login_get_instance_private(login);
 
-	lasso_release_string(login->private_data->soap_request_msg);
-	lasso_release_gobject(login->private_data->saml2_assertion);
-	lasso_release_string(login->private_data->request_id);
+	lasso_release_string(private_data->soap_request_msg);
+	lasso_release_gobject(private_data->saml2_assertion);
+	lasso_release_string(private_data->request_id);
 	G_OBJECT_CLASS(parent_class)->dispose(object);
 }
 
@@ -2453,9 +2455,12 @@ dispose(GObject *object)
 /*****************************************************************************/
 
 static void
-instance_init(LassoLogin *login, G_GNUC_UNUSED void *unused)
+lasso_login_init(LassoLogin *login)
 {
-	login->private_data = LASSO_LOGIN_GET_PRIVATE(login);
+#pragma GCC diagnostic push
+#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
+	login->private_data = lasso_login_get_instance_private(login);
+#pragma GCC diagnostic pop
 	login->protocolProfile = 0;
 	login->assertionArtifact = NULL;
 	login->nameIDPolicy = NULL;
@@ -2463,7 +2468,7 @@ instance_init(LassoLogin *login, G_GNUC_UNUSED void *unused)
 }
 
 static void
-class_init(LassoLoginClass *klass, void *unused G_GNUC_UNUSED)
+lasso_login_class_init(LassoLoginClass *klass)
 {
 	LassoNodeClass *nclass = LASSO_NODE_CLASS(klass);
 
@@ -2474,36 +2479,10 @@ class_init(LassoLoginClass *klass, void *unused G_GNUC_UNUSED)
 	lasso_node_class_set_nodename(nclass, "Login");
 	lasso_node_class_set_ns(nclass, LASSO_LASSO_HREF, LASSO_LASSO_PREFIX);
 	lasso_node_class_add_snippets(nclass, schema_snippets);
-	g_type_class_add_private(klass, sizeof(LassoLoginPrivate));
 
 	G_OBJECT_CLASS(klass)->dispose = dispose;
 }
 
-GType
-lasso_login_get_type()
-{
-	static GType this_type = 0;
-
-	if (!this_type) {
-		static const GTypeInfo this_info = {
-			sizeof(LassoLoginClass),
-			NULL,
-			NULL,
-			(GClassInitFunc) class_init,
-			NULL,
-			NULL,
-			sizeof(LassoLogin),
-			0,
-			(GInstanceInitFunc) instance_init,
-			NULL
-		};
-
-		this_type = g_type_register_static(LASSO_TYPE_PROFILE,
-				"LassoLogin", &this_info, 0);
-	}
-	return this_type;
-}
-
 /**
  * lasso_login_new
  * @server: the #LassoServer
@@ -2670,9 +2649,44 @@ LassoNode*
 lasso_login_get_assertion(LassoLogin *login)
 {
 	g_return_val_if_fail (LASSO_IS_LOGIN (login), NULL);
+	LassoLoginPrivate *private_data = lasso_login_get_instance_private(login);
 
-	if (login->private_data && login->private_data->saml2_assertion)
-		return (LassoNode*)g_object_ref(login->private_data->saml2_assertion);
+	if (private_data && private_data->saml2_assertion)
+		return (LassoNode*)g_object_ref(private_data->saml2_assertion);
 
 	return (LassoNode*)g_object_ref(login->assertion);
 }
+
+/*****************************************************************************/
+/* not exported private accessors for saml-2.0/login.c */
+/* headers in profileprivate.h*/
+/*****************************************************************************/
+
+LassoSaml2Assertion*
+lasso_login_get_saml2_assertion(LassoLogin *login)
+{
+	LassoLoginPrivate *private_data = lasso_login_get_instance_private(login);
+	return private_data->saml2_assertion;
+}
+
+void
+lasso_login_set_saml2_assertion(LassoLogin *login, LassoSaml2Assertion *assertion)
+{
+	LassoLoginPrivate *private_data = lasso_login_get_instance_private(login);
+	lasso_assign_gobject(private_data->saml2_assertion, assertion);
+}
+
+const char*
+lasso_login_get_request_id(LassoLogin *login)
+{
+	LassoLoginPrivate *private_data = lasso_login_get_instance_private(login);
+	return private_data->request_id;
+}
+
+void
+lasso_login_set_request_id(LassoLogin *login, char *request_id)
+{
+	LassoLoginPrivate *private_data = lasso_login_get_instance_private(login);
+	lasso_assign_string(private_data->request_id, request_id);
+}
+
diff --git a/lasso/id-ff/login.h b/lasso/id-ff/login.h
index 485e4a48..ef2394d5 100644
--- a/lasso/id-ff/login.h
+++ b/lasso/id-ff/login.h
@@ -98,7 +98,8 @@ struct _LassoLogin {
 	gchar *nameIDPolicy;
 	LassoHttpMethod http_method;
 
-	LassoLoginPrivate *private_data;
+	/* keeping it to preserve struct size */
+	LassoLoginPrivate *private_data __attribute__ ((deprecated));
 };
 
 struct _LassoLoginClass {
diff --git a/lasso/id-ff/loginprivate.h b/lasso/id-ff/loginprivate.h
index b88ecb95..0802e9e8 100644
--- a/lasso/id-ff/loginprivate.h
+++ b/lasso/id-ff/loginprivate.h
@@ -39,6 +39,11 @@ struct _LassoLoginPrivate
 	char *request_id;
 };
 
+LassoSaml2Assertion *lasso_login_get_saml2_assertion(LassoLogin *login);
+void lasso_login_set_saml2_assertion(LassoLogin *login, LassoSaml2Assertion *assertion);
+const char *lasso_login_get_request_id(LassoLogin *login);
+void lasso_login_set_request_id(LassoLogin *login, char *request_id);
+
 #ifdef __cplusplus
 }
 #endif /* __cplusplus */
diff --git a/lasso/id-ff/logout.c b/lasso/id-ff/logout.c
index f6307e54..dc6c20fc 100644
--- a/lasso/id-ff/logout.c
+++ b/lasso/id-ff/logout.c
@@ -378,7 +378,7 @@ lasso_logout_build_response_msg(LassoLogout *logout)
 	profile = &logout->parent;
 	lasso_profile_clean_msg_info(profile);
 
-	if (! profile->private_data || ! logout->private_data) {
+	if (! lasso_profile_is_init(profile) || ! logout->private_data) {
 		return LASSO_PARAM_ERROR_NON_INITIALIZED_OBJECT;
 	}
 
diff --git a/lasso/id-ff/profile.c b/lasso/id-ff/profile.c
index d8e1d1d3..21a90ba4 100644
--- a/lasso/id-ff/profile.c
+++ b/lasso/id-ff/profile.c
@@ -52,6 +52,8 @@
 
 #include <stdio.h>
 
+G_DEFINE_TYPE_WITH_PRIVATE(LassoProfile, lasso_profile, LASSO_TYPE_NODE);
+
 /*****************************************************************************/
 /* public functions                                                          */
 /*****************************************************************************/
@@ -434,7 +436,8 @@ lasso_profile_set_session_from_dump(LassoProfile *profile, const gchar *dump)
 char*
 lasso_profile_get_artifact(LassoProfile *profile)
 {
-	return g_strdup(profile->private_data->artifact);
+	LassoProfilePrivate *private_data = lasso_profile_get_instance_private(profile);
+	return g_strdup(private_data->artifact);
 }
 
 /**
@@ -448,7 +451,8 @@ lasso_profile_get_artifact(LassoProfile *profile)
 char*
 lasso_profile_get_artifact_message(LassoProfile *profile)
 {
-	return g_strdup(profile->private_data->artifact_message);
+	LassoProfilePrivate *private_data = lasso_profile_get_instance_private(profile);
+	return g_strdup(private_data->artifact_message);
 }
 
 /**
@@ -467,7 +471,8 @@ lasso_profile_set_artifact_message(LassoProfile *profile, const char *message)
 			"LassoProfile object: %p", profile);
 		return;
 	}
-	lasso_assign_string(profile->private_data->artifact_message, message);
+	LassoProfilePrivate *private_data = lasso_profile_get_instance_private(profile);
+	lasso_assign_string(private_data->artifact_message, message);
 }
 
 /**
@@ -508,7 +513,8 @@ lasso_profile_get_server(LassoProfile *profile)
 char*
 lasso_profile_get_message_id(LassoProfile *profile)
 {
-	return g_strdup(profile->private_data->message_id);
+	LassoProfilePrivate *private_data = lasso_profile_get_instance_private(profile);
+	return g_strdup(private_data->message_id);
 }
 
 /**
@@ -527,7 +533,8 @@ lasso_profile_set_message_id(LassoProfile *profile, const char *message_id)
 			"LassoProfile object: %p", profile);
 		return;
 	}
-	lasso_assign_string(profile->private_data->message_id, message_id);
+	LassoProfilePrivate *private_data = lasso_profile_get_instance_private(profile);
+	lasso_assign_string(private_data->message_id, message_id);
 }
 
 /**
@@ -542,7 +549,8 @@ lasso_profile_set_message_id(LassoProfile *profile, const char *message_id)
 LassoNode*
 lasso_profile_get_idp_list(LassoProfile *profile)
 {
-	return profile->private_data->idp_list;
+	LassoProfilePrivate *private_data = lasso_profile_get_instance_private(profile);
+	return private_data->idp_list;
 }
 
 /**
@@ -562,7 +570,8 @@ lasso_profile_set_idp_list(LassoProfile *profile, const LassoNode *idp_list)
 			"LassoProfile object: %p", profile);
 		return;
 	}
-	lasso_assign_gobject(profile->private_data->idp_list, idp_list);
+	LassoProfilePrivate *private_data = lasso_profile_get_instance_private(profile);
+	lasso_assign_gobject(private_data->idp_list, idp_list);
 }
 
 /*****************************************************************************/
@@ -603,9 +612,10 @@ static LassoNodeClass *parent_class = NULL;
 void
 lasso_profile_set_signature_hint(LassoProfile *profile, LassoProfileSignatureHint signature_hint)
 {
-	if (! LASSO_IS_PROFILE(profile) || ! profile->private_data)
-		return;
-	profile->private_data->signature_hint = signature_hint;
+	if (! LASSO_IS_PROFILE(profile)) { return; }
+	LassoProfilePrivate *private_data = lasso_profile_get_instance_private(profile);
+	if (! private_data) { return; }
+	private_data->signature_hint = signature_hint;
 }
 
 /**
@@ -620,15 +630,22 @@ LassoProfileSignatureHint
 lasso_profile_get_signature_hint(LassoProfile *profile)
 {
 	LassoProfileSignatureVerifyHint signature_verify_hint;
-	if (! LASSO_IS_PROFILE(profile) || ! profile->private_data)
+	if (! LASSO_IS_PROFILE(profile))
+	{
+		return LASSO_PROFILE_SIGNATURE_HINT_MAYBE;
+	}
+	LassoProfilePrivate *private_data = lasso_profile_get_instance_private(profile);
+	if (! private_data)
+	{
 		return LASSO_PROFILE_SIGNATURE_HINT_MAYBE;
-	signature_verify_hint = profile->private_data->signature_verify_hint;
+	}
+	signature_verify_hint = private_data->signature_verify_hint;
 	if (signature_verify_hint >= LASSO_PROFILE_SIGNATURE_VERIFY_HINT_LAST) {
 		message(G_LOG_LEVEL_WARNING, "%u is an invalid signature verify hint",
 				signature_verify_hint);
 		return LASSO_PROFILE_SIGNATURE_HINT_MAYBE;
 	}
-	return profile->private_data->signature_hint;
+	return private_data->signature_hint;
 }
 
 /**
@@ -644,14 +661,15 @@ void
 lasso_profile_set_signature_verify_hint(LassoProfile *profile,
 		LassoProfileSignatureVerifyHint signature_verify_hint)
 {
-	if (! LASSO_IS_PROFILE(profile) || ! profile->private_data)
-		return;
+	if (! LASSO_IS_PROFILE(profile)) { return; }
+	LassoProfilePrivate *private_data = lasso_profile_get_instance_private(profile);
+	if (! private_data) { return; }
 	if (signature_verify_hint >= LASSO_PROFILE_SIGNATURE_VERIFY_HINT_LAST) {
 		message(G_LOG_LEVEL_WARNING, "%i is an invalid argument for " __FUNCTION__,
 				signature_verify_hint);
 		return;
 	}
-	profile->private_data->signature_verify_hint = signature_verify_hint;
+	private_data->signature_verify_hint = signature_verify_hint;
 }
 
 /**
@@ -666,9 +684,16 @@ lasso_profile_set_signature_verify_hint(LassoProfile *profile,
 LassoProfileSignatureVerifyHint
 lasso_profile_get_signature_verify_hint(LassoProfile *profile)
 {
-	if (! LASSO_IS_PROFILE(profile) || ! profile->private_data)
+	if (! LASSO_IS_PROFILE(profile))
+	{
+		return LASSO_PROFILE_SIGNATURE_VERIFY_HINT_MAYBE;
+	}
+	LassoProfilePrivate *private_data = lasso_profile_get_instance_private(profile);
+	if (! private_data)
+	{
 		return LASSO_PROFILE_SIGNATURE_VERIFY_HINT_MAYBE;
-	return profile->private_data->signature_verify_hint;
+	}
+	return private_data->signature_verify_hint;
 }
 
 
@@ -899,11 +924,12 @@ static void
 dispose(GObject *object)
 {
 	LassoProfile *profile = LASSO_PROFILE(object);
+	LassoProfilePrivate *private_data = lasso_profile_get_instance_private(profile);
 
-	if (profile->private_data->dispose_has_run) {
+	if (private_data->dispose_has_run) {
 		return;
 	}
-	profile->private_data->dispose_has_run = TRUE;
+	private_data->dispose_has_run = TRUE;
 
 
 	lasso_mem_debug("LassoProfile", "Server", profile->server);
@@ -915,13 +941,13 @@ dispose(GObject *object)
 	lasso_mem_debug("LassoProfile", "Session", profile->session);
 	lasso_release_gobject(profile->session);
 
-	lasso_release_string(profile->private_data->artifact);
-	lasso_release_string(profile->private_data->artifact_message);
+	lasso_release_string(private_data->artifact);
+	lasso_release_string(private_data->artifact_message);
 
 	G_OBJECT_CLASS(parent_class)->dispose(G_OBJECT(profile));
 
-	lasso_release_gobject(profile->private_data->idp_list);
-	lasso_release_string(profile->private_data->message_id);
+	lasso_release_gobject(private_data->idp_list);
+	lasso_release_string(private_data->message_id);
 }
 
 /*****************************************************************************/
@@ -929,15 +955,20 @@ dispose(GObject *object)
 /*****************************************************************************/
 
 static void
-instance_init(LassoProfile *profile, G_GNUC_UNUSED void *unused)
+lasso_profile_init(LassoProfile *profile)
 {
-	profile->private_data = LASSO_PROFILE_GET_PRIVATE(profile);
-	profile->private_data->dispose_has_run = FALSE;
-	profile->private_data->artifact = NULL;
-	profile->private_data->artifact_message = NULL;
-	profile->private_data->signature_hint = LASSO_PROFILE_SIGNATURE_HINT_MAYBE;
-	profile->private_data->message_id = NULL;
-	profile->private_data->idp_list = NULL;
+	LassoProfilePrivate *private_data = lasso_profile_get_instance_private(profile);
+#pragma GCC diagnostic push
+#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
+	profile->private_data = private_data;
+#pragma GCC diagnostic pop
+
+	private_data->dispose_has_run = FALSE;
+	private_data->artifact = NULL;
+	private_data->artifact_message = NULL;
+	private_data->signature_hint = LASSO_PROFILE_SIGNATURE_HINT_MAYBE;
+	private_data->message_id = NULL;
+	private_data->idp_list = NULL;
 
 	profile->server = NULL;
 	profile->request = NULL;
@@ -954,7 +985,7 @@ instance_init(LassoProfile *profile, G_GNUC_UNUSED void *unused)
 }
 
 static void
-class_init(LassoProfileClass *klass, void *unused G_GNUC_UNUSED)
+lasso_profile_class_init(LassoProfileClass *klass)
 {
 	LassoNodeClass *nclass = LASSO_NODE_CLASS(klass);
 
@@ -963,33 +994,48 @@ class_init(LassoProfileClass *klass, void *unused G_GNUC_UNUSED)
 	lasso_node_class_set_nodename(nclass, "Profile");
 	lasso_node_class_set_ns(nclass, LASSO_LASSO_HREF, LASSO_LASSO_PREFIX);
 	lasso_node_class_add_snippets(nclass, schema_snippets);
-	g_type_class_add_private(klass, sizeof(LassoProfilePrivate));
 
 	G_OBJECT_CLASS(klass)->dispose = dispose;
 }
 
-GType
-lasso_profile_get_type()
+
+const char*
+lasso_profile_private_get_artifact(LassoProfile *profile)
 {
-	static GType this_type = 0;
+	LassoProfilePrivate *private_data = lasso_profile_get_instance_private(profile);
+	return private_data->artifact;
+}
 
-	if (!this_type) {
-		static const GTypeInfo this_info = {
-			sizeof(LassoProfileClass),
-			NULL,
-			NULL,
-			(GClassInitFunc) class_init,
-			NULL,
-			NULL,
-			sizeof(LassoProfile),
-			0,
-			(GInstanceInitFunc) instance_init,
-			NULL
-		};
+void
+lasso_profile_set_artifact(LassoProfile *profile, char *artifact)
+{
+	LassoProfilePrivate *private_data = lasso_profile_get_instance_private(profile);
+	lasso_assign_string(private_data->artifact, artifact);
+}
 
-		this_type = g_type_register_static(LASSO_TYPE_NODE,
-				"LassoProfile", &this_info, 0);
-	}
-	return this_type;
+void
+lasso_profile_set_new_artifact(LassoProfile *profile, char *artifact)
+{
+	LassoProfilePrivate *private_data = lasso_profile_get_instance_private(profile);
+	lasso_assign_new_string(private_data->artifact, artifact);
+}
+
+void
+lasso_profile_set_new_artifact_message(LassoProfile *profile, char *artifact_message)
+{
+	LassoProfilePrivate *private_data = lasso_profile_get_instance_private(profile);
+	lasso_assign_string(private_data->artifact_message, artifact_message);
 }
 
+const char*
+lasso_profile_private_get_artifact_message(LassoProfile *profile)
+{
+	LassoProfilePrivate *private_data = lasso_profile_get_instance_private(profile);
+	return private_data->artifact_message;
+}
+
+gboolean
+lasso_profile_is_init(LassoProfile *profile)
+{
+	return lasso_profile_get_instance_private(profile) != NULL;
+}
diff --git a/lasso/id-ff/profile.h b/lasso/id-ff/profile.h
index 681ae455..cd02f97f 100644
--- a/lasso/id-ff/profile.h
+++ b/lasso/id-ff/profile.h
@@ -152,7 +152,7 @@ struct _LassoProfile {
 	LassoHttpMethod http_request_method;
 	gint signature_status;
 
-	LassoProfilePrivate *private_data;
+	LassoProfilePrivate *private_data __attribute__ ((deprecated));
 };
 
 struct _LassoProfileClass {
diff --git a/lasso/id-ff/profileprivate.h b/lasso/id-ff/profileprivate.h
index 8527ca52..d19b1877 100644
--- a/lasso/id-ff/profileprivate.h
+++ b/lasso/id-ff/profileprivate.h
@@ -44,9 +44,13 @@ struct _LassoProfilePrivate
 
 void lasso_profile_set_response_status(LassoProfile *profile, const gchar *statusCodeValue);
 void lasso_profile_clean_msg_info(LassoProfile *profile);
+const char *lasso_profile_private_get_artifact(LassoProfile *profile);
+void lasso_profile_set_artifact(LassoProfile *profile, char *artifact);
+void lasso_profile_set_new_artifact(LassoProfile *profile, char *artifact);
+void lasso_profile_set_new_artifact_message(LassoProfile *profile, char *artifact);
+const char *lasso_profile_private_get_artifact_message(LassoProfile *profile);
+gboolean lasso_profile_is_init(LassoProfile *profile);
 
-#define LASSO_PROFILE_GET_PRIVATE(o) \
-	   (G_TYPE_INSTANCE_GET_PRIVATE ((o), LASSO_TYPE_PROFILE, LassoProfilePrivate))
 
 #ifdef __cplusplus
 }
diff --git a/lasso/id-ff/provider.c b/lasso/id-ff/provider.c
index ec097974..1dcd1b02 100644
--- a/lasso/id-ff/provider.c
+++ b/lasso/id-ff/provider.c
@@ -67,6 +67,8 @@ use this default role to access descriptors.</para>
 #include "../debug.h"
 #include "../keyprivate.h"
 
+G_DEFINE_TYPE_WITH_PRIVATE(LassoProvider, lasso_provider, LASSO_TYPE_NODE);
+
 static char *protocol_uris[LASSO_MD_PROTOCOL_TYPE_LAST] = {
 	"http://projectliberty.org/profiles/fedterm",
 	"http://projectliberty.org/profiles/nim",
@@ -98,7 +100,8 @@ typedef int LassoProviderRoleIndex;
 
 static int
 lasso_provider_try_loading_public_keys(LassoProvider *provider, GList **public_keys, gboolean mandatory) {
-	if (provider->public_key || provider->private_data->signing_key_descriptors) {
+	LassoProviderPrivate *private_data = lasso_provider_get_instance_private(provider);
+	if (provider->public_key || private_data->signing_key_descriptors) {
 		*public_keys = lasso_provider_get_public_keys(provider);
 		if (*public_keys == NULL)
 			return LASSO_DS_ERROR_PUBLIC_KEY_LOAD_FAILED;
@@ -144,10 +147,11 @@ lasso_provider_get_assertion_consumer_service_url(LassoProvider *provider, const
 {
 	char *name = NULL;
 	char *assertion_consumer_service_url = NULL;
+	LassoProviderPrivate *private_data = lasso_provider_get_instance_private(provider);
 
 	g_return_val_if_fail(LASSO_IS_PROVIDER(provider), NULL);
 
-	if (provider->private_data->conformance == LASSO_PROTOCOL_SAML_2_0) {
+	if (private_data->conformance == LASSO_PROTOCOL_SAML_2_0) {
 		long sid = -1;
 		if (service_id != NULL) {
 			if (lasso_string_to_xsd_integer(service_id, &sid)) {
@@ -160,7 +164,7 @@ lasso_provider_get_assertion_consumer_service_url(LassoProvider *provider, const
 	}
 
 	if (service_id == NULL)
-		service_id = provider->private_data->default_assertion_consumer;
+		service_id = private_data->default_assertion_consumer;
 	name = g_strdup_printf("AssertionConsumerServiceURL %s", service_id);
 	assertion_consumer_service_url = lasso_provider_get_metadata_one_for_role(provider, LASSO_PROVIDER_ROLE_SP, name);
 	lasso_release(name);
@@ -197,9 +201,10 @@ _lasso_provider_add_metadata_value_for_role(LassoProvider *provider, LassoProvid
 	GHashTable *descriptor;
 	char *symbol;
 	const char *role_prefix;
+	LassoProviderPrivate *private_data = lasso_provider_get_instance_private(provider);
 
 	g_return_if_fail(LASSO_IS_PROVIDER(provider) && name && value);
-	descriptor = provider->private_data->Descriptors; /* default to SP */
+	descriptor = private_data->Descriptors; /* default to SP */
 	g_return_if_fail (descriptor);
 	l = (GList*)lasso_provider_get_metadata_list_for_role(provider, role, name);
 	lasso_list_add_string(l, value);
@@ -230,11 +235,12 @@ lasso_provider_get_metadata_list_for_role(const LassoProvider *provider, LassoPr
 	GHashTable *descriptor;
 	char *symbol;
 	const char *role_prefix;
+	const LassoProviderPrivate *private_data = lasso_provider_get_instance_private((LassoProvider*)provider);
 
 	g_return_val_if_fail(LASSO_IS_PROVIDER(provider) && name, NULL);
 	g_return_val_if_fail(_lasso_provider_get_role_index(role), NULL);
 
-	descriptor = provider->private_data->Descriptors; /* default to SP */
+	descriptor = private_data->Descriptors; /* default to SP */
 	if (descriptor == NULL)
 		return NULL;
 
@@ -324,10 +330,11 @@ lasso_provider_get_first_http_method(LassoProvider *provider,
 	const GList *t1, *t2 = NULL;
 	gboolean found;
 	const gchar *role_prefix;
+	LassoProviderPrivate *private_data = lasso_provider_get_instance_private(provider);
 
 	g_return_val_if_fail(LASSO_IS_PROVIDER(provider), LASSO_HTTP_METHOD_NONE);
 	g_return_val_if_fail(remote_provider != NULL, LASSO_HTTP_METHOD_NONE);
-	if (provider->private_data->conformance == LASSO_PROTOCOL_SAML_2_0) {
+	if (private_data->conformance == LASSO_PROTOCOL_SAML_2_0) {
 		return lasso_saml20_provider_get_first_http_method(
 				provider, remote_provider, protocol_type);
 	}
@@ -396,9 +403,10 @@ lasso_provider_accept_http_method(LassoProvider *provider, LassoProvider *remote
 	LassoProviderRole initiating_role;
 	char *protocol_profile;
 	const gchar *role_prefix;
+	LassoProviderPrivate *private_data = lasso_provider_get_instance_private(provider);
 
 	g_return_val_if_fail(LASSO_IS_PROVIDER(provider), FALSE); /* Be conservative */
-	if (provider->private_data->conformance == LASSO_PROTOCOL_SAML_2_0) {
+	if (private_data->conformance == LASSO_PROTOCOL_SAML_2_0) {
 		return lasso_saml20_provider_accept_http_method(
 				provider, remote_provider, protocol_type,
 				http_method, initiate_profile);
@@ -499,8 +507,9 @@ xmlNode*
 lasso_provider_get_organization(const LassoProvider *provider)
 {
 	g_return_val_if_fail(LASSO_IS_PROVIDER(provider), NULL);
-	if (provider->private_data->organization) {
-		return xmlCopyNode(provider->private_data->organization, 1);
+	const LassoProviderPrivate *private_data = lasso_provider_get_instance_private((LassoProvider*)provider);
+	if (private_data->organization) {
+		return xmlCopyNode(private_data->organization, 1);
 	} else {
 		return NULL;
 	}
@@ -536,7 +545,8 @@ GList*
 lasso_provider_get_public_keys(const LassoProvider *provider)
 {
 	g_return_val_if_fail(LASSO_IS_PROVIDER(provider), NULL);
-	return provider->private_data->signing_public_keys;
+	const LassoProviderPrivate *private_data = lasso_provider_get_instance_private((LassoProvider*)provider);
+	return private_data->signing_public_keys;
 }
 
 /**
@@ -553,8 +563,9 @@ lasso_provider_get_encryption_public_key(const LassoProvider *provider)
 {
 	g_return_val_if_fail(LASSO_IS_PROVIDER(provider), NULL);
 	GList *keys;
+	const LassoProviderPrivate *private_data = lasso_provider_get_instance_private((LassoProvider*)provider);
 
-	keys = provider->private_data->encryption_public_keys;
+	keys = private_data->encryption_public_keys;
 	/* encrypt using the first given key, multiple encryption key in the metadata is generally
 	 * useless. roll-over of the encryption key is done mainly at the receiving side, by trying
 	 * to decipher using the two private keys, the old and the new. */
@@ -570,6 +581,7 @@ _lasso_provider_load_endpoint_type(LassoProvider *provider, xmlNode *endpoint,
 {
 	char *name = (char*)endpoint->name;
 	xmlChar *value = NULL;
+	LassoProviderPrivate *private_data = lasso_provider_get_instance_private(provider);
 
 	if (strcmp(name, "AssertionConsumerServiceURL") == 0) {
 		char *isDefault = (char*)xmlGetProp(endpoint, (xmlChar*)"isDefault");
@@ -577,7 +589,7 @@ _lasso_provider_load_endpoint_type(LassoProvider *provider, xmlNode *endpoint,
 		name = g_strdup_printf("%s %s", name, id);
 		if (isDefault) {
 			if (strcmp(isDefault, "true") == 0 || strcmp(isDefault, "1") == 0)
-				lasso_assign_string(provider->private_data->default_assertion_consumer,
+				lasso_assign_string(private_data->default_assertion_consumer,
 					id);
 			xmlFree(isDefault);
 		}
@@ -628,6 +640,7 @@ get_xmlNode(LassoNode *node, gboolean lasso_dump)
 		"Assertion",
 		"Both"
 	};
+	LassoProviderPrivate *private_data = lasso_provider_get_instance_private(provider);
 
 	xmlnode = parent_class->get_xmlNode(node, lasso_dump);
 
@@ -639,7 +652,7 @@ get_xmlNode(LassoNode *node, gboolean lasso_dump)
 
 	/* Save encryption mode */
 	xmlSetProp(xmlnode, (xmlChar*)"EncryptionMode",
-		(xmlChar*)encryption_mode[provider->private_data->encryption_mode]);
+		(xmlChar*)encryption_mode[private_data->encryption_mode]);
 
 	return xmlnode;
 }
@@ -651,9 +664,9 @@ _lasso_provider_load_key_descriptor(LassoProvider *provider, xmlNode *key_descri
 	xmlChar *use;
 
 	g_return_if_fail(LASSO_IS_PROVIDER(provider));
-	g_return_if_fail(provider->private_data);
+	private_data = lasso_provider_get_instance_private(provider);
+	g_return_if_fail(private_data);
 
-	private_data = provider->private_data;
 	use = xmlGetProp(key_descriptor, (xmlChar*)"use");
 	if (use == NULL || lasso_strisequal((char *)use,"signing")) {
 		lasso_list_add_xml_node(private_data->signing_key_descriptors,
@@ -681,6 +694,7 @@ init_from_xml(LassoNode *node, xmlNode *xmlnode)
 	xmlChar *s;
 	int i;
 	int rc = 0;
+	LassoProviderPrivate *private_data = lasso_provider_get_instance_private(provider);
 
 	parent_class->init_from_xml(node, xmlnode);
 
@@ -706,11 +720,11 @@ init_from_xml(LassoNode *node, xmlNode *xmlnode)
 	/* Load encryption mode */
 	s = xmlGetProp(xmlnode, (xmlChar*)"EncryptionMode");
 	if (s != NULL && strcmp((char*)s, "NameId") == 0) {
-		provider->private_data->encryption_mode = LASSO_ENCRYPTION_MODE_NAMEID;
+		private_data->encryption_mode = LASSO_ENCRYPTION_MODE_NAMEID;
 	} else if (s != NULL && strcmp((char*)s, "Assertion") == 0) {
-		provider->private_data->encryption_mode = LASSO_ENCRYPTION_MODE_ASSERTION;
+		private_data->encryption_mode = LASSO_ENCRYPTION_MODE_ASSERTION;
 	} else if (s != NULL && strcmp((char*)s, "Both") == 0) {
-		provider->private_data->encryption_mode =
+		private_data->encryption_mode =
 			LASSO_ENCRYPTION_MODE_NAMEID | LASSO_ENCRYPTION_MODE_ASSERTION;
 	}
 	if (s != NULL) {
@@ -745,10 +759,8 @@ init_from_xml(LassoNode *node, xmlNode *xmlnode)
 static void*
 _lasso_provider_get_pdata_thing(LassoProvider *provider, ptrdiff_t offset)
 {
-	LassoProviderPrivate *pdata;
-
 	lasso_return_val_if_fail(LASSO_IS_PROVIDER(provider), NULL);
-	pdata = provider->private_data;
+	LassoProviderPrivate *pdata = lasso_provider_get_instance_private(provider);
 	if (pdata)
 		return G_STRUCT_MEMBER_P(pdata, offset);
 
@@ -827,51 +839,52 @@ static void
 dispose(GObject *object)
 {
 	LassoProvider *provider = LASSO_PROVIDER(object);
+	LassoProviderPrivate *private_data = lasso_provider_get_instance_private(provider);
 
-	if (provider->private_data->dispose_has_run) {
+	if (private_data->dispose_has_run) {
 		return;
 	}
-	provider->private_data->dispose_has_run = TRUE;
+	private_data->dispose_has_run = TRUE;
 
-	lasso_release_ghashtable(provider->private_data->Descriptors);
+	lasso_release_ghashtable(private_data->Descriptors);
 
-	if (provider->private_data->organization) {
-		xmlFreeNode(provider->private_data->organization);
-		provider->private_data->organization = NULL;
+	if (private_data->organization) {
+		xmlFreeNode(private_data->organization);
+		private_data->organization = NULL;
 	}
 
-	if (provider->private_data->default_assertion_consumer) {
-		lasso_release(provider->private_data->default_assertion_consumer);
-		provider->private_data->default_assertion_consumer = NULL;
+	if (private_data->default_assertion_consumer) {
+		lasso_release(private_data->default_assertion_consumer);
+		private_data->default_assertion_consumer = NULL;
 	}
 
-	if (provider->private_data->signing_public_keys) {
-		lasso_release_list_of_sec_key(provider->private_data->signing_public_keys);
+	if (private_data->signing_public_keys) {
+		lasso_release_list_of_sec_key(private_data->signing_public_keys);
 	}
 
-	if (provider->private_data->signing_key_descriptors) {
-		lasso_release_list_of_xml_node(provider->private_data->signing_key_descriptors);
+	if (private_data->signing_key_descriptors) {
+		lasso_release_list_of_xml_node(private_data->signing_key_descriptors);
 	}
 
-	if (provider->private_data->encryption_key_descriptor) {
-		xmlFreeNode(provider->private_data->encryption_key_descriptor);
-		provider->private_data->encryption_key_descriptor = NULL;
+	if (private_data->encryption_key_descriptor) {
+		xmlFreeNode(private_data->encryption_key_descriptor);
+		private_data->encryption_key_descriptor = NULL;
 	}
 
-	if (provider->private_data->encryption_public_key_str) {
-		lasso_release(provider->private_data->encryption_public_key_str);
-		provider->private_data->encryption_public_key_str = NULL;
+	if (private_data->encryption_public_key_str) {
+		lasso_release(private_data->encryption_public_key_str);
+		private_data->encryption_public_key_str = NULL;
 	}
 
-	lasso_release_list_of_sec_key(provider->private_data->encryption_public_keys);
+	lasso_release_list_of_sec_key(private_data->encryption_public_keys);
 
-	lasso_release(provider->private_data->affiliation_id);
-	provider->private_data->affiliation_id = NULL;
-	lasso_release(provider->private_data->affiliation_owner_id);
-	provider->private_data->affiliation_owner_id = NULL;
-	lasso_release_list_of_full(provider->private_data->endpoints, lasso_endpoint_free);
+	lasso_release(private_data->affiliation_id);
+	private_data->affiliation_id = NULL;
+	lasso_release(private_data->affiliation_owner_id);
+	private_data->affiliation_owner_id = NULL;
+	lasso_release_list_of_full(private_data->endpoints, lasso_endpoint_free);
 
-	lasso_assign_new_signature_context(provider->private_data->signature_context,
+	lasso_assign_new_signature_context(private_data->signature_context,
 			LASSO_SIGNATURE_CONTEXT_NONE);
 
 	G_OBJECT_CLASS(parent_class)->dispose(G_OBJECT(provider));
@@ -882,38 +895,43 @@ dispose(GObject *object)
 /*****************************************************************************/
 
 static void
-instance_init(LassoProvider *provider, G_GNUC_UNUSED void *unused)
+lasso_provider_init(LassoProvider *provider)
 {
 	provider->role = LASSO_PROVIDER_ROLE_NONE;
 	provider->ProviderID = NULL;
 	provider->metadata_filename = NULL;
 	provider->public_key = NULL;
 	provider->ca_cert_chain = NULL;
-	provider->private_data = G_TYPE_INSTANCE_GET_PRIVATE(provider, LASSO_TYPE_PROVIDER,
-			LassoProviderPrivate);
-	provider->private_data->dispose_has_run = FALSE;
-	provider->private_data->default_assertion_consumer = NULL;
-	provider->private_data->affiliation_id = NULL;
-	provider->private_data->affiliation_owner_id = NULL;
-	provider->private_data->organization = NULL;
-	provider->private_data->signing_public_keys = NULL;
-	provider->private_data->signing_key_descriptors = NULL;
-	provider->private_data->encryption_key_descriptor = NULL;
-	provider->private_data->encryption_public_key_str = NULL;
-	provider->private_data->encryption_public_keys = NULL;
-	provider->private_data->encryption_mode = LASSO_ENCRYPTION_MODE_NONE;
-	provider->private_data->encryption_sym_key_type = LASSO_ENCRYPTION_SYM_KEY_TYPE_AES_128;
-	provider->private_data->key_encryption_method = LASSO_KEY_ENCRYPTION_METHOD_DEFAULT;
-	provider->private_data->signature_context = LASSO_SIGNATURE_CONTEXT_NONE;
+
+	LassoProviderPrivate *private_data = lasso_provider_get_instance_private(provider);
+	private_data->dispose_has_run = FALSE;
+	private_data->default_assertion_consumer = NULL;
+	private_data->affiliation_id = NULL;
+	private_data->affiliation_owner_id = NULL;
+	private_data->organization = NULL;
+	private_data->signing_public_keys = NULL;
+	private_data->signing_key_descriptors = NULL;
+	private_data->encryption_key_descriptor = NULL;
+	private_data->encryption_public_key_str = NULL;
+	private_data->encryption_public_keys = NULL;
+	private_data->encryption_mode = LASSO_ENCRYPTION_MODE_NONE;
+	private_data->encryption_sym_key_type = LASSO_ENCRYPTION_SYM_KEY_TYPE_AES_128;
+	private_data->key_encryption_method = LASSO_KEY_ENCRYPTION_METHOD_DEFAULT;
+	private_data->signature_context = LASSO_SIGNATURE_CONTEXT_NONE;
 
 	/* no value_destroy_func since it shouldn't destroy the GList on insert */
-	provider->private_data->Descriptors = g_hash_table_new_full(
-			g_str_hash, g_str_equal, g_free, (GFreeFunc)free_list_strings);
-	provider->private_data->attributes = NULL;
+	private_data->Descriptors = g_hash_table_new_full(
+	      g_str_hash, g_str_equal, g_free, (GFreeFunc)free_list_strings);
+	private_data->attributes = NULL;
+
+#pragma GCC diagnostic push
+#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
+	provider->private_data = private_data;
+#pragma GCC diagnostic pop
 }
 
 static void
-class_init(LassoProviderClass *klass, void *unused G_GNUC_UNUSED)
+lasso_provider_class_init(LassoProviderClass *klass)
 {
 	LassoNodeClass *nclass = LASSO_NODE_CLASS(klass);
 
@@ -926,33 +944,8 @@ class_init(LassoProviderClass *klass, void *unused G_GNUC_UNUSED)
 	nclass->init_from_xml = init_from_xml;
 
 	G_OBJECT_CLASS(klass)->dispose = dispose;
-	g_type_class_add_private(G_OBJECT_CLASS(klass), sizeof(LassoProviderPrivate));
 }
 
-GType
-lasso_provider_get_type()
-{
-	static GType this_type = 0;
-
-	if (!this_type) {
-		static const GTypeInfo this_info = {
-			sizeof (LassoProviderClass),
-			NULL,
-			NULL,
-			(GClassInitFunc) class_init,
-			NULL,
-			NULL,
-			sizeof(LassoProvider),
-			0,
-			(GInstanceInitFunc) instance_init,
-			NULL
-		};
-
-		this_type = g_type_register_static(LASSO_TYPE_NODE,
-				"LassoProvider", &this_info, 0);
-	}
-	return this_type;
-}
 
 /**
  * lasso_provider_get_protocol_conformance:
@@ -967,7 +960,8 @@ LassoProtocolConformance
 lasso_provider_get_protocol_conformance(const LassoProvider *provider)
 {
 	g_return_val_if_fail(LASSO_IS_PROVIDER(provider), LASSO_PROTOCOL_NONE);
-	return provider->private_data->conformance;
+	const LassoProviderPrivate *private_data = lasso_provider_get_instance_private((LassoProvider*)provider);
+	return private_data->conformance;
 }
 
 /**
@@ -993,7 +987,8 @@ lasso_provider_get_protocol_conformance(const LassoProvider *provider)
 void
 lasso_provider_set_protocol_conformance(LassoProvider *provider, LassoProtocolConformance protocol_conformance)
 {
-	provider->private_data->conformance = protocol_conformance;
+	LassoProviderPrivate *private_data = lasso_provider_get_instance_private(provider);
+	private_data->conformance = protocol_conformance;
 }
 
 gboolean
@@ -1068,6 +1063,7 @@ _lasso_provider_load_metadata_from_xmlnode(LassoProvider *provider, xmlNode *nod
 	const char *xpath_sp = "/md:EntityDescriptor/md:SPDescriptor";
 	const char *xpath_organization = "/md:EntityDescriptor/md:Organization";
 	xmlChar *providerID = NULL;
+	LassoProviderPrivate *private_data = lasso_provider_get_instance_private(provider);
 
 	g_return_val_if_fail(LASSO_IS_PROVIDER(provider), FALSE);
 	g_return_val_if_fail(node != NULL && node->ns != NULL, FALSE);
@@ -1079,12 +1075,12 @@ _lasso_provider_load_metadata_from_xmlnode(LassoProvider *provider, xmlNode *nod
 
 	if (strcmp((char*)node->ns->href, LASSO_SAML2_METADATA_HREF) == 0) {
 		gboolean result;
-		provider->private_data->conformance = LASSO_PROTOCOL_SAML_2_0;
+		private_data->conformance = LASSO_PROTOCOL_SAML_2_0;
 		result = lasso_saml20_provider_load_metadata(provider, node);
 		return result;
 	}
 
-	provider->private_data->conformance = LASSO_PROTOCOL_LIBERTY_1_2;
+	private_data->conformance = LASSO_PROTOCOL_LIBERTY_1_2;
 
 	xpathCtx = xmlXPathNewContext(doc);
 	xmlXPathRegisterNs(xpathCtx, (xmlChar*)"md", (xmlChar*)LASSO_METADATA_HREF);
@@ -1102,7 +1098,7 @@ _lasso_provider_load_metadata_from_xmlnode(LassoProvider *provider, xmlNode *nod
 			xmlXPathFreeContext(xpathCtx);
 			return FALSE;
 		}
-		provider->private_data->conformance = LASSO_PROTOCOL_LIBERTY_1_1;
+		private_data->conformance = LASSO_PROTOCOL_LIBERTY_1_1;
 		xpath_idp = "/md11:IDPDescriptor";
 		xpath_sp = "/md11:SPDescriptor";
 	}
@@ -1116,7 +1112,7 @@ _lasso_provider_load_metadata_from_xmlnode(LassoProvider *provider, xmlNode *nod
 	if (xpathObj && xpathObj->nodesetval && xpathObj->nodesetval->nodeNr == 1) {
 		_lasso_provider_load_descriptor(provider, xpathObj->nodesetval->nodeTab[0],
 				LASSO_PROVIDER_ROLE_IDP);
-		if (provider->private_data->conformance < LASSO_PROTOCOL_LIBERTY_1_2) {
+		if (private_data->conformance < LASSO_PROTOCOL_LIBERTY_1_2) {
 			/* lookup ProviderID */
 			node = xpathObj->nodesetval->nodeTab[0]->children;
 			while (node) {
@@ -1136,7 +1132,7 @@ _lasso_provider_load_metadata_from_xmlnode(LassoProvider *provider, xmlNode *nod
 	if (xpathObj && xpathObj->nodesetval && xpathObj->nodesetval->nodeNr == 1) {
 		_lasso_provider_load_descriptor(provider, xpathObj->nodesetval->nodeTab[0],
 				LASSO_PROVIDER_ROLE_SP);
-		if (provider->private_data->conformance < LASSO_PROTOCOL_LIBERTY_1_2) {
+		if (private_data->conformance < LASSO_PROTOCOL_LIBERTY_1_2) {
 			/* lookup ProviderID */
 			node = xpathObj->nodesetval->nodeTab[0]->children;
 			while (node) {
@@ -1154,7 +1150,7 @@ _lasso_provider_load_metadata_from_xmlnode(LassoProvider *provider, xmlNode *nod
 
 	xpathObj = xmlXPathEvalExpression((xmlChar*)xpath_organization, xpathCtx);
 	if (xpathObj && xpathObj->nodesetval && xpathObj->nodesetval->nodeNr == 1) {
-		lasso_assign_xml_node(provider->private_data->organization,
+		lasso_assign_xml_node(private_data->organization,
 				xpathObj->nodesetval->nodeTab[0]);
 	}
 	xmlXPathFreeObject(xpathObj);
@@ -1175,7 +1171,8 @@ _lasso_provider_new_helper(LassoProviderRole role, const char *metadata,
 		const char *public_key, const char *ca_cert_chain, gboolean (*loader)(
 			LassoProvider *provider, const gchar *metadata))
 {
-	LassoProvider *provider = NULL, *ret = NULL;
+	LassoProvider *provider, *ret = NULL;
+	LassoProviderPrivate *private_data;
 
 	provider = (LassoProvider*)g_object_new(LASSO_TYPE_PROVIDER, NULL);
 	provider->role = role;
@@ -1199,7 +1196,8 @@ _lasso_provider_new_helper(LassoProviderRole role, const char *metadata,
 		goto cleanup;
 	}
 
-	provider->private_data->encryption_mode = LASSO_ENCRYPTION_MODE_NONE;
+	private_data = lasso_provider_get_instance_private(provider);
+	private_data->encryption_mode = LASSO_ENCRYPTION_MODE_NONE;
 	lasso_transfer_gobject(ret, provider);
 cleanup:
 	lasso_release_gobject(provider);
@@ -1262,11 +1260,13 @@ lasso_provider_load_public_key(LassoProvider *provider, LassoPublicKeyType publi
 	gboolean ret = FALSE;
 
 	g_return_val_if_fail(LASSO_IS_PROVIDER(provider), FALSE);
+	LassoProviderPrivate *private_data = lasso_provider_get_instance_private(provider);
+
 	if (public_key_type == LASSO_PUBLIC_KEY_SIGNING) {
 		public_key = provider->public_key;
-		keys_descriptors = provider->private_data->signing_key_descriptors;
+		keys_descriptors = private_data->signing_key_descriptors;
 	} else {
-		key_descriptor = provider->private_data->encryption_key_descriptor;
+		key_descriptor = private_data->encryption_key_descriptor;
 	}
 
 	if (public_key == NULL && keys_descriptors == NULL && key_descriptor == NULL) {
@@ -1311,10 +1311,10 @@ lasso_provider_load_public_key(LassoProvider *provider, LassoPublicKeyType publi
 		GList **dest = NULL;
 		switch (public_key_type) {
 			case LASSO_PUBLIC_KEY_SIGNING:
-				dest = &provider->private_data->signing_public_keys;
+				dest = &private_data->signing_public_keys;
 				break;
 			case LASSO_PUBLIC_KEY_ENCRYPTION:
-				dest = &provider->private_data->encryption_public_keys;
+				dest = &private_data->encryption_public_keys;
 				break;
 		}
 		if (dest) {
@@ -1486,7 +1486,8 @@ void
 lasso_provider_set_encryption_mode(LassoProvider *provider, LassoEncryptionMode encryption_mode)
 {
 	g_return_if_fail(LASSO_IS_PROVIDER(provider));
-	provider->private_data->encryption_mode = encryption_mode;
+	LassoProviderPrivate *private_data = lasso_provider_get_instance_private(provider);
+	private_data->encryption_mode = encryption_mode;
 }
 
 /**
@@ -1499,9 +1500,14 @@ lasso_provider_set_encryption_mode(LassoProvider *provider, LassoEncryptionMode
  */
 LassoEncryptionMode
 lasso_provider_get_encryption_mode(LassoProvider *provider) {
-	if (! LASSO_IS_PROVIDER(provider) || ! provider->private_data)
+	if (! LASSO_IS_PROVIDER(provider)) {
 		return LASSO_ENCRYPTION_MODE_NONE;
-	return provider->private_data->encryption_mode;
+	}
+	LassoProviderPrivate *private_data = lasso_provider_get_instance_private(provider);
+	if (! private_data) {
+		return LASSO_ENCRYPTION_MODE_NONE;
+	}
+	return private_data->encryption_mode;
 }
 
 /**
@@ -1516,7 +1522,8 @@ lasso_provider_set_encryption_sym_key_type(LassoProvider *provider,
 		LassoEncryptionSymKeyType encryption_sym_key_type)
 {
 	g_return_if_fail(LASSO_IS_PROVIDER(provider));
-	provider->private_data->encryption_sym_key_type = encryption_sym_key_type;
+	LassoProviderPrivate *private_data = lasso_provider_get_instance_private(provider);
+	private_data->encryption_sym_key_type = encryption_sym_key_type;
 }
 
 /**
@@ -1530,8 +1537,14 @@ lasso_provider_set_encryption_sym_key_type(LassoProvider *provider,
 LassoEncryptionSymKeyType
 lasso_provider_get_encryption_sym_key_type(const LassoProvider *provider)
 {
-	if (LASSO_IS_PROVIDER(provider) && provider->private_data)
-		return provider->private_data->encryption_sym_key_type;
+	if (LASSO_IS_PROVIDER(provider))
+	{
+		const LassoProviderPrivate *private_data = lasso_provider_get_instance_private((LassoProvider*)provider);
+		if (private_data)
+		{
+			return private_data->encryption_sym_key_type;
+		}
+	}
 
 	return LASSO_ENCRYPTION_SYM_KEY_TYPE_DEFAULT;
 }
@@ -1548,11 +1561,12 @@ lasso_provider_set_key_encryption_method(LassoProvider *provider,
 		LassoKeyEncryptionMethod key_encryption_method)
 {
 	g_return_if_fail(LASSO_IS_PROVIDER(provider));
+	LassoProviderPrivate *private_data = lasso_provider_get_instance_private(provider);
 
 	if (key_encryption_method == LASSO_KEY_ENCRYPTION_METHOD_DEFAULT) {
 		key_encryption_method = lasso_get_default_key_encryption_method();
 	}
-	provider->private_data->key_encryption_method = key_encryption_method;;
+	private_data->key_encryption_method = key_encryption_method;;
 }
 
 /**
@@ -1566,9 +1580,14 @@ lasso_provider_set_key_encryption_method(LassoProvider *provider,
 LassoKeyEncryptionMethod
 lasso_provider_get_key_encryption_method(const LassoProvider *provider)
 {
-	if (LASSO_IS_PROVIDER(provider) && provider->private_data)
-		if (provider->private_data->key_encryption_method != LASSO_KEY_ENCRYPTION_METHOD_DEFAULT)
-			return provider->private_data->key_encryption_method;
+	if (LASSO_IS_PROVIDER(provider))
+	{
+		const LassoProviderPrivate *private_data = lasso_provider_get_instance_private((LassoProvider*)provider);
+		if (private_data && private_data->key_encryption_method != LASSO_KEY_ENCRYPTION_METHOD_DEFAULT)
+		{
+			return private_data->key_encryption_method;
+		}
+	}
 
 	return lasso_get_default_key_encryption_method();
 }
@@ -1657,11 +1676,12 @@ lasso_provider_get_sp_name_qualifier(LassoProvider *provider)
 	const char *sp_name_qualifier;
 
 	g_return_val_if_fail(LASSO_IS_PROVIDER(provider), NULL);
+	LassoProviderPrivate *private_data = lasso_provider_get_instance_private(provider);
 	/* should not happen ! */
-	g_return_val_if_fail(provider->private_data != NULL, NULL);
+	g_return_val_if_fail(private_data != NULL, NULL);
 
-	if (provider->private_data->affiliation_id) {
-		sp_name_qualifier = provider->private_data->affiliation_id;
+	if (private_data->affiliation_id) {
+		sp_name_qualifier = private_data->affiliation_id;
 	} else {
 		sp_name_qualifier = provider->ProviderID;
 	}
@@ -1746,11 +1766,12 @@ lasso_provider_get_metadata_keys_for_role(LassoProvider *provider, LassoProvider
 	struct AddForRoleHelper helper = { NULL, role };
 
 	lasso_return_val_if_fail(LASSO_IS_PROVIDER(provider), NULL);
-	lasso_return_val_if_fail(provider->private_data != NULL, NULL);
+	LassoProviderPrivate *private_data = lasso_provider_get_instance_private(provider);
+	lasso_return_val_if_fail(private_data != NULL, NULL);
 	lasso_return_val_if_fail(role > LASSO_PROVIDER_ROLE_NONE && role < LASSO_PROVIDER_ROLE_LAST, NULL);
 	g_return_val_if_fail(role_to_prefix(role) != NULL, NULL);
 
-	g_hash_table_foreach(provider->private_data->Descriptors, (GHFunc)_add_for_role, &helper);
+	g_hash_table_foreach(private_data->Descriptors, (GHFunc)_add_for_role, &helper);
 
 	return helper.l;
 }
@@ -1766,9 +1787,12 @@ lasso_provider_get_metadata_keys_for_role(LassoProvider *provider, LassoProvider
 LassoProviderRole
 lasso_provider_get_roles(LassoProvider *provider)
 {
-	lasso_return_val_if_fail(LASSO_IS_PROVIDER(provider) && provider->private_data, LASSO_PROVIDER_ROLE_NONE);
-
-	return provider->private_data->roles;
+	lasso_return_val_if_fail(
+			LASSO_IS_PROVIDER(provider)\
+				&& lasso_provider_get_instance_private(provider),
+			LASSO_PROVIDER_ROLE_NONE);
+	LassoProviderPrivate *private_data = lasso_provider_get_instance_private(provider);
+	return private_data->roles;
 }
 
 /**
@@ -1813,7 +1837,8 @@ lasso_provider_new_from_xmlnode(LassoProviderRole role, xmlNode *node) {
 		goto cleanup;
 	}
 
-	provider->private_data->encryption_mode = LASSO_ENCRYPTION_MODE_NONE;
+	LassoProviderPrivate *private_data = lasso_provider_get_instance_private(provider);
+	private_data->encryption_mode = LASSO_ENCRYPTION_MODE_NONE;
 	lasso_transfer_gobject(ret, provider);
 cleanup:
 	lasso_release_gobject(provider);
@@ -1839,14 +1864,16 @@ lasso_provider_add_key(LassoProvider *provider, LassoKey *key, gboolean after)
 	lasso_error_t rc = 0;
 	GList **list = NULL;
 	xmlSecKey *xml_sec_key = NULL;
+	LassoProviderPrivate *private_data = NULL;
 
 	lasso_bad_param(PROVIDER, provider);
 	lasso_bad_param(KEY, key);
 
 	switch (lasso_key_get_key_type(key)) {
 		case LASSO_KEY_TYPE_FOR_SIGNATURE:
+			private_data = lasso_provider_get_instance_private(provider);
 			context = lasso_key_get_signature_context(key);
-			list = &provider->private_data->signing_public_keys;
+			list = &private_data->signing_public_keys;
 			xml_sec_key = xmlSecKeyDuplicate(context.signature_key);
 			break;
 	}
@@ -1880,8 +1907,128 @@ lasso_provider_set_server_signing_key(LassoProvider *provider,
 	context = lasso_key_get_signature_context(key);
 	goto_cleanup_if_fail_with_rc(lasso_validate_signature_context(context),
 			LASSO_DS_ERROR_PRIVATE_KEY_LOAD_FAILED);
-	lasso_assign_signature_context(provider->private_data->signature_context,
+
+	LassoProviderPrivate *private_data = lasso_provider_get_instance_private(provider);
+	lasso_assign_signature_context(private_data->signature_context,
 			context);
 cleanup:
 	return rc;
 }
+
+/*****************************************************************************/
+/* Non exported methods, headers in providerprivate.h */
+/* used by id-ff/server.c saml-2.0/server.c saml-2.0/provider.c*/
+/*****************************************************************************/
+
+gboolean
+lasso_provider_is_init(LassoProvider *provider)
+{
+	LassoProviderPrivate *private_data = lasso_provider_get_instance_private(provider);
+	return private_data != NULL;
+}
+
+const LassoSignatureContext*
+lasso_provider_get_signature_context(LassoProvider *provider)
+{
+	LassoProviderPrivate *private_data = lasso_provider_get_instance_private((LassoProvider*)provider);
+	return &private_data->signature_context;
+}
+
+const char*
+lasso_provider_get_affiliation_owner_id(LassoProvider *provider)
+{
+	LassoProviderPrivate *private_data = lasso_provider_get_instance_private(provider);
+	return private_data->affiliation_owner_id;
+}
+
+void
+lasso_provider_release_affiliation_owner_id(LassoProvider *provider)
+{
+	LassoProviderPrivate *private_data = lasso_provider_get_instance_private(provider);
+	lasso_release_string(private_data->affiliation_owner_id);
+}
+
+void
+lasso_provider_set_affiliation_owner_id(LassoProvider *provider, const char *affiliation_owner_id)
+{
+	LassoProviderPrivate *private_data = lasso_provider_get_instance_private(provider);
+	private_data->affiliation_owner_id = g_strdup(affiliation_owner_id);
+}
+
+void
+lasso_provider_set_affiliation_id(LassoProvider *provider, const char *affiliation_id)
+{
+	LassoProviderPrivate *private_data = lasso_provider_get_instance_private(provider);
+	private_data->affiliation_id = g_strdup(affiliation_id);
+}
+
+void
+lasso_provider_set_valid_until_from_prop(LassoProvider *provider, xmlNode *node, xmlChar *name, xmlChar *ns)
+{
+	LassoProviderPrivate *private_data = lasso_provider_get_instance_private(provider);
+	lasso_set_string_from_prop(&private_data->valid_until, node, name, ns);
+}
+
+void lasso_provider_set_cache_duration_from_prop(LassoProvider *provider, xmlNode *node, xmlChar *name, xmlChar *ns)
+{
+	LassoProviderPrivate *private_data = lasso_provider_get_instance_private(provider);
+	lasso_set_string_from_prop(&private_data->cache_duration, node, name, ns);
+}
+
+
+const char*
+lasso_provider_get_default_assertion_consumer(LassoProvider *provider)
+{
+	LassoProviderPrivate *private_data = lasso_provider_get_instance_private(provider);
+	return private_data->default_assertion_consumer;
+}
+
+void
+lasso_provider_set_default_assertion_consumer(LassoProvider *provider, char *assertion_consumer)
+{
+	LassoProviderPrivate *private_data = lasso_provider_get_instance_private(provider);
+	lasso_assign_string(private_data->default_assertion_consumer,
+			assertion_consumer);
+}
+
+void
+lasso_provider_sort_endpoints(LassoProvider *provider, GCompareFunc cmpfun)
+{
+	LassoProviderPrivate *private_data = lasso_provider_get_instance_private(provider);
+	private_data->endpoints = g_list_sort(private_data->endpoints, cmpfun);
+}
+
+void
+lasso_provider_add_endpoint(LassoProvider *provider, EndpointType *endpoint)
+{
+	LassoProviderPrivate *private_data = lasso_provider_get_instance_private(provider);
+	lasso_list_add(private_data->endpoints, (void*)endpoint);
+}
+
+const GList*
+lasso_provider_get_endpoints(LassoProvider *provider)
+{
+	LassoProviderPrivate *private_data = lasso_provider_get_instance_private(provider);
+	return private_data->endpoints;
+}
+
+void
+lasso_provider_add_attribute(LassoProvider *provider, LassoSaml2Attribute *attribute)
+{
+	LassoProviderPrivate *private_data = lasso_provider_get_instance_private(provider);
+	lasso_list_add(private_data->attributes, (void*)attribute);
+}
+
+void
+lasso_provider_set_organization(LassoProvider *provider, xmlNode *organization)
+{
+	LassoProviderPrivate *private_data = lasso_provider_get_instance_private(provider);
+	lasso_assign_xml_node(private_data->organization, organization);
+}
+
+void
+lasso_provider_set_roles(LassoProvider *provider, LassoProviderRole roles)
+{
+	LassoProviderPrivate *private_data = lasso_provider_get_instance_private(provider);
+	private_data->roles = roles;
+}
diff --git a/lasso/id-ff/provider.h b/lasso/id-ff/provider.h
index f0be2272..1780479f 100644
--- a/lasso/id-ff/provider.h
+++ b/lasso/id-ff/provider.h
@@ -200,7 +200,7 @@ struct _LassoProvider {
 	gchar *ca_cert_chain;
 
 	/*< private >*/
-	LassoProviderPrivate *private_data;
+	LassoProviderPrivate *private_data __attribute__ ((deprecated));
 };
 
 struct _LassoProviderClass {
@@ -278,14 +278,15 @@ LASSO_EXPORT lasso_error_t lasso_provider_set_server_signing_key(LassoProvider *
 
 LASSO_EXPORT lasso_error_t lasso_provider_add_key(LassoProvider *provider, LassoKey *key, gboolean after);
 
+LASSO_EXPORT int lasso_provider_verify_saml_signature(LassoProvider *provider, xmlNode *signed_node, xmlDoc *doc);
+
 LASSO_EXPORT int lasso_provider_verify_signature(LassoProvider *provider,
 		const char *message, const char *id_attr_name, LassoMessageFormat format);
 
 LASSO_EXPORT void lasso_provider_set_key_encryption_method(
 		LassoProvider *provider, LassoKeyEncryptionMethod method);
 
-LASSO_EXPORT LassoKeyEncryptionMethod lasso_provider_get_key_encryption_method();
-
+LASSO_EXPORT LassoKeyEncryptionMethod lasso_provider_get_key_encryption_method(const LassoProvider* provider);
 
 #ifdef __cplusplus
 }
diff --git a/lasso/id-ff/providerprivate.h b/lasso/id-ff/providerprivate.h
index 164f0d59..972b2b6a 100644
--- a/lasso/id-ff/providerprivate.h
+++ b/lasso/id-ff/providerprivate.h
@@ -26,6 +26,7 @@
 
 #include <./serverprivate.h>
 #include "../xml/private.h"
+#include "../xml/saml-2.0/saml2_attribute.h"
 
 #ifdef __cplusplus
 extern "C" {
@@ -45,7 +46,7 @@ typedef enum {
 } LassoPublicKeyType;
 
 /* This structure should allow to map ID-FFv1.2 and SAMLv2 endpoints */
-struct EndpointType_s {
+typedef struct _EndpointType {
 	LassoProviderRole role;
 	char *kind;
 	char *binding;
@@ -53,8 +54,7 @@ struct EndpointType_s {
 	char *return_url;
 	int index;
 	int is_default;
-};
-typedef struct EndpointType_s EndpointType;
+} EndpointType;
 
 
 struct _LassoProviderPrivate
@@ -93,12 +93,27 @@ GList* lasso_provider_get_public_keys(const LassoProvider *provider);
 xmlSecKey* lasso_provider_get_encryption_public_key(const LassoProvider *provider);
 LassoEncryptionSymKeyType lasso_provider_get_encryption_sym_key_type(const LassoProvider* provider);
 LassoKeyEncryptionMethod lasso_provider_get_key_encryption_method(const LassoProvider* provider);
-int lasso_provider_verify_saml_signature(LassoProvider *provider, xmlNode *signed_node, xmlDoc *doc);
 int lasso_provider_verify_query_signature(LassoProvider *provider, const char *message);
 void _lasso_provider_load_key_descriptor(LassoProvider *provider, xmlNode *key_descriptor);
 void _lasso_provider_add_metadata_value_for_role(LassoProvider *provider,
 		LassoProviderRole role, const char *name, const char *value);
 LassoProvider* lasso_provider_new_from_xmlnode(LassoProviderRole role, xmlNode *node);
+gboolean lasso_provider_is_init(LassoProvider *provider);
+const LassoSignatureContext *lasso_provider_get_signature_context(LassoProvider *provider);
+const char *lasso_provider_get_affiliation_owner_id(LassoProvider *provider);
+void lasso_provider_release_affiliation_owner_id(LassoProvider *provider);
+void lasso_provider_set_affiliation_owner_id(LassoProvider *provider, const char *affiliation_owner_id);
+void lasso_provider_set_affiliation_id(LassoProvider *provider, const char *affiliation_id);
+void lasso_provider_set_valid_until_from_prop(LassoProvider *provider, xmlNode *node, xmlChar *name, xmlChar *ns);
+void lasso_provider_set_cache_duration_from_prop(LassoProvider *provider, xmlNode *node, xmlChar *name, xmlChar *ns);
+const char *lasso_provider_get_default_assertion_consumer(LassoProvider *provider);
+void lasso_provider_set_default_assertion_consumer(LassoProvider *provider, char *assertion_consumer);
+void lasso_provider_sort_endpoints(LassoProvider *provider, GCompareFunc cmpfun);
+void lasso_provider_add_endpoint(LassoProvider *provider, EndpointType *endpoint);
+const GList *lasso_provider_get_endpoints(LassoProvider *provider);
+void lasso_provider_add_attribute(LassoProvider *provider, LassoSaml2Attribute *attribute);
+void lasso_provider_set_organization(LassoProvider *provider, xmlNode *organization);
+void lasso_provider_set_roles(LassoProvider *provider, LassoProviderRole roles);
 
 #ifdef __cplusplus
 }
diff --git a/lasso/id-ff/server.c b/lasso/id-ff/server.c
index c4b35cac..d6bbec0c 100644
--- a/lasso/id-ff/server.c
+++ b/lasso/id-ff/server.c
@@ -64,6 +64,7 @@ lasso_server_add_provider_helper(LassoServer *server, LassoProviderRole role,
 {
 	LassoProvider *provider;
 	lasso_error_t rc = 0;
+	LassoProtocolConformance server_conformance, provider_conformance;
 
 	g_return_val_if_fail(LASSO_IS_SERVER(server), LASSO_PARAM_ERROR_BAD_TYPE_OR_NULL_OBJ);
 	g_return_val_if_fail(metadata != NULL, LASSO_PARAM_ERROR_INVALID_VALUE);
@@ -72,13 +73,15 @@ lasso_server_add_provider_helper(LassoServer *server, LassoProviderRole role,
 	goto_cleanup_if_fail_with_rc(provider != NULL, critical_error(LASSO_SERVER_ERROR_ADD_PROVIDER_FAILED));
 
 	provider->role = role;
+	server_conformance = lasso_provider_get_protocol_conformance(LASSO_PROVIDER(server));
+	provider_conformance = lasso_provider_get_protocol_conformance(provider);
 
-	if (LASSO_PROVIDER(server)->private_data->conformance == LASSO_PROTOCOL_SAML_2_0 && provider->private_data->conformance != LASSO_PROTOCOL_SAML_2_0) {
+	if (server_conformance == LASSO_PROTOCOL_SAML_2_0 && provider_conformance != LASSO_PROTOCOL_SAML_2_0)
+	{
 		goto_cleanup_with_rc(LASSO_SERVER_ERROR_ADD_PROVIDER_PROTOCOL_MISMATCH);
 	}
 
-	if (LASSO_PROVIDER(server)->private_data->conformance == LASSO_PROTOCOL_LIBERTY_1_2
-		&& provider->private_data->conformance > LASSO_PROTOCOL_LIBERTY_1_2) {
+	if (server_conformance == LASSO_PROTOCOL_LIBERTY_1_2 && provider_conformance > LASSO_PROTOCOL_LIBERTY_1_2) {
 		goto_cleanup_with_rc(LASSO_SERVER_ERROR_ADD_PROVIDER_PROTOCOL_MISMATCH);
 	}
 
@@ -240,7 +243,7 @@ lasso_server_load_affiliation(LassoServer *server, const gchar *filename)
 	node = xmlDocGetRootElement(doc);
 	goto_cleanup_if_fail_with_rc (node != NULL && node->ns != NULL, LASSO_XML_ERROR_NODE_NOT_FOUND);
 
-	if (provider->private_data->conformance == LASSO_PROTOCOL_SAML_2_0) {
+	if (lasso_provider_get_protocol_conformance(provider) == LASSO_PROTOCOL_SAML_2_0) {
 		rc = lasso_saml20_server_load_affiliation(server, node);
 	} else {
 		/* affiliations are not supported in ID-FF 1.2 mode */
@@ -880,14 +883,14 @@ lasso_server_get_signature_context_for_provider(LassoServer *server,
 		LassoProvider *provider, LassoSignatureContext *signature_context)
 {
 	lasso_error_t rc = 0;
-	LassoSignatureContext *private_context = NULL;
+	const LassoSignatureContext *private_context = NULL;
 
 	lasso_bad_param(SERVER, server);
 	lasso_null_param(signature_context);
 
 	if (provider) {
 		lasso_bad_param(PROVIDER, provider);
-		private_context = &provider->private_data->signature_context;
+		private_context = lasso_provider_get_signature_context(provider);
 	}
 
 	if (private_context && lasso_ok_signature_method(private_context->signature_method)) {
diff --git a/lasso/id-ff/server.h b/lasso/id-ff/server.h
index 5f9022e9..59225179 100644
--- a/lasso/id-ff/server.h
+++ b/lasso/id-ff/server.h
@@ -133,9 +133,6 @@ LASSO_EXPORT gchar *lasso_server_get_endpoint_url_by_id(const LassoServer *serve
 LASSO_EXPORT GList *lasso_server_get_filtered_provider_list(const LassoServer *server,
 	LassoProviderRole role, LassoMdProtocolType protocol_type, LassoHttpMethod http_method);
 
-LASSO_EXPORT LassoSignatureMethod lasso_get_default_signature_method();
-void lasso_set_default_signature_method(LassoSignatureMethod meth);
-
 #ifdef __cplusplus
 }
 #endif /* __cplusplus */
diff --git a/lasso/id-ff/session.c b/lasso/id-ff/session.c
index 86f5fdec..96113411 100644
--- a/lasso/id-ff/session.c
+++ b/lasso/id-ff/session.c
@@ -43,6 +43,8 @@
 #include <xmlsec/xmltree.h>
 #include <xmlsec/base64.h>
 
+G_DEFINE_TYPE_WITH_PRIVATE(LassoSession, lasso_session, LASSO_TYPE_NODE);
+
 static gboolean lasso_match_name_id(LassoNode *a, LassoNode *b);
 
 struct _NidAndSessionIndex {
@@ -88,7 +90,8 @@ lasso_session_add_nid_and_session_index(LassoSession *session,
 		const char *providerID,
 		struct _NidAndSessionIndex *nid_and_session_index)
 {
-	GList *l = g_hash_table_lookup(session->private_data->nid_and_session_indexes, providerID);
+	LassoSessionPrivate *private_data = lasso_session_get_instance_private(session);
+	GList *l = g_hash_table_lookup(private_data->nid_and_session_indexes, providerID);
 	GList *i;
 
 	lasso_foreach(i, l) {
@@ -107,7 +110,7 @@ lasso_session_add_nid_and_session_index(LassoSession *session,
 		l = g_list_append(l, nid_and_session_index);
 	} else {
 		l = g_list_append(l, nid_and_session_index);
-		g_hash_table_insert(session->private_data->nid_and_session_indexes,
+		g_hash_table_insert(private_data->nid_and_session_indexes,
 				g_strdup(providerID), l);
 	}
 }
@@ -231,12 +234,13 @@ lasso_session_get_session_indexes(LassoSession *session,
 {
 	GList *l = NULL, *iter = NULL;
 	GList *ret = NULL;
+	LassoSessionPrivate *private_data = lasso_session_get_instance_private(session);
 
 	if (! LASSO_IS_SESSION(session))
 		return NULL;
 	if (! providerID)
 		return NULL;
-	l = g_hash_table_lookup(session->private_data->nid_and_session_indexes,
+	l = g_hash_table_lookup(private_data->nid_and_session_indexes,
 			providerID);
 
 	lasso_foreach(iter, l) {
@@ -268,6 +272,7 @@ lasso_session_get_name_ids(LassoSession *session, const gchar *providerID)
 	GList *nid_and_session_indexes = NULL;
 	GList *ret = NULL;
 	GList *i, *j;
+	LassoSessionPrivate *private_data = lasso_session_get_instance_private(session);
 
 	if (! LASSO_IS_SESSION(session))
 		return NULL;
@@ -275,7 +280,7 @@ lasso_session_get_name_ids(LassoSession *session, const gchar *providerID)
 	if (! providerID)
 		return NULL;
 
-	nid_and_session_indexes = g_hash_table_lookup(session->private_data->nid_and_session_indexes,
+	nid_and_session_indexes = g_hash_table_lookup(private_data->nid_and_session_indexes,
 			providerID);
 
 	lasso_foreach(i, nid_and_session_indexes) {
@@ -310,6 +315,7 @@ lasso_session_get_assertion_ids(LassoSession *session, const gchar *providerID)
 	GList *nid_and_session_indexes = NULL;
 	GList *ret = NULL;
 	GList *i;
+	LassoSessionPrivate *private_data = lasso_session_get_instance_private(session);
 
 	if (! LASSO_IS_SESSION(session))
 		return NULL;
@@ -317,7 +323,7 @@ lasso_session_get_assertion_ids(LassoSession *session, const gchar *providerID)
 	if (! providerID)
 		return NULL;
 
-	nid_and_session_indexes = g_hash_table_lookup(session->private_data->nid_and_session_indexes,
+	nid_and_session_indexes = g_hash_table_lookup(private_data->nid_and_session_indexes,
 			providerID);
 
 	lasso_foreach(i, nid_and_session_indexes) {
@@ -374,8 +380,9 @@ lasso_session_add_assertion_with_id(LassoSession *session, const char *assertion
 	g_return_val_if_fail(LASSO_IS_SESSION(session), LASSO_PARAM_ERROR_INVALID_VALUE);
 	g_return_val_if_fail(assertionID != NULL, LASSO_PARAM_ERROR_INVALID_VALUE);
 	g_return_val_if_fail(assertion != NULL, LASSO_PARAM_ERROR_INVALID_VALUE);
+	LassoSessionPrivate *private_data = lasso_session_get_instance_private(session);
 
-	g_hash_table_insert(session->private_data->assertions_by_id,
+	g_hash_table_insert(private_data->assertions_by_id,
 			g_strdup(assertionID),
 			xmlCopyNode(assertion, 1));
 
@@ -400,8 +407,9 @@ lasso_session_add_status(LassoSession *session, const char *providerID, LassoNod
 	g_return_val_if_fail(LASSO_IS_SESSION(session), LASSO_PARAM_ERROR_INVALID_VALUE);
 	g_return_val_if_fail(providerID != NULL, LASSO_PARAM_ERROR_INVALID_VALUE);
 	g_return_val_if_fail(status != NULL, LASSO_PARAM_ERROR_INVALID_VALUE);
+	LassoSessionPrivate *private_data = lasso_session_get_instance_private(session);
 
-	g_hash_table_insert(session->private_data->status, g_strdup(providerID), status);
+	g_hash_table_insert(private_data->status, g_strdup(providerID), status);
 
 	session->is_dirty = TRUE;
 
@@ -443,8 +451,9 @@ xmlNode*
 lasso_session_get_assertion_by_id(LassoSession *session, const gchar *assertionID)
 {
 	g_return_val_if_fail(LASSO_IS_SESSION(session), NULL);
+	LassoSessionPrivate *private_data = lasso_session_get_instance_private(session);
 
-	return g_hash_table_lookup(session->private_data->assertions_by_id, assertionID);
+	return g_hash_table_lookup(private_data->assertions_by_id, assertionID);
 }
 
 static void
@@ -499,13 +508,15 @@ lasso_session_get_status(LassoSession *session, const gchar *providerID)
 	if (session == NULL) {
 		return NULL;
 	}
-	return g_hash_table_lookup(session->private_data->status, providerID);
+	LassoSessionPrivate *private_data = lasso_session_get_instance_private(session);
+	return g_hash_table_lookup(private_data->status, providerID);
 }
 
 static void
 add_providerID(gchar *key, G_GNUC_UNUSED struct _NidAndSessionIndex *ignored, LassoSession *session)
 {
-	lasso_list_add_string(session->private_data->providerIDs, key);
+	LassoSessionPrivate *private_data = lasso_session_get_instance_private(session);
+	lasso_list_add_string(private_data->providerIDs, key);
 }
 
 /**
@@ -525,18 +536,19 @@ lasso_session_get_provider_index(LassoSession *session, gint index)
 	int length;
 
 	g_return_val_if_fail(LASSO_IS_SESSION(session), NULL);
-	g_return_val_if_fail(session->private_data, NULL);
+	LassoSessionPrivate *private_data = lasso_session_get_instance_private(session);
+	g_return_val_if_fail(private_data, NULL);
 
-	length = g_hash_table_size(session->private_data->nid_and_session_indexes);
+	length = g_hash_table_size(private_data->nid_and_session_indexes);
 
 	if (length == 0)
 		return NULL;
 
-	if (session->private_data->providerIDs == NULL) {
+	if (private_data->providerIDs == NULL) {
 		lasso_session_init_provider_ids(session);
 	}
 
-	element = g_list_nth(session->private_data->providerIDs, index);
+	element = g_list_nth(private_data->providerIDs, index);
 	if (element == NULL)
 		return NULL;
 
@@ -555,10 +567,11 @@ void
 lasso_session_init_provider_ids(LassoSession *session)
 {
 	g_return_if_fail(LASSO_IS_SESSION(session));
-	g_return_if_fail(session->private_data);
+	LassoSessionPrivate *private_data = lasso_session_get_instance_private(session);
+	g_return_if_fail(private_data);
 
-	lasso_release_list_of_strings(session->private_data->providerIDs);
-	g_hash_table_foreach(session->private_data->nid_and_session_indexes, (GHFunc)add_providerID,
+	lasso_release_list_of_strings(private_data->providerIDs);
+	g_hash_table_foreach(private_data->nid_and_session_indexes, (GHFunc)add_providerID,
 			session);
 }
 
@@ -577,11 +590,12 @@ lasso_session_is_empty(LassoSession *session)
 	if (session == NULL) {
 		return TRUE;
 	}
+	LassoSessionPrivate *private_data = lasso_session_get_instance_private(session);
 
 	if (g_hash_table_size(session->assertions) +
-	    g_hash_table_size(session->private_data->status) +
-	    g_hash_table_size(session->private_data->assertions_by_id) +
-	    g_hash_table_size(session->private_data->nid_and_session_indexes))
+	    g_hash_table_size(private_data->status) +
+	    g_hash_table_size(private_data->assertions_by_id) +
+	    g_hash_table_size(private_data->nid_and_session_indexes))
 	{
 		return FALSE;
 	}
@@ -605,9 +619,15 @@ lasso_session_count_assertions(LassoSession *session)
 	if (! LASSO_IS_SESSION(session))
 		return -1;
 	if (lasso_flag_thin_sessions)
-		hashtable = session->private_data->nid_and_session_indexes;
+	{
+		LassoSessionPrivate *private_data =
+			lasso_session_get_instance_private(session);
+		hashtable = private_data->nid_and_session_indexes;
+	}
 	else
+	{
 		hashtable = session->assertions;
+	}
 
 	return hashtable ? g_hash_table_size(hashtable) : 0;
 }
@@ -634,12 +654,13 @@ lasso_session_remove_assertion(LassoSession *session, const gchar *providerID)
 {
 	int rc = 0;
 	gboolean ok1, ok2;
+	LassoSessionPrivate *private_data = lasso_session_get_instance_private(session);
 
 	lasso_bad_param(SESSION, session);
 	lasso_return_val_if_fail(! lasso_strisempty(providerID), LASSO_PARAM_ERROR_INVALID_VALUE);
 
 	ok1 = g_hash_table_remove(session->assertions, providerID);
-	ok2 = g_hash_table_remove(session->private_data->nid_and_session_indexes, providerID);
+	ok2 = g_hash_table_remove(private_data->nid_and_session_indexes, providerID);
 
 	if (ok1 || ok2) {
 		session->is_dirty = TRUE;
@@ -664,7 +685,9 @@ lasso_session_remove_status(LassoSession *session, const gchar *providerID)
 	g_return_val_if_fail(session != NULL, LASSO_PARAM_ERROR_INVALID_VALUE);
 	g_return_val_if_fail(providerID != NULL, LASSO_PARAM_ERROR_INVALID_VALUE);
 
-	if (g_hash_table_remove(session->private_data->status, providerID)) {
+	LassoSessionPrivate *private_data = lasso_session_get_instance_private(session);
+
+	if (g_hash_table_remove(private_data->status, providerID)) {
 		session->is_dirty = TRUE;
 		return 0;
 	}
@@ -770,6 +793,7 @@ get_xmlNode(LassoNode *node, G_GNUC_UNUSED gboolean lasso_dump)
 	xmlNode *xmlnode;
 	LassoSession *session = LASSO_SESSION(node);
 	DumpContext context;
+	LassoSessionPrivate *private_data = lasso_session_get_instance_private(session);
 
 	xmlnode = xmlNewNode(NULL, (xmlChar*)"Session");
 	context.parent = xmlnode;
@@ -780,15 +804,15 @@ get_xmlNode(LassoNode *node, G_GNUC_UNUSED gboolean lasso_dump)
 	if (g_hash_table_size(session->assertions))
 		g_hash_table_foreach(session->assertions,
 				(GHFunc)add_assertion_childnode, &context);
-	if (g_hash_table_size(session->private_data->status))
-		g_hash_table_foreach(session->private_data->status,
+	if (g_hash_table_size(private_data->status))
+		g_hash_table_foreach(private_data->status,
 				(GHFunc)add_status_childnode, &context);
-	if (g_hash_table_size(session->private_data->assertions_by_id)) {
-		g_hash_table_foreach(session->private_data->assertions_by_id,
+	if (g_hash_table_size(private_data->assertions_by_id)) {
+		g_hash_table_foreach(private_data->assertions_by_id,
 				(GHFunc)add_assertion_by_id, &context);
 	}
-	if (g_hash_table_size(session->private_data->nid_and_session_indexes)) {
-		g_hash_table_foreach(session->private_data->nid_and_session_indexes,
+	if (g_hash_table_size(private_data->nid_and_session_indexes)) {
+		g_hash_table_foreach(private_data->nid_and_session_indexes,
 				(GHFunc)xmlnode_add_assertion_nid_and_session_indexes, &context);
 	}
 
@@ -906,8 +930,10 @@ init_from_xml(LassoNode *node, xmlNode *xmlnode)
 
 			if (n) {
 				LassoNode *status;
+				LassoSessionPrivate *private_data =
+					lasso_session_get_instance_private(session);
 				status = lasso_node_new_from_xmlNode(n);
-				g_hash_table_insert(session->private_data->status,
+				g_hash_table_insert(private_data->status,
 						xmlGetProp(t, (xmlChar*)"RemoteProviderID"),
 						status);
 			}
@@ -933,16 +959,17 @@ static void
 dispose(GObject *object)
 {
 	LassoSession *session = LASSO_SESSION(object);
+	LassoSessionPrivate *private_data = lasso_session_get_instance_private(session);
 
-	if (! session->private_data || session->private_data->dispose_has_run == TRUE)
+	if (! private_data || private_data->dispose_has_run == TRUE)
 		return;
-	session->private_data->dispose_has_run = TRUE;
+	private_data->dispose_has_run = TRUE;
 
 	lasso_release_ghashtable(session->assertions);
-	lasso_release_ghashtable(session->private_data->status);
-	lasso_release_list_of_strings(session->private_data->providerIDs);
-	lasso_release_ghashtable(session->private_data->assertions_by_id);
-	lasso_release_ghashtable(session->private_data->nid_and_session_indexes);
+	lasso_release_ghashtable(private_data->status);
+	lasso_release_list_of_strings(private_data->providerIDs);
+	lasso_release_ghashtable(private_data->assertions_by_id);
+	lasso_release_ghashtable(private_data->nid_and_session_indexes);
 
 	G_OBJECT_CLASS(parent_class)->dispose(object);
 }
@@ -952,28 +979,34 @@ dispose(GObject *object)
 /*****************************************************************************/
 
 static void
-instance_init(LassoSession *session, G_GNUC_UNUSED void *unused)
+lasso_session_init(LassoSession *session)
 {
-	session->private_data = LASSO_SESSION_GET_PRIVATE(session);
-	session->private_data->dispose_has_run = FALSE;
-	session->private_data->providerIDs = NULL;
-	session->private_data->status = g_hash_table_new_full(g_str_hash, g_str_equal,
+	LassoSessionPrivate *private_data = lasso_session_get_instance_private(session);
+
+	private_data->dispose_has_run = FALSE;
+	private_data->providerIDs = NULL;
+	private_data->status = g_hash_table_new_full(g_str_hash, g_str_equal,
 			(GDestroyNotify)g_free,
 			(GDestroyNotify)lasso_node_destroy);
-	session->private_data->assertions_by_id =
+	private_data->assertions_by_id =
 			g_hash_table_new_full(g_str_hash, g_str_equal,
 					(GDestroyNotify)g_free,
 					(GDestroyNotify)xmlFree);
 	session->assertions = g_hash_table_new_full(g_str_hash, g_str_equal,
 			(GDestroyNotify)g_free, (GDestroyNotify)lasso_node_destroy);
 	session->is_dirty = FALSE;
-	session->private_data->nid_and_session_indexes = g_hash_table_new_full(g_str_hash,
+	private_data->nid_and_session_indexes = g_hash_table_new_full(g_str_hash,
 			g_str_equal, (GDestroyNotify)g_free,
 			(GDestroyNotify)lasso_release_list_of_nid_an_session_index);
+
+#pragma GCC diagnostic push
+#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
+	session->private_data = private_data;
+#pragma GCC diagnostic pop
 }
 
 static void
-class_init(LassoSessionClass *klass, void *unused G_GNUC_UNUSED)
+lasso_session_class_init(LassoSessionClass *klass)
 {
 	LassoNodeClass *nclass = LASSO_NODE_CLASS(klass);
 	parent_class = g_type_class_peek_parent(klass);
@@ -983,36 +1016,10 @@ class_init(LassoSessionClass *klass, void *unused G_GNUC_UNUSED)
 	nclass->node_data = g_new0(LassoNodeClassData, 1);
 	lasso_node_class_set_nodename(nclass, "Session");
 	lasso_node_class_set_ns(nclass, LASSO_LASSO_HREF, LASSO_LASSO_PREFIX);
-	g_type_class_add_private(nclass, sizeof(LassoSessionPrivate));
 
 	G_OBJECT_CLASS(klass)->dispose = dispose;
 }
 
-GType
-lasso_session_get_type()
-{
-	static GType this_type = 0;
-
-	if (!this_type) {
-		static const GTypeInfo this_info = {
-			sizeof (LassoSessionClass),
-			NULL,
-			NULL,
-			(GClassInitFunc) class_init,
-			NULL,
-			NULL,
-			sizeof(LassoSession),
-			0,
-			(GInstanceInitFunc) instance_init,
-			NULL
-		};
-
-		this_type = g_type_register_static(LASSO_TYPE_NODE,
-				"LassoSession", &this_info, 0);
-	}
-	return this_type;
-}
-
 /**
  * lasso_session_new:
  *
@@ -1081,6 +1088,7 @@ lasso_session_has_slo_session(LassoSession *session, const gchar *provider_id)
 {
 	if (! LASSO_IS_SESSION(session))
 		return FALSE;
-	return g_hash_table_lookup(session->private_data->nid_and_session_indexes, provider_id) !=
+	LassoSessionPrivate *private_data = lasso_session_get_instance_private(session);
+	return g_hash_table_lookup(private_data->nid_and_session_indexes, provider_id) !=
 		NULL;
 }
diff --git a/lasso/id-ff/session.h b/lasso/id-ff/session.h
index 92603b6a..6fe66208 100644
--- a/lasso/id-ff/session.h
+++ b/lasso/id-ff/session.h
@@ -59,7 +59,7 @@ struct _LassoSession {
 	gboolean is_dirty;
 
 	/*< private >*/
-	LassoSessionPrivate *private_data;
+	LassoSessionPrivate *private_data __attribute__ ((deprecated));
 };
 
 struct _LassoSessionClass {
diff --git a/lasso/id-ff/sessionprivate.h b/lasso/id-ff/sessionprivate.h
index faaf922b..1d6fdbec 100644
--- a/lasso/id-ff/sessionprivate.h
+++ b/lasso/id-ff/sessionprivate.h
@@ -43,9 +43,6 @@ struct _LassoSessionPrivate
 	GHashTable *nid_and_session_indexes;
 };
 
-#define LASSO_SESSION_GET_PRIVATE(o) \
-	   (G_TYPE_INSTANCE_GET_PRIVATE ((o), LASSO_TYPE_SESSION, LassoSessionPrivate))
-
 gint lasso_session_add_status(LassoSession *session,
 		const char *providerID, LassoNode *status);
 gint lasso_session_add_assertion_with_id(LassoSession *session,
diff --git a/lasso/key.c b/lasso/key.c
index 6bf16d0c..0cb460c5 100644
--- a/lasso/key.c
+++ b/lasso/key.c
@@ -36,8 +36,7 @@ struct _LassoKeyPrivate {
 	} context;
 };
 
-#define LASSO_KEY_GET_PRIVATE(o) \
-	   (G_TYPE_INSTANCE_GET_PRIVATE ((o), LASSO_TYPE_KEY, LassoKeyPrivate))
+G_DEFINE_TYPE_WITH_PRIVATE(LassoKey, lasso_key, LASSO_TYPE_NODE);
 
 static struct XmlSnippet schema_snippets[] = {
 	{NULL, 0, 0, NULL, NULL, NULL}
@@ -51,21 +50,25 @@ static LassoNodeClass *parent_class = NULL;
 /*****************************************************************************/
 
 static void
-instance_init(LassoKey *key, G_GNUC_UNUSED void *unused)
+lasso_key_init(LassoKey *key)
 {
-	key->private_data = LASSO_KEY_GET_PRIVATE(key);
+#pragma GCC diagnostic push
+#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
+	key->private_data = lasso_key_get_instance_private(key);
+#pragma GCC diagnostic pop
 }
 
 static void
 dispose(GObject *g_object)
 {
 	LassoKey *key = (LassoKey*)g_object;
+	LassoKeyPrivate *private_data = lasso_key_get_instance_private(key);
 
-	if (key->private_data) {
-		switch (key->private_data->type) {
+	if (private_data) {
+		switch (private_data->type) {
 			case LASSO_KEY_TYPE_FOR_SIGNATURE:
 				lasso_assign_new_signature_context(
-						key->private_data->context.signature,
+						private_data->context.signature,
 						LASSO_SIGNATURE_CONTEXT_NONE);
 				break;
 		}
@@ -75,7 +78,7 @@ dispose(GObject *g_object)
 }
 
 static void
-class_init(LassoKeyClass *klass, void *unused G_GNUC_UNUSED)
+lasso_key_class_init(LassoKeyClass *klass)
 {
 	LassoNodeClass *nclass = LASSO_NODE_CLASS(klass);
 
@@ -84,35 +87,9 @@ class_init(LassoKeyClass *klass, void *unused G_GNUC_UNUSED)
 	lasso_node_class_set_nodename(nclass, "Key");
 	lasso_node_class_set_ns(nclass, LASSO_LASSO_HREF, LASSO_LASSO_PREFIX);
 	lasso_node_class_add_snippets(nclass, schema_snippets);
-	g_type_class_add_private(klass, sizeof(LassoKeyPrivate));
 	G_OBJECT_CLASS(klass)->dispose = dispose;
 }
 
-GType
-lasso_key_get_type()
-{
-	static GType this_type = 0;
-
-	if (!this_type) {
-		static const GTypeInfo this_info = {
-			sizeof (LassoKeyClass),
-			NULL,
-			NULL,
-			(GClassInitFunc) class_init,
-			NULL,
-			NULL,
-			sizeof(LassoKey),
-			0,
-			(GInstanceInitFunc) instance_init,
-			NULL
-		};
-
-		this_type = g_type_register_static(LASSO_TYPE_NODE,
-				"LassoKey", &this_info, 0);
-	}
-	return this_type;
-}
-
 static LassoKey*
 lasso_key_new()
 {
@@ -122,11 +99,12 @@ lasso_key_new()
 static LassoKey*
 lasso_key_new_for_signature_from_context(LassoSignatureContext context) {
 	LassoKey *key = lasso_key_new();
+	LassoKeyPrivate *private_data = lasso_key_get_instance_private(key);
 
-	key->private_data->type = LASSO_KEY_TYPE_FOR_SIGNATURE;
+	private_data->type = LASSO_KEY_TYPE_FOR_SIGNATURE;
 	lasso_assign_new_signature_context(
-			key->private_data->context.signature, context);
-	if (! lasso_validate_signature_context(key->private_data->context.signature)) {
+			private_data->context.signature, context);
+	if (! lasso_validate_signature_context(private_data->context.signature)) {
 		lasso_release_gobject(key);
 	}
 	return key;
@@ -366,8 +344,9 @@ lasso_key_query_sign(LassoKey *key, const char *query)
  */
 LassoSignatureContext
 lasso_key_get_signature_context(LassoKey *key) {
-	if (key->private_data && key->private_data->type == LASSO_KEY_TYPE_FOR_SIGNATURE) {
-		return key->private_data->context.signature;
+	LassoKeyPrivate *private_data = lasso_key_get_instance_private(key);
+	if (private_data && private_data->type == LASSO_KEY_TYPE_FOR_SIGNATURE) {
+		return private_data->context.signature;
 	}
 	return LASSO_SIGNATURE_CONTEXT_NONE;
 }
@@ -380,7 +359,8 @@ lasso_key_get_signature_context(LassoKey *key) {
  */
 LassoKeyType
 lasso_key_get_key_type(LassoKey *key) {
+	LassoKeyPrivate *private_data = lasso_key_get_instance_private(key);
 	lasso_return_val_if_fail(LASSO_IS_KEY(key),
 			LASSO_KEY_TYPE_FOR_SIGNATURE);
-	return key->private_data->type;
+	return private_data->type;
 }
diff --git a/lasso/key.h b/lasso/key.h
index 75309d6b..1e52f27d 100644
--- a/lasso/key.h
+++ b/lasso/key.h
@@ -55,7 +55,7 @@ typedef enum _LassoKeyType {
 struct _LassoKey {
 	LassoNode parent;
 	/*< private >*/
-	LassoKeyPrivate *private_data;
+	LassoKeyPrivate *private_data __attribute__ ((deprecated));
 };
 
 struct _LassoKeyClass {
diff --git a/lasso/lasso.c b/lasso/lasso.c
index 9902512f..9d03d44d 100644
--- a/lasso/lasso.c
+++ b/lasso/lasso.c
@@ -138,7 +138,13 @@ DllMain(HINSTANCE hinstDLL, DWORD fdwReason, LPVOID lpvReserved)
 #include "types.c"
 
 static void
-lasso_xml_structured_error_func(G_GNUC_UNUSED void *user_data, xmlErrorPtr error)
+lasso_xml_structured_error_func(G_GNUC_UNUSED void *user_data,
+#if LIBXML_VERSION >= 21200
+                                        const xmlError *error
+#else
+                                        xmlErrorPtr error
+#endif
+				)
 {
 	g_log("libxml2", G_LOG_LEVEL_DEBUG, "libxml2: %s", error->message);
 }
@@ -148,7 +154,7 @@ lasso_xmlsec_errors_callback(const char *file G_GNUC_UNUSED, int line G_GNUC_UNU
 		const char *errorObject G_GNUC_UNUSED, const char *errorSubject G_GNUC_UNUSED, int reason G_GNUC_UNUSED,
 		const char *msg)
 {
-	g_log("libxmlsec", G_LOG_LEVEL_DEBUG, "libxmlsec: %s:%d:%s:%s:%s:%s:%s", file, line, func, errorObject, errorSubject, xmlSecErrorsGetMsg(reason), msg);
+	g_log("libxmlsec", G_LOG_LEVEL_INFO, "libxmlsec: %s:%d:%s:%s:%s:%s:%s", file, line, func, errorObject, errorSubject, xmlSecErrorsGetMsg(reason), msg);
 }
 
 static int
@@ -270,7 +276,7 @@ int lasso_init()
 	 * xmlsec-crypto library.
 	 */
 #ifdef XMLSEC_CRYPTO_DYNAMIC_LOADING
-	if (xmlSecCryptoDLLoadLibrary(BAD_CAST XMLSEC_CRYPTO) < 0) {
+	if (xmlSecCryptoDLLoadLibrary(BAD_CAST xmlSecGetDefaultCrypto()) < 0) {
 		message(G_LOG_LEVEL_CRITICAL,
 				"Unable to load default xmlsec-crypto library. Make sure"
 				"that you have it installed and check shared libraries path"
diff --git a/lasso/registry-private.h b/lasso/registry-private.h
index 413c1ad4..4e0cb9f9 100644
--- a/lasso/registry-private.h
+++ b/lasso/registry-private.h
@@ -39,7 +39,7 @@ struct _LassoRegistry {
 };
 
 LassoRegistry *lasso_registry_new();
-void lasso_registry_destroy();
+void lasso_registry_destroy(LassoRegistry *registry);
 void lasso_registry_default_shutdown();
 gint lasso_registry_add_direct_mapping(LassoRegistry *registry, const char *from_namespace,
 		const char *from_name, const char *to_namespace, const char *to_name);
diff --git a/lasso/saml-2.0/login.c b/lasso/saml-2.0/login.c
index cf0814d1..a88c418b 100644
--- a/lasso/saml-2.0/login.c
+++ b/lasso/saml-2.0/login.c
@@ -87,7 +87,7 @@ lasso_saml20_login_init_authn_request(LassoLogin *login, LassoHttpMethod http_me
 	login->http_method = login->parent.http_request_method;
 
 	/* save request ID, for later check */
-	lasso_assign_string(login->private_data->request_id, request->ID);
+	lasso_login_set_request_id(login, request->ID);
 	/* set name id policy */
 	lasso_assign_new_gobject(LASSO_SAMLP2_AUTHN_REQUEST(request)->NameIDPolicy,
 			lasso_samlp2_name_id_policy_new());
@@ -917,7 +917,7 @@ lasso_saml20_login_build_assertion(LassoLogin *login,
 
 	response = LASSO_SAMLP2_RESPONSE(profile->response);
 	lasso_list_add_gobject(response->Assertion, assertion);
-	lasso_assign_gobject(login->private_data->saml2_assertion, assertion);
+	lasso_login_set_saml2_assertion(login, assertion);
 cleanup:
 	lasso_release_gobject(assertion);
 	return rc;
@@ -957,7 +957,7 @@ lasso_saml20_login_build_artifact_msg(LassoLogin *login, LassoHttpMethod http_me
 		return critical_error(LASSO_SERVER_ERROR_PROVIDER_NOT_FOUND);
 
 	url = lasso_saml20_login_get_assertion_consumer_service_url(login, remote_provider);
-	assertion = login->private_data->saml2_assertion;
+	assertion = lasso_login_get_saml2_assertion(login);
 	if (LASSO_IS_SAML2_ASSERTION(assertion) && url) {
 		LassoSaml2SubjectConfirmationData *subject_confirmation_data;
 
@@ -976,7 +976,6 @@ lasso_saml20_login_build_artifact_msg(LassoLogin *login, LassoHttpMethod http_me
 				LASSO_NODE(assertion));
 	}
 
-
 	lasso_check_good_rc(lasso_saml20_profile_build_response_msg(profile, NULL, http_method,
 				url));
 
@@ -1049,7 +1048,7 @@ lasso_saml20_login_build_response_msg(LassoLogin *login)
 		assertionConsumerURL = lasso_saml20_provider_get_assertion_consumer_service_url_by_binding(
                          remote_provider, LASSO_SAML2_METADATA_BINDING_PAOS);
 
-		assertion = login->private_data->saml2_assertion;
+		assertion = lasso_login_get_saml2_assertion(login);
 		if (LASSO_IS_SAML2_ASSERTION(assertion) == TRUE) {
 			assertion->Subject->SubjectConfirmation->SubjectConfirmationData->Recipient
 						= g_strdup(assertionConsumerURL);
@@ -1468,10 +1467,11 @@ lasso_saml20_login_process_response_status_and_assertion(LassoLogin *login)
 			LASSO_PROFILE_ERROR_MISSING_SUBJECT);
 
 		/* Verify Subject->SubjectConfirmationData->InResponseTo */
-		if (login->private_data->request_id) {
+		if (lasso_login_get_request_id(login)) {
 			const char *in_response_to = lasso_saml2_assertion_get_in_response_to(assertion);
 
-			if (lasso_strisnotequal(in_response_to,login->private_data->request_id)) {
+			if (lasso_strisnotequal(in_response_to,
+						lasso_login_get_request_id(login))) {
 				rc = LASSO_LOGIN_ERROR_ASSERTION_DOES_NOT_MATCH_REQUEST_ID;
 				goto cleanup;
 			}
@@ -1486,7 +1486,7 @@ lasso_saml20_login_process_response_status_and_assertion(LassoLogin *login)
 
 	/* set the default assertion to the last one */
 	if (last_assertion) {
-		lasso_assign_gobject (login->private_data->saml2_assertion, last_assertion);
+		lasso_login_set_saml2_assertion(login, last_assertion);
 	}
 
 cleanup:
@@ -1573,7 +1573,7 @@ lasso_saml20_login_build_authn_response_msg(LassoLogin *login)
 
 	url = lasso_saml20_login_get_assertion_consumer_service_url(login, remote_provider);
 
-	assertion = login->private_data->saml2_assertion;
+	assertion = lasso_login_get_saml2_assertion(login);
 	if (LASSO_IS_SAML2_ASSERTION(assertion) && url) {
 		LassoSaml2SubjectConfirmationData *subject_confirmation_data;
 
diff --git a/lasso/saml-2.0/profile.c b/lasso/saml-2.0/profile.c
index 378f072d..017c7c88 100644
--- a/lasso/saml-2.0/profile.c
+++ b/lasso/saml-2.0/profile.c
@@ -66,7 +66,7 @@ static gint lasso_profile_saml20_build_artifact_get_response_msg(LassoProfile *p
 		const char *service);
 static gint lasso_profile_saml20_build_artifact_post_response_msg(LassoProfile *profile,
 		const char *service);
-static char* lasso_saml20_profile_generate_artifact(LassoProfile *profile, int part);
+static const char* lasso_saml20_profile_generate_artifact(LassoProfile *profile, int part);
 
 #define check_msg_body \
 	if (! profile->msg_body) { \
@@ -157,11 +157,11 @@ http_method_to_binding(LassoHttpMethod method) {
  *
  * Return value: the generated artifact (internally allocated, don't free)
  **/
-static char*
+static const char*
 lasso_saml20_profile_generate_artifact(LassoProfile *profile, int part)
 {
 	LassoNode *what = NULL;
-	lasso_assign_new_string(profile->private_data->artifact,
+	lasso_profile_set_new_artifact(profile,
 			lasso_saml20_profile_build_artifact(&profile->server->parent));
 	if (part == 0) {
 		what = profile->request;
@@ -173,10 +173,10 @@ lasso_saml20_profile_generate_artifact(LassoProfile *profile, int part)
 	/* Remove signature at the response level, if needed if will be on the ArtifactResponse */
 	lasso_node_remove_signature(what);
 	/* Keep an XML copy of the response for later retrieval */
-	lasso_assign_new_string(profile->private_data->artifact_message,
+	lasso_profile_set_new_artifact_message(profile,
 			lasso_node_export_to_xml(what));
 
-	return profile->private_data->artifact;
+	return lasso_profile_private_get_artifact(profile);
 }
 
 
@@ -220,7 +220,7 @@ static gint
 lasso_profile_saml20_build_artifact_msg(LassoProfile *profile,
 		const char *url, int request_or_response, int get_or_post)
 {
-	char *artifact = lasso_saml20_profile_generate_artifact(profile, request_or_response);
+	const char *artifact = lasso_saml20_profile_generate_artifact(profile, request_or_response);
 
 	if (artifact == NULL) {
 		return critical_error(LASSO_PROFILE_ERROR_BUILDING_QUERY_FAILED);
@@ -373,7 +373,7 @@ lasso_saml20_profile_process_artifact_resolve(LassoProfile *profile, const char
 	if (! LASSO_IS_SAMLP2_ARTIFACT_RESOLVE(profile->request)) {
 		return critical_error(LASSO_PROFILE_ERROR_INVALID_MSG);
 	}
-	lasso_assign_string(profile->private_data->artifact,
+	lasso_profile_set_artifact(profile,
 			LASSO_SAMLP2_ARTIFACT_RESOLVE(profile->request)->Artifact);
 
 	sig_verify_hint = lasso_profile_get_signature_verify_hint(profile);
@@ -424,10 +424,10 @@ lasso_saml20_profile_build_artifact_response(LassoProfile *profile)
 	response->IssueInstant = lasso_get_current_time();
 	lasso_assign_string(response->InResponseTo, LASSO_SAMLP2_REQUEST_ABSTRACT(profile->request)->ID);
 	/* Add content */
-	if (profile->private_data->artifact_message) {
+	if (lasso_profile_private_get_artifact_message(profile)) {
 		xmlDoc *doc;
 		xmlNode *node;
-		char *content = profile->private_data->artifact_message;
+		const char *content = lasso_profile_private_get_artifact_message(profile);
 		doc = lasso_xml_parse_memory(content, strlen(content));
 		if (doc) {
 			node = xmlDocGetRootElement(doc);
diff --git a/lasso/saml-2.0/provider.c b/lasso/saml-2.0/provider.c
index dc78ffe6..22780f6c 100644
--- a/lasso/saml-2.0/provider.c
+++ b/lasso/saml-2.0/provider.c
@@ -203,7 +203,7 @@ load_endpoint_type2(xmlNode *xmlnode, LassoProvider *provider, LassoProviderRole
 	endpoint_type->role = role;
 	endpoint_type->index = idx;
 	endpoint_type->is_default = is_default;
-	lasso_list_add(provider->private_data->endpoints, (void*)endpoint_type);
+	lasso_provider_add_endpoint(provider, endpoint_type);
 
 cleanup:
 	lasso_release_xml_string(binding);
@@ -249,7 +249,6 @@ load_endpoint_type(xmlNode *xmlnode, LassoProvider *provider, LassoProviderRole
 	xmlChar *binding = xmlGetProp(xmlnode, BAD_CAST "Binding");
 	char *name = NULL;
 	char *response_name = NULL;
-	LassoProviderPrivate *private_data = provider->private_data;
 	const char *binding_s = NULL;
 	xmlChar *value = NULL;
 	xmlChar *response_value = NULL;
@@ -273,8 +272,8 @@ load_endpoint_type(xmlNode *xmlnode, LassoProvider *provider, LassoProviderRole
 		xmlChar *index = getSaml2MdProp(xmlnode, LASSO_SAML2_METADATA_ATTRIBUTE_INDEX);
 		xmlChar *is_default = getSaml2MdProp(xmlnode, LASSO_SAML2_METADATA_ATTRIBUTE_ISDEFAULT);
 
-		if (xsdIsTrue(is_default) && ! private_data->default_assertion_consumer) {
-			lasso_assign_string(private_data->default_assertion_consumer, (char*)index);
+		if (xsdIsTrue(is_default) && ! lasso_provider_get_default_assertion_consumer(provider)) {
+			lasso_provider_set_default_assertion_consumer(provider, (char*)index);
 		}
 		name = g_strdup_printf(LASSO_SAML2_METADATA_ELEMENT_ASSERTION_CONSUMER_SERVICE 
 				" %s %s", 
@@ -314,10 +313,9 @@ load_default_assertion_consumer(xmlNode *descriptor, LassoProvider *provider)
 	xmlChar *index = NULL;
 	xmlChar *is_default = NULL;
 	xmlNode *t = NULL;
-	LassoProviderPrivate *pdata = provider->private_data;
 
-	g_return_val_if_fail(pdata, FALSE);
-	if (provider->private_data->default_assertion_consumer) {
+	g_return_val_if_fail(lasso_provider_is_init(provider), FALSE);
+	if(lasso_provider_get_default_assertion_consumer(provider)) {
 		return TRUE;
 	}
 
@@ -333,7 +331,7 @@ load_default_assertion_consumer(xmlNode *descriptor, LassoProvider *provider)
 					t = xmlSecGetNextElementNode(t->next);
 					continue;
 				}
-				lasso_assign_string(pdata->default_assertion_consumer, (char*)index);
+				lasso_provider_set_default_assertion_consumer(provider, (char*)index);
 				lasso_release_xml_string(index);
 				break;
 			}
@@ -341,7 +339,7 @@ load_default_assertion_consumer(xmlNode *descriptor, LassoProvider *provider)
 		t = xmlSecGetNextElementNode(t->next);
 	}
 	lasso_release_xml_string(is_default);
-	if (provider->private_data->default_assertion_consumer) {
+	if (lasso_provider_get_default_assertion_consumer(provider)) {
 		return TRUE;
 	}
 	t = xmlSecFindChild(descriptor,
@@ -354,7 +352,7 @@ load_default_assertion_consumer(xmlNode *descriptor, LassoProvider *provider)
 	if (! index) {
 		return FALSE;
 	}
-	lasso_assign_string( pdata->default_assertion_consumer, (char*)index);
+	lasso_provider_set_default_assertion_consumer(provider, (char*)index);
 	lasso_release_xml_string(index);
 	return TRUE;
 
@@ -374,7 +372,6 @@ load_descriptor(xmlNode *xmlnode, LassoProvider *provider, LassoProviderRole rol
 	int i;
 	xmlNode *t;
 	xmlChar *value;
-	LassoProviderPrivate *pdata = provider->private_data;
 	char *token, *saveptr = NULL;
 	int counter = 0;
 	
@@ -394,7 +391,8 @@ load_descriptor(xmlNode *xmlnode, LassoProvider *provider, LassoProviderRole rol
 	lasso_release_xml_string(value);
 
 	/* add role to supported roles for the provider */
-	pdata->roles |= role;
+	lasso_provider_set_roles(provider,
+			lasso_provider_get_roles(provider) | role);
 	t = xmlSecGetNextElementNode(xmlnode->children);
 	while (t) {
 		if (checkSaml2MdNode(t,
@@ -404,8 +402,7 @@ load_descriptor(xmlNode *xmlnode, LassoProvider *provider, LassoProviderRole rol
 					LASSO_SAML2_ASSERTION_ELEMENT_ATTRIBUTE) && role == LASSO_PROVIDER_ROLE_IDP) {
 			LassoSaml2Attribute *attribute;
 			attribute = (LassoSaml2Attribute*) lasso_node_new_from_xmlNode(t);
-			lasso_list_add_new_gobject(pdata->attributes, 
-					attribute);
+			lasso_provider_add_attribute(provider, attribute);
 		} else if (hasSaml2MdProp(t, LASSO_SAML2_METADATA_ATTRIBUTE_BINDING)) {
 			load_endpoint_type(t, provider, role);
 			load_endpoint_type2(t, provider, role, &counter);
@@ -417,8 +414,7 @@ load_descriptor(xmlNode *xmlnode, LassoProvider *provider, LassoProviderRole rol
 		}
 		t = xmlSecGetNextElementNode(t->next);
 	}
-	provider->private_data->endpoints = g_list_sort(provider->private_data->endpoints,
-			(GCompareFunc) compare_endpoint_type);
+	lasso_provider_sort_endpoints(provider, (GCompareFunc)compare_endpoint_type);
 	for (i = 0; descriptor_attrs[i]; i++) {
 		value = getSaml2MdProp(xmlnode, descriptor_attrs[i]);
 		if (value == NULL) {
@@ -446,7 +442,6 @@ lasso_saml20_provider_load_metadata(LassoProvider *provider, xmlNode *root_node)
 	xmlChar *providerID;
 	xmlChar providerID_cpy[150] = "";
 
-	LassoProviderPrivate *pdata = provider->private_data;
 	static const struct {
 		char *name;
 		LassoProviderRole role;
@@ -485,13 +480,17 @@ lasso_saml20_provider_load_metadata(LassoProvider *provider, xmlNode *root_node)
 	g_strlcpy((char*) providerID_cpy, (char*) providerID, 150);
 	lasso_release_xml_string(providerID);
 	/* initialize roles */
-	pdata->roles = LASSO_PROVIDER_ROLE_NONE;
-	lasso_set_string_from_prop(&pdata->valid_until, node,
-				BAD_CAST LASSO_SAML2_METADATA_ATTRIBUTE_VALID_UNTIL,
-				BAD_CAST LASSO_SAML2_METADATA_HREF);
-	lasso_set_string_from_prop(&pdata->cache_duration, node,
-				BAD_CAST LASSO_SAML2_METADATA_ATTRIBUTE_CACHE_DURATION,
-				BAD_CAST LASSO_SAML2_METADATA_HREF);
+	lasso_provider_set_roles(provider, LASSO_PROVIDER_ROLE_NONE);
+	lasso_provider_set_valid_until_from_prop(
+		provider,
+		node,
+		BAD_CAST LASSO_SAML2_METADATA_ATTRIBUTE_VALID_UNTIL,
+		BAD_CAST LASSO_SAML2_METADATA_HREF);
+	lasso_provider_set_cache_duration_from_prop(
+		provider,
+		node,
+		BAD_CAST LASSO_SAML2_METADATA_ATTRIBUTE_CACHE_DURATION,
+		BAD_CAST LASSO_SAML2_METADATA_HREF);
 
 	descriptor_node = xmlSecGetNextElementNode(node->children);
 	while (descriptor_node) {
@@ -511,19 +510,23 @@ lasso_saml20_provider_load_metadata(LassoProvider *provider, xmlNode *root_node)
 		}
 
 		if (checkSaml2MdNode(descriptor_node,
-					LASSO_SAML2_METADATA_ELEMENT_ORGANIZATION)) {
-			lasso_assign_xml_node(pdata->organization, descriptor_node); }
+					LASSO_SAML2_METADATA_ELEMENT_ORGANIZATION))
+		{
+			lasso_provider_set_organization(provider, descriptor_node);
+		}
 		descriptor_node = xmlSecGetNextElementNode(descriptor_node->next);
 	}
 
 	if (! LASSO_IS_SERVER(provider) &&
-			(! loaded_one_or_more_descriptor || (pdata->roles & provider->role) == 0)) {
+			(! loaded_one_or_more_descriptor || \
+			 (lasso_provider_get_roles(provider) & provider->role) == 0)
+			) {
 		/* We must at least load one descriptor, and we must load a descriptor for our
 		 * assigned role or we fail. */
 		if (! loaded_one_or_more_descriptor) {
 			warning("%s: No descriptor was loaded, failing", providerID_cpy);
 		}
-		if ((pdata->roles & provider->role) == 0) {
+		if ((lasso_provider_get_roles(provider) & provider->role) == 0) {
 			warning("%s: Loaded roles and prescribed role does not intersect",
 					providerID_cpy);
 		}
@@ -552,7 +555,7 @@ enum {
 static gboolean has_synchronous_methods(LassoProvider *provider, LassoMdProtocolType protocol_type,
 		gboolean for_response)
 {
-	GList *t = NULL;
+	const GList *t = NULL;
 	const char *kind = NULL;
 	LassoHttpMethod result = LASSO_HTTP_METHOD_NONE;
 
@@ -568,7 +571,7 @@ static gboolean has_synchronous_methods(LassoProvider *provider, LassoMdProtocol
 		kind = LASSO_SAML2_METADATA_ELEMENT_ASSERTION_CONSUMER_SERVICE;
 	}
 
-	lasso_foreach(t, provider->private_data->endpoints) {
+	lasso_foreach(t, lasso_provider_get_endpoints(provider)) {
 		EndpointType *endpoint_type = (EndpointType*)t->data;
 		if (endpoint_type && lasso_strisequal(endpoint_type->kind, kind)) {
 			result = binding_uri_to_http_method(endpoint_type->binding);
@@ -584,7 +587,7 @@ LassoHttpMethod
 lasso_saml20_provider_get_first_http_method(LassoProvider *provider,
 		LassoProvider *remote_provider, LassoMdProtocolType protocol_type)
 {
-	GList *t = NULL;
+	const GList *t = NULL;
 	const char *kind = NULL;
 	LassoHttpMethod result = LASSO_HTTP_METHOD_NONE;
 	
@@ -595,7 +598,7 @@ lasso_saml20_provider_get_first_http_method(LassoProvider *provider,
 		return LASSO_HTTP_METHOD_NONE;
 	}
 
-	lasso_foreach(t, remote_provider->private_data->endpoints) {
+	lasso_foreach(t, lasso_provider_get_endpoints(remote_provider)) {
 		EndpointType *endpoint_type = (EndpointType*)t->data;
 		if (endpoint_type && lasso_strisequal(endpoint_type->kind, kind)) {
 			result = binding_uri_to_http_method(endpoint_type->binding);
@@ -617,7 +620,7 @@ lasso_saml20_provider_accept_http_method(G_GNUC_UNUSED LassoProvider *provider,
 		LassoMdProtocolType protocol_type, LassoHttpMethod http_method,
 		G_GNUC_UNUSED gboolean initiate_profile)
 {
-	GList *t = NULL;
+	const GList *t = NULL;
 	const char *kind = NULL;
 	
 	if (protocol_type < LASSO_MD_PROTOCOL_TYPE_LAST) {
@@ -628,7 +631,7 @@ lasso_saml20_provider_accept_http_method(G_GNUC_UNUSED LassoProvider *provider,
 		return FALSE;
 	}
 
-	lasso_foreach(t, remote_provider->private_data->endpoints) {
+	lasso_foreach(t, lasso_provider_get_endpoints(remote_provider)) {
 		EndpointType *endpoint_type = (EndpointType*)t->data;
 		if (endpoint_type && endpoint_type->role == remote_provider->role &&
 				lasso_strisequal(endpoint_type->kind, kind)) {
@@ -644,9 +647,9 @@ lasso_saml20_provider_accept_http_method(G_GNUC_UNUSED LassoProvider *provider,
 gboolean
 lasso_saml20_provider_check_assertion_consumer_service_url(LassoProvider *provider, const gchar *url, const gchar *binding)
 {
-	GList *t = NULL;
+	const GList *t = NULL;
 
-	lasso_foreach (t, provider->private_data->endpoints) {
+	lasso_foreach(t, lasso_provider_get_endpoints(provider)) {
 		EndpointType *endpoint_type = (EndpointType*) t->data;
 		if (endpoint_type && endpoint_type->role == LASSO_PROVIDER_ROLE_SP
 				&& lasso_strisequal(endpoint_type->url,url)
@@ -677,11 +680,11 @@ static EndpointType *
 lasso_saml20_provider_get_assertion_consumer_service(LassoProvider *provider, int service_id)
 {
 	const char *kind = LASSO_SAML2_METADATA_ELEMENT_ASSERTION_CONSUMER_SERVICE;
-	GList *t = NULL;
+	const GList *t = NULL;
 	EndpointType *result = NULL;
 
 	if (service_id != -1) {
-		lasso_foreach(t, provider->private_data->endpoints) {
+		lasso_foreach(t, lasso_provider_get_endpoints(provider)) {
 			EndpointType *endpoint_type = (EndpointType*) t->data;
 			if (! endpoint_type)
 				continue;
@@ -694,7 +697,7 @@ lasso_saml20_provider_get_assertion_consumer_service(LassoProvider *provider, in
 			}
 		}
 	} else { /* lookup a default supported endpoint type */
-		lasso_foreach(t, provider->private_data->endpoints) {
+		lasso_foreach(t, lasso_provider_get_endpoints(provider)) {
 			EndpointType *endpoint_type = (EndpointType*) t->data;
 			if (! endpoint_type)
 				continue;
@@ -740,9 +743,9 @@ const gchar*
 lasso_saml20_provider_get_assertion_consumer_service_binding_by_url(LassoProvider *provider, const char *url)
 {
 	const char *kind = LASSO_SAML2_METADATA_ELEMENT_ASSERTION_CONSUMER_SERVICE;
-	GList *t = NULL;
+	const GList *t = NULL;
 
-	lasso_foreach(t, provider->private_data->endpoints) {
+	lasso_foreach(t, lasso_provider_get_endpoints(provider)) {
 		EndpointType *endpoint_type = (EndpointType*) t->data;
 		if (! endpoint_type)
 			continue;
@@ -761,9 +764,9 @@ lasso_saml20_provider_get_assertion_consumer_service_url_by_binding(LassoProvide
 		const gchar *binding)
 {
 	const char *kind = LASSO_SAML2_METADATA_ELEMENT_ASSERTION_CONSUMER_SERVICE;
-	GList *t = NULL;
+	const GList *t = NULL;
 
-	lasso_foreach(t, provider->private_data->endpoints) {
+	lasso_foreach(t, lasso_provider_get_endpoints(provider)) {
 		EndpointType *endpoint_type = (EndpointType*) t->data;
 		if (! endpoint_type)
 			continue;
@@ -795,11 +798,11 @@ lasso_saml20_provider_get_endpoint_url(LassoProvider *provider,
 		gboolean is_default, int idx)
 {
 	EndpointType* endpoint_type = NULL;
-	GList *t = NULL;
+	const GList *t = NULL;
 
 	if (! LASSO_IS_PROVIDER(provider) || !kind)
 		return NULL;
-	lasso_foreach(t, provider->private_data->endpoints) {
+	lasso_foreach(t, lasso_provider_get_endpoints(provider)) {
 		endpoint_type = (EndpointType*) t->data;
 		if (! endpoint_type)
 			continue;
@@ -840,11 +843,11 @@ lasso_error_t
 lasso_saml20_provider_get_artifact_resolution_service_index(LassoProvider *provider, unsigned short *index)
 {
 	const char *kind = LASSO_SAML2_METADATA_ELEMENT_ARTIFACT_RESOLUTION_SERVICE;
-	GList *t = NULL;
+	const GList *t = NULL;
 
 	lasso_bad_param(PROVIDER, provider)
 	lasso_null_param(index);
-	lasso_foreach(t, provider->private_data->endpoints) {
+	lasso_foreach(t, lasso_provider_get_endpoints(provider)) {
 		EndpointType *endpoint_type = (EndpointType*) t->data;
 		if (! endpoint_type)
 			continue;
diff --git a/lasso/saml-2.0/server.c b/lasso/saml-2.0/server.c
index 9abe3206..9fd412d0 100644
--- a/lasso/saml-2.0/server.c
+++ b/lasso/saml-2.0/server.c
@@ -69,14 +69,15 @@ lasso_saml20_server_load_affiliation(LassoServer *server, xmlNode *node)
 				xmlFree(member_id);
 				continue;
 			}
-			if (provider->private_data->affiliation_owner_id) {
+			if(lasso_provider_get_affiliation_owner_id(provider))
+			{
 				message(G_LOG_LEVEL_WARNING,
 						"Provider %s in more than one affiliation",
 						provider->ProviderID);
-				lasso_release_string(provider->private_data->affiliation_owner_id);
+				lasso_provider_release_affiliation_owner_id(provider);
 			}
-			provider->private_data->affiliation_owner_id = g_strdup(owner_id);
-			provider->private_data->affiliation_id = g_strdup(affiliation_id);
+			lasso_provider_set_affiliation_owner_id(provider, owner_id);
+			lasso_provider_set_affiliation_id(provider, affiliation_id);
 			xmlFree(member_id);
 		}
 	}
diff --git a/lasso/utils.h b/lasso/utils.h
index dc7e0597..5021276d 100644
--- a/lasso/utils.h
+++ b/lasso/utils.h
@@ -731,6 +731,10 @@ inline static gboolean
 lasso_xmlstrisnotequal(const xmlChar *a, const xmlChar *b) {
 	return lasso_strisnotequal((char*)a, (char*)b);
 }
+inline static gboolean
+lasso_strstartswith(const char *str, const char *needle) {
+	return strncmp(str, needle, strlen(needle)) == 0;
+}
 
 /**
  * lasso_crypto_memequal:
diff --git a/lasso/xml/dsig/ds_key_value.c b/lasso/xml/dsig/ds_key_value.c
index 3333e06f..0bcdde2e 100644
--- a/lasso/xml/dsig/ds_key_value.c
+++ b/lasso/xml/dsig/ds_key_value.c
@@ -30,14 +30,11 @@
  *
  */
 
-struct _LassoDsKeyValuePrivate {
+typedef struct {
 	LassoDsX509Data *X509Data;
-};
-
-typedef struct _LassoDsKeyValuePrivate LassoDsKeyValuePrivate;
+} LassoDsKeyValuePrivate;
 
-#define LASSO_DS_KEY_VALUE_GET_PRIVATE(o) \
-	   (G_TYPE_INSTANCE_GET_PRIVATE ((o), LASSO_TYPE_DS_KEY_VALUE, LassoDsKeyValuePrivate))
+G_DEFINE_TYPE_WITH_PRIVATE(LassoDsKeyValue, lasso_ds_key_value, LASSO_TYPE_NODE);
 
 /*****************************************************************************/
 /* private methods                                                           */
@@ -55,7 +52,7 @@ static struct XmlSnippet schema_snippets[] = {
 
 
 static void
-class_init(LassoDsKeyValueClass *klass, void *unused G_GNUC_UNUSED)
+lasso_ds_key_value_class_init(LassoDsKeyValueClass *klass)
 {
 	LassoNodeClass *nclass = LASSO_NODE_CLASS(klass);
 
@@ -63,33 +60,11 @@ class_init(LassoDsKeyValueClass *klass, void *unused G_GNUC_UNUSED)
 	lasso_node_class_set_nodename(nclass, "KeyValue");
 	lasso_node_class_set_ns(nclass, LASSO_DS_HREF, LASSO_DS_PREFIX);
 	lasso_node_class_add_snippets(nclass, schema_snippets);
-	g_type_class_add_private(klass, sizeof(LassoDsKeyValuePrivate));
 }
 
-GType
-lasso_ds_key_value_get_type()
-{
-	static GType this_type = 0;
-
-	if (!this_type) {
-		static const GTypeInfo this_info = {
-			sizeof (LassoDsKeyValueClass),
-			NULL,
-			NULL,
-			(GClassInitFunc) class_init,
-			NULL,
-			NULL,
-			sizeof(LassoDsKeyValue),
-			0,
-			NULL,
-			NULL
-		};
-
-		this_type = g_type_register_static(LASSO_TYPE_NODE,
-				"LassoDsKeyValue", &this_info, 0);
-	}
-	return this_type;
-}
+static void
+lasso_ds_key_value_init(LassoDsKeyValue* self)
+{}
 
 /**
  * lasso_ds_key_value_new:
@@ -116,7 +91,9 @@ lasso_ds_key_value_get_x509_data(LassoDsKeyValue *key_value)
 {
 	lasso_return_val_if_fail(LASSO_IS_DS_KEY_VALUE(key_value), NULL);
 
-	return LASSO_DS_KEY_VALUE_GET_PRIVATE(key_value)->X509Data;
+	LassoDsKeyValuePrivate *private_data =
+		lasso_ds_key_value_get_instance_private(key_value);
+	return private_data->X509Data;
 }
 
 /**
@@ -130,5 +107,7 @@ lasso_ds_key_value_set_x509_data(LassoDsKeyValue *key_value, LassoDsX509Data *x5
 {
 	lasso_return_if_fail(LASSO_IS_DS_KEY_VALUE(key_value));
 
-	lasso_assign_gobject(LASSO_DS_KEY_VALUE_GET_PRIVATE(key_value)->X509Data, x509_data);
+	LassoDsKeyValuePrivate *private_data =
+		lasso_ds_key_value_get_instance_private(key_value);
+	lasso_assign_gobject(private_data->X509Data, x509_data);
 }
diff --git a/lasso/xml/dsig/ds_x509_data.c b/lasso/xml/dsig/ds_x509_data.c
index 9ee612b9..12ed8d86 100644
--- a/lasso/xml/dsig/ds_x509_data.c
+++ b/lasso/xml/dsig/ds_x509_data.c
@@ -35,8 +35,9 @@ struct _LassoDsX509DataPrivate {
 	char *X509SubjectName;
 	char *X509CRL;
 };
-#define LASSO_DS_X509_DATA_GET_PRIVATE(o) \
-	   (G_TYPE_INSTANCE_GET_PRIVATE ((o), LASSO_TYPE_DS_X509_DATA, LassoDsX509DataPrivate))
+
+G_DEFINE_TYPE_WITH_PRIVATE(LassoDsX509Data, lasso_ds_x509_data, LASSO_TYPE_NODE);
+
 
 /*****************************************************************************/
 /* private methods                                                           */
@@ -59,13 +60,7 @@ static LassoNodeClass *parent_class = NULL;
 /*****************************************************************************/
 
 static void
-instance_init(LassoDsX509Data *x509_data, G_GNUC_UNUSED void *unused)
-{
-	x509_data->private_data = LASSO_DS_X509_DATA_GET_PRIVATE(x509_data);
-}
-
-static void
-class_init(LassoDsX509DataClass *klass, void *unused G_GNUC_UNUSED)
+lasso_ds_x509_data_class_init(LassoDsX509DataClass *klass)
 {
 	LassoNodeClass *nclass = LASSO_NODE_CLASS(klass);
 
@@ -74,32 +69,16 @@ class_init(LassoDsX509DataClass *klass, void *unused G_GNUC_UNUSED)
 	lasso_node_class_set_nodename(nclass, "X509Data");
 	lasso_node_class_set_ns(nclass, LASSO_DS_HREF, LASSO_DS_PREFIX);
 	lasso_node_class_add_snippets(nclass, schema_snippets);
-	g_type_class_add_private(klass, sizeof(LassoDsX509DataPrivate));
 }
 
-GType
-lasso_ds_x509_data_get_type()
+static void
+lasso_ds_x509_data_init(LassoDsX509Data *ds_x509_data)
 {
-	static GType this_type = 0;
-
-	if (!this_type) {
-		static const GTypeInfo this_info = {
-			sizeof (LassoDsX509DataClass),
-			NULL,
-			NULL,
-			(GClassInitFunc) class_init,
-			NULL,
-			NULL,
-			sizeof(LassoDsX509Data),
-			0,
-			(GInstanceInitFunc)instance_init,
-			NULL
-		};
-
-		this_type = g_type_register_static(LASSO_TYPE_NODE,
-				"LassoDsX509Data", &this_info, 0);
-	}
-	return this_type;
+#pragma GCC diagnostic push
+#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
+	ds_x509_data->private_data =
+		lasso_ds_x509_data_get_instance_private(ds_x509_data);
+#pragma GCC diagnostic pop
 }
 
 /**
@@ -127,7 +106,9 @@ lasso_ds_x509_data_new()
 const char*
 lasso_ds_x509_data_get_certificate(LassoDsX509Data *x509_data) {
 	lasso_return_val_if_fail(LASSO_IS_DS_X509_DATA(x509_data), NULL);
-	return x509_data->private_data->X509Certificate;
+	LassoDsX509DataPrivate *private_data =
+		lasso_ds_x509_data_get_instance_private(x509_data);
+	return private_data->X509Certificate;
 }
 
 /**
@@ -141,7 +122,8 @@ lasso_ds_x509_data_get_certificate(LassoDsX509Data *x509_data) {
 void
 lasso_ds_x509_data_set_certificate(LassoDsX509Data *x509_data, const char *certificate) {
 	lasso_return_if_fail(LASSO_IS_DS_X509_DATA(x509_data));
-	lasso_assign_string(x509_data->private_data->X509Certificate, certificate);
+	LassoDsX509DataPrivate *private_data = lasso_ds_x509_data_get_instance_private(x509_data);
+	lasso_assign_string(private_data->X509Certificate, certificate);
 }
 
 /**
@@ -156,7 +138,9 @@ lasso_ds_x509_data_set_certificate(LassoDsX509Data *x509_data, const char *certi
 const char*
 lasso_ds_x509_data_get_subject_name(LassoDsX509Data *x509_data) {
 	lasso_return_val_if_fail(LASSO_IS_DS_X509_DATA(x509_data), NULL);
-	return x509_data->private_data->X509SubjectName;
+	LassoDsX509DataPrivate *private_data =
+		lasso_ds_x509_data_get_instance_private(x509_data);
+	return private_data->X509SubjectName;
 }
 
 /**
@@ -170,7 +154,9 @@ lasso_ds_x509_data_get_subject_name(LassoDsX509Data *x509_data) {
 void
 lasso_ds_x509_data_set_subject_name(LassoDsX509Data *x509_data, const char *subject_name) {
 	lasso_return_if_fail(LASSO_IS_DS_X509_DATA(x509_data));
-	lasso_assign_string(x509_data->private_data->X509SubjectName, subject_name);
+	LassoDsX509DataPrivate *private_data =
+		lasso_ds_x509_data_get_instance_private(x509_data);
+	lasso_assign_string(private_data->X509SubjectName, subject_name);
 }
 
 /**
@@ -185,7 +171,8 @@ lasso_ds_x509_data_set_subject_name(LassoDsX509Data *x509_data, const char *subj
 const char*
 lasso_ds_x509_data_get_crl(LassoDsX509Data *x509_data) {
 	lasso_return_val_if_fail(LASSO_IS_DS_X509_DATA(x509_data), NULL);
-	return x509_data->private_data->X509CRL;
+	LassoDsX509DataPrivate *private_data = lasso_ds_x509_data_get_instance_private(x509_data);
+	return private_data->X509CRL;
 }
 
 /**
@@ -199,5 +186,6 @@ lasso_ds_x509_data_get_crl(LassoDsX509Data *x509_data) {
 void
 lasso_ds_x509_data_set_crl(LassoDsX509Data *x509_data, const char *crl) {
 	lasso_return_if_fail(LASSO_IS_DS_X509_DATA(x509_data));
-	lasso_assign_string(x509_data->private_data->X509CRL, crl);
+	LassoDsX509DataPrivate *private_data = lasso_ds_x509_data_get_instance_private(x509_data);
+	lasso_assign_string(private_data->X509CRL, crl);
 }
diff --git a/lasso/xml/dsig/ds_x509_data.h b/lasso/xml/dsig/ds_x509_data.h
index 1ff34fb4..2888952a 100644
--- a/lasso/xml/dsig/ds_x509_data.h
+++ b/lasso/xml/dsig/ds_x509_data.h
@@ -52,7 +52,7 @@ typedef struct _LassoDsX509DataPrivate LassoDsX509DataPrivate;
 struct _LassoDsX509Data {
 	LassoNode parent;
 	/*< private >*/
-	LassoDsX509DataPrivate *private_data;
+	LassoDsX509DataPrivate *private_data __attribute__ ((deprecated));
 };
 
 struct _LassoDsX509DataClass {
diff --git a/lasso/xml/lib_logout_request.c b/lasso/xml/lib_logout_request.c
index c2fdd3ae..245144db 100644
--- a/lasso/xml/lib_logout_request.c
+++ b/lasso/xml/lib_logout_request.c
@@ -59,13 +59,12 @@
 /* private methods                                                           */
 /*****************************************************************************/
 
-#define LASSO_LIB_LOGOUT_REQUEST_GET_PRIVATE(o) \
-	   (G_TYPE_INSTANCE_GET_PRIVATE ((o), LASSO_TYPE_LIB_LOGOUT_REQUEST, \
-					 struct _LassoLibLogoutRequestPrivate))
-
-struct _LassoLibLogoutRequestPrivate {
+typedef struct {
 	GList *SessionIndex;
-};
+} LassoLibLogoutRequestPrivate;
+
+G_DEFINE_TYPE_WITH_PRIVATE(LassoLibLogoutRequest, lasso_lib_logout_request,
+		LASSO_TYPE_SAMLP_REQUEST_ABSTRACT);
 
 static struct XmlSnippet schema_snippets[] = {
 	{ "Extension", SNIPPET_EXTENSION, G_STRUCT_OFFSET(LassoLibLogoutRequest, Extension), NULL, NULL, NULL},
@@ -73,8 +72,8 @@ static struct XmlSnippet schema_snippets[] = {
 	{ "NameIdentifier", SNIPPET_NODE, G_STRUCT_OFFSET(LassoLibLogoutRequest, NameIdentifier),
 		NULL, LASSO_SAML_ASSERTION_PREFIX, LASSO_SAML_ASSERTION_HREF},
 	{ "SessionIndex", SNIPPET_CONTENT, G_STRUCT_OFFSET(LassoLibLogoutRequest, SessionIndex), NULL, NULL, NULL},
-	{ "SessionIndex", SNIPPET_LIST_CONTENT|SNIPPET_PRIVATE, G_STRUCT_OFFSET(struct
-			_LassoLibLogoutRequestPrivate, SessionIndex), NULL, NULL, NULL},
+	{ "SessionIndex", SNIPPET_LIST_CONTENT|SNIPPET_PRIVATE, G_STRUCT_OFFSET(
+			LassoLibLogoutRequestPrivate, SessionIndex), NULL, NULL, NULL},
 	{ "RelayState", SNIPPET_CONTENT, G_STRUCT_OFFSET(LassoLibLogoutRequest, RelayState), NULL, NULL, NULL},
 	{ "consent", SNIPPET_ATTRIBUTE, G_STRUCT_OFFSET(LassoLibLogoutRequest, consent), NULL, NULL, NULL},
 	{ "NotOnOrAfter", SNIPPET_ATTRIBUTE,
@@ -134,7 +133,7 @@ cleanup:
 
 
 static void
-class_init(LassoLibLogoutRequestClass *klass, void *unused G_GNUC_UNUSED)
+lasso_lib_logout_request_class_init(LassoLibLogoutRequestClass *klass)
 {
 	LassoNodeClass *nclass = LASSO_NODE_CLASS(klass);
 
@@ -145,33 +144,11 @@ class_init(LassoLibLogoutRequestClass *klass, void *unused G_GNUC_UNUSED)
 	lasso_node_class_set_ns(nclass, LASSO_LIB_HREF, LASSO_LIB_PREFIX);
 	lasso_node_class_add_snippets(nclass, schema_snippets);
 	lasso_node_class_add_query_snippets(nclass, query_snippets);
-	g_type_class_add_private(nclass, sizeof(struct _LassoLibLogoutRequestPrivate));
 }
 
-GType
-lasso_lib_logout_request_get_type()
-{
-	static GType this_type = 0;
-
-	if (!this_type) {
-		static const GTypeInfo this_info = {
-			sizeof (LassoLibLogoutRequestClass),
-			NULL,
-			NULL,
-			(GClassInitFunc) class_init,
-			NULL,
-			NULL,
-			sizeof(LassoLibLogoutRequest),
-			0,
-			NULL,
-			NULL
-		};
-
-		this_type = g_type_register_static(LASSO_TYPE_SAMLP_REQUEST_ABSTRACT,
-				"LassoLibLogoutRequest", &this_info, 0);
-	}
-	return this_type;
-}
+static void
+lasso_lib_logout_request_init(LassoLibLogoutRequest *self)
+{}
 
 /**
  * lasso_lib_logout_request_new:
@@ -231,11 +208,11 @@ lasso_lib_logout_request_set_session_indexes(LassoLibLogoutRequest *lib_logout_r
 		GList *session_indexes)
 {
 	char *first = NULL;
-	struct _LassoLibLogoutRequestPrivate *private_data;
+	LassoLibLogoutRequestPrivate *private_data;
 
 	if (! LASSO_IS_LIB_LOGOUT_REQUEST(lib_logout_request))
 		return;
-	private_data = LASSO_LIB_LOGOUT_REQUEST_GET_PRIVATE(lib_logout_request);
+	private_data = lasso_lib_logout_request_get_instance_private(lib_logout_request);
 	if (session_indexes) {
 		first = session_indexes->data;
 		session_indexes = g_list_next(session_indexes);
@@ -256,13 +233,13 @@ lasso_lib_logout_request_set_session_indexes(LassoLibLogoutRequest *lib_logout_r
 GList*
 lasso_lib_logout_request_get_session_indexes(LassoLibLogoutRequest *lib_logout_request)
 {
-	struct _LassoLibLogoutRequestPrivate *private_data;
+	LassoLibLogoutRequestPrivate *private_data;
 	GList *ret = NULL;
 	GList *i = NULL;
 
 	if (! LASSO_IS_LIB_LOGOUT_REQUEST(lib_logout_request))
 		return NULL;
-	private_data = LASSO_LIB_LOGOUT_REQUEST_GET_PRIVATE(lib_logout_request);
+	private_data = lasso_lib_logout_request_get_instance_private(lib_logout_request);
 	if (lib_logout_request->SessionIndex) {
 		lasso_list_add_string(ret, lib_logout_request->SessionIndex);
 	}
diff --git a/lasso/xml/misc_text_node.c b/lasso/xml/misc_text_node.c
index 59d98c5c..15a0a898 100644
--- a/lasso/xml/misc_text_node.c
+++ b/lasso/xml/misc_text_node.c
@@ -35,8 +35,8 @@ typedef struct {
 	GHashTable *any_attributes;
 } LassoMiscTextNodePrivate;
 
-#define LASSO_MISC_TEXT_NODE_GET_PRIVATE(o) \
-	   (G_TYPE_INSTANCE_GET_PRIVATE ((o), LASSO_TYPE_MISC_TEXT_NODE, LassoMiscTextNodePrivate))
+G_DEFINE_TYPE_WITH_PRIVATE(LassoMiscTextNode, lasso_misc_text_node, LASSO_TYPE_NODE);
+
 
 static struct XmlSnippet schema_snippets[] = {
 	{ "content", SNIPPET_TEXT_CHILD,
@@ -56,7 +56,7 @@ get_xmlNode(LassoNode *node, gboolean lasso_dump)
 	LassoMiscTextNode *mtnode = (LassoMiscTextNode*)node;
 	LassoMiscTextNodePrivate *private;
 
-	private = LASSO_MISC_TEXT_NODE_GET_PRIVATE(node);
+	private = lasso_misc_text_node_get_instance_private(LASSO_MISC_TEXT_NODE(node));
 	if (private->xml_content) {
 		return xmlCopyNode(private->xml_content, 1);
 	}
@@ -110,7 +110,7 @@ finalize(GObject *object)
 	LassoMiscTextNode *t = LASSO_MISC_TEXT_NODE(object);
 	LassoMiscTextNodePrivate *private;
 
-	private = LASSO_MISC_TEXT_NODE_GET_PRIVATE(object);
+	private = lasso_misc_text_node_get_instance_private(LASSO_MISC_TEXT_NODE(object));
 	lasso_release_xml_node(private->xml_content);
 	lasso_release_string(t->name);
 	lasso_release_string(t->ns_href);
@@ -124,9 +124,8 @@ finalize(GObject *object)
 /* instance and class init functions                                         */
 /*****************************************************************************/
 
-
 static void
-class_init(LassoMiscTextNodeClass *klass, void *unused G_GNUC_UNUSED)
+lasso_misc_text_node_class_init(LassoMiscTextNodeClass *klass)
 {
 	LassoNodeClass *nclass = LASSO_NODE_CLASS(klass);
 
@@ -139,33 +138,12 @@ class_init(LassoMiscTextNodeClass *klass, void *unused G_GNUC_UNUSED)
 
 	lasso_node_class_set_nodename(nclass, "XXX");
 	lasso_node_class_add_snippets(nclass, schema_snippets);
-	g_type_class_add_private(klass, sizeof(LassoMiscTextNodePrivate));
 }
 
-GType
-lasso_misc_text_node_get_type()
-{
-	static GType this_type = 0;
-
-	if (!this_type) {
-		static const GTypeInfo this_info = {
-			sizeof (LassoMiscTextNodeClass),
-			NULL,
-			NULL,
-			(GClassInitFunc) class_init,
-			NULL,
-			NULL,
-			sizeof(LassoMiscTextNode),
-			0,
-			NULL,
-			NULL
-		};
-
-		this_type = g_type_register_static(LASSO_TYPE_NODE,
-				"LassoMiscTextNode", &this_info, 0);
-	}
-	return this_type;
-}
+static void
+lasso_misc_text_node_init(LassoMiscTextNode *name G_GNUC_UNUSED )
+{}
+
 
 /**
  * lasso_misc_text_node_get_xml_content:
@@ -180,7 +158,7 @@ lasso_misc_text_node_get_xml_content(LassoMiscTextNode *misc_text_node)
 {
 	LassoMiscTextNodePrivate *private_data;
 
-	private_data = LASSO_MISC_TEXT_NODE_GET_PRIVATE(misc_text_node);
+	private_data = lasso_misc_text_node_get_instance_private(misc_text_node);
 	return private_data->xml_content;
 }
 
@@ -195,7 +173,7 @@ lasso_misc_text_node_set_xml_content(LassoMiscTextNode *misc_text_node, xmlNode
 {
 	LassoMiscTextNodePrivate *private_data;
 
-	private_data = LASSO_MISC_TEXT_NODE_GET_PRIVATE(misc_text_node);
+	private_data = lasso_misc_text_node_get_instance_private(misc_text_node);
 	lasso_assign_xml_node(private_data->xml_content, node);
 }
 
@@ -212,7 +190,6 @@ lasso_misc_text_node_new()
 	return g_object_new(LASSO_TYPE_MISC_TEXT_NODE, NULL);
 }
 
-
 /**
  * lasso_misc_text_node_new_with_string:
  * @content: the content of newly created #LassoMiscTextNode
diff --git a/lasso/xml/private.h b/lasso/xml/private.h
index 84810d8d..8f09fa0a 100644
--- a/lasso/xml/private.h
+++ b/lasso/xml/private.h
@@ -354,6 +354,10 @@ gchar* lasso_xmlnode_build_deflated_query(xmlNode *xmlnode);
 
 xmlTextReader *lasso_xmltextreader_from_message(const char *message, char **to_free);
 
+void lasso_set_default_signature_method(LassoSignatureMethod meth);
+void lasso_set_min_signature_method(LassoSignatureMethod meth);
+
+
 #ifdef __cplusplus
 }
 #endif /* __cplusplus */
diff --git a/lasso/xml/saml-2.0/saml2_attribute_value.c b/lasso/xml/saml-2.0/saml2_attribute_value.c
index c8a588c0..c41f0e05 100644
--- a/lasso/xml/saml-2.0/saml2_attribute_value.c
+++ b/lasso/xml/saml-2.0/saml2_attribute_value.c
@@ -46,15 +46,17 @@
 /* private methods                                                           */
 /*****************************************************************************/
 
-struct _LassoSaml2AttributeValuePrivate {
+typedef struct {
 	GHashTable *any_attributes;
-};
+} LassoSaml2AttributeValuePrivate;
+
+G_DEFINE_TYPE_WITH_PRIVATE(LassoSaml2AttributeValue, lasso_saml2_attribute_value, LASSO_TYPE_NODE);
 
 static struct XmlSnippet schema_snippets[] = {
 	{ "any", SNIPPET_LIST_NODES | SNIPPET_ANY | SNIPPET_ALLOW_TEXT,
 		G_STRUCT_OFFSET(LassoSaml2AttributeValue, any), NULL, NULL, NULL},
 	{ "any_attributes", SNIPPET_ATTRIBUTE | SNIPPET_ANY | SNIPPET_PRIVATE,
-		G_STRUCT_OFFSET(struct _LassoSaml2AttributeValuePrivate, any_attributes), NULL,
+		G_STRUCT_OFFSET(LassoSaml2AttributeValuePrivate, any_attributes), NULL,
 		NULL, NULL },
 	{NULL, 0, 0, NULL, NULL, NULL}
 };
@@ -81,7 +83,7 @@ get_xmlNode(LassoNode *node, gboolean lasso_dump)
 }
 
 static void
-class_init(LassoSaml2AttributeValueClass *klass, void *unused G_GNUC_UNUSED)
+lasso_saml2_attribute_value_class_init(LassoSaml2AttributeValueClass *klass)
 {
 	LassoNodeClass *nclass = LASSO_NODE_CLASS(klass);
 
@@ -91,34 +93,11 @@ class_init(LassoSaml2AttributeValueClass *klass, void *unused G_GNUC_UNUSED)
 	lasso_node_class_set_nodename(nclass, "AttributeValue");
 	lasso_node_class_set_ns(nclass, LASSO_SAML2_ASSERTION_HREF, LASSO_SAML2_ASSERTION_PREFIX);
 	lasso_node_class_add_snippets(nclass, schema_snippets);
-	g_type_class_add_private(klass, sizeof(struct _LassoSaml2AttributeValuePrivate));
 }
 
-GType
-lasso_saml2_attribute_value_get_type()
-{
-	static GType this_type = 0;
-
-	if (!this_type) {
-		static const GTypeInfo this_info = {
-			sizeof (LassoSaml2AttributeValueClass),
-			NULL,
-			NULL,
-			(GClassInitFunc) class_init,
-			NULL,
-			NULL,
-			sizeof(LassoSaml2AttributeValue),
-			0,
-			NULL,
-			NULL
-		};
-
-		this_type = g_type_register_static(LASSO_TYPE_NODE,
-				"LassoSaml2AttributeValue",
-				&this_info, 0);
-	}
-	return this_type;
-}
+static void
+lasso_saml2_attribute_value_init(LassoSaml2AttributeValue *attr_value)
+{}
 
 LassoSaml2AttributeValue*
 lasso_saml2_attribute_value_new()
diff --git a/lasso/xml/saml-2.0/saml2_key_info_confirmation_data_type.c b/lasso/xml/saml-2.0/saml2_key_info_confirmation_data_type.c
index 8ba3d72e..cddcd55d 100644
--- a/lasso/xml/saml-2.0/saml2_key_info_confirmation_data_type.c
+++ b/lasso/xml/saml-2.0/saml2_key_info_confirmation_data_type.c
@@ -61,6 +61,8 @@ struct _LassoSaml2KeyInfoConfirmationDataTypePrivate {
 	GList *KeyInfo;
 };
 
+G_DEFINE_TYPE_WITH_PRIVATE(LassoSaml2KeyInfoConfirmationDataType, lasso_saml2_key_info_confirmation_data_type, LASSO_TYPE_SAML2_SUBJECT_CONFIRMATION_DATA);
+
 static struct XmlSnippet schema_snippets[] = {
 	{ "KeyInfo", SNIPPET_LIST_NODES|SNIPPET_PRIVATE,
 		G_STRUCT_OFFSET(LassoSaml2KeyInfoConfirmationDataTypePrivate, KeyInfo),
@@ -70,23 +72,20 @@ static struct XmlSnippet schema_snippets[] = {
 
 static LassoNodeClass *parent_class = NULL;
 
-#define LASSO_SAML2_KEY_INFO_CONFIRMATION_DATA_TYPE_GET_PRIVATE(o) \
-	   (G_TYPE_INSTANCE_GET_PRIVATE ((o), LASSO_TYPE_SAML2_KEY_INFO_CONFIRMATION_DATA_TYPE, LassoSaml2KeyInfoConfirmationDataTypePrivate))
-
 /*****************************************************************************/
 /* instance and class init functions                                         */
 /*****************************************************************************/
 
 static void
-instance_init(LassoSaml2KeyInfoConfirmationDataType *saml2_key_info_confirmation_data_type, G_GNUC_UNUSED void *unused)
+lasso_saml2_key_info_confirmation_data_type_init(LassoSaml2KeyInfoConfirmationDataType *saml2_key_info_confirmation_data_type)
 {
 	saml2_key_info_confirmation_data_type->private_data =
-		LASSO_SAML2_KEY_INFO_CONFIRMATION_DATA_TYPE_GET_PRIVATE(
+		lasso_saml2_key_info_confirmation_data_type_get_instance_private(
 				saml2_key_info_confirmation_data_type);
 }
 
 static void
-class_init(LassoSaml2KeyInfoConfirmationDataTypeClass *klass, void *unused G_GNUC_UNUSED)
+lasso_saml2_key_info_confirmation_data_type_class_init(LassoSaml2KeyInfoConfirmationDataTypeClass *klass)
 {
 	LassoNodeClass *nclass = LASSO_NODE_CLASS(klass);
 
@@ -96,9 +95,9 @@ class_init(LassoSaml2KeyInfoConfirmationDataTypeClass *klass, void *unused G_GNU
 	lasso_node_class_set_nodename(nclass, "KeyInfoConfirmationDataType");
 	lasso_node_class_set_ns(nclass, LASSO_SAML2_ASSERTION_HREF, LASSO_SAML2_ASSERTION_PREFIX);
 	lasso_node_class_add_snippets(nclass, schema_snippets);
-	g_type_class_add_private(klass, sizeof(LassoSaml2KeyInfoConfirmationDataTypePrivate));
 }
 
+/*
 GType
 lasso_saml2_key_info_confirmation_data_type_get_type()
 {
@@ -126,6 +125,7 @@ lasso_saml2_key_info_confirmation_data_type_get_type()
 	}
 	return this_type;
 }
+*/
 
 /**
  * lasso_saml2_key_info_confirmation_data_type_new:
diff --git a/lasso/xml/saml-2.0/saml2_subject_confirmation_data.c b/lasso/xml/saml-2.0/saml2_subject_confirmation_data.c
index d6caa670..9fc94fb6 100644
--- a/lasso/xml/saml-2.0/saml2_subject_confirmation_data.c
+++ b/lasso/xml/saml-2.0/saml2_subject_confirmation_data.c
@@ -50,10 +50,13 @@
  * </figure>
  */
 
-struct _LassoSaml2SubjectConfirmationDataPrivate {
+typedef struct {
 	GList *any;
 	GHashTable *attributes;
-};
+} LassoSaml2SubjectConfirmationDataPrivate;
+
+G_DEFINE_TYPE_WITH_PRIVATE(LassoSaml2SubjectConfirmationData,
+		lasso_saml2_subject_confirmation_data, LASSO_TYPE_NODE);
 
 /*****************************************************************************/
 /* private methods                                                           */
@@ -72,9 +75,9 @@ static struct XmlSnippet schema_snippets[] = {
 	{ "Address", SNIPPET_ATTRIBUTE,
 		G_STRUCT_OFFSET(LassoSaml2SubjectConfirmationData, Address), NULL, NULL, NULL},
 	{ "", SNIPPET_LIST_NODES | SNIPPET_ANY | SNIPPET_PRIVATE,
-		G_STRUCT_OFFSET(struct _LassoSaml2SubjectConfirmationDataPrivate, any), NULL, NULL, NULL},
+		G_STRUCT_OFFSET(LassoSaml2SubjectConfirmationDataPrivate, any), NULL, NULL, NULL},
 	{ "", SNIPPET_ATTRIBUTE | SNIPPET_ANY | SNIPPET_PRIVATE,
-		G_STRUCT_OFFSET(struct _LassoSaml2SubjectConfirmationDataPrivate, attributes), NULL, NULL, NULL},
+		G_STRUCT_OFFSET(LassoSaml2SubjectConfirmationDataPrivate, attributes), NULL, NULL, NULL},
 	{NULL, 0, 0, NULL, NULL, NULL}
 };
 
@@ -87,7 +90,7 @@ static LassoNodeClass *parent_class = NULL;
 
 
 static void
-class_init(LassoSaml2SubjectConfirmationDataClass *klass, void *unused G_GNUC_UNUSED)
+lasso_saml2_subject_confirmation_data_class_init(LassoSaml2SubjectConfirmationDataClass *klass)
 {
 	LassoNodeClass *nclass = LASSO_NODE_CLASS(klass);
 
@@ -96,33 +99,11 @@ class_init(LassoSaml2SubjectConfirmationDataClass *klass, void *unused G_GNUC_UN
 	lasso_node_class_set_nodename(nclass, "SubjectConfirmationData");
 	lasso_node_class_set_ns(nclass, LASSO_SAML2_ASSERTION_HREF, LASSO_SAML2_ASSERTION_PREFIX);
 	lasso_node_class_add_snippets(nclass, schema_snippets);
-	g_type_class_add_private(klass, sizeof(struct _LassoSaml2SubjectConfirmationDataPrivate));
 }
 
-GType
-lasso_saml2_subject_confirmation_data_get_type()
-{
-	static GType this_type = 0;
-
-	if (!this_type) {
-		static const GTypeInfo this_info = {
-			sizeof (LassoSaml2SubjectConfirmationDataClass),
-			NULL,
-			NULL,
-			(GClassInitFunc) class_init,
-			NULL,
-			NULL,
-			sizeof(LassoSaml2SubjectConfirmationData),
-			0,
-			NULL,
-			NULL
-		};
-
-		this_type = g_type_register_static(LASSO_TYPE_NODE,
-				"LassoSaml2SubjectConfirmationData", &this_info, 0);
-	}
-	return this_type;
-}
+static void
+lasso_saml2_subject_confirmation_data_init(LassoSaml2SubjectConfirmationData *unused G_GNUC_UNUSED)
+{}
 
 /**
  * lasso_saml2_subject_confirmation_data_new:
diff --git a/lasso/xml/saml-2.0/samlp2_extensions.c b/lasso/xml/saml-2.0/samlp2_extensions.c
index d8e1402e..2def566e 100644
--- a/lasso/xml/saml-2.0/samlp2_extensions.c
+++ b/lasso/xml/saml-2.0/samlp2_extensions.c
@@ -45,12 +45,13 @@
  *
  */
 
-typedef struct _LassoSamlp2ExtensionsPrivate LassoSamlp2ExtensionsPrivate;
 
-struct _LassoSamlp2ExtensionsPrivate {
+typedef struct {
 	GList *any;
 	GHashTable *attributes;
-};
+} LassoSamlp2ExtensionsPrivate;
+
+G_DEFINE_TYPE_WITH_PRIVATE(LassoSamlp2Extensions, lasso_samlp2_extensions, LASSO_TYPE_NODE);
 
 /*****************************************************************************/
 /* private methods                                                           */
@@ -67,15 +68,13 @@ static struct XmlSnippet schema_snippets[] = {
 
 static LassoNodeClass *parent_class = NULL;
 
-#define GET_PRIVATE(x) G_TYPE_INSTANCE_GET_PRIVATE(x, \
-		LASSO_TYPE_SAMLP2_EXTENSIONS, LassoSamlp2ExtensionsPrivate)
 
 /*****************************************************************************/
 /* instance and class init functions                                         */
 /*****************************************************************************/
 
 static void
-class_init(LassoSamlp2ExtensionsClass *klass, void *unused G_GNUC_UNUSED)
+lasso_samlp2_extensions_class_init(LassoSamlp2ExtensionsClass *klass)
 {
 	LassoNodeClass *nclass = LASSO_NODE_CLASS(klass);
 
@@ -85,33 +84,11 @@ class_init(LassoSamlp2ExtensionsClass *klass, void *unused G_GNUC_UNUSED)
 	lasso_node_class_set_nodename(nclass, "Extensions");
 	lasso_node_class_set_ns(nclass, LASSO_SAML2_PROTOCOL_HREF, LASSO_SAML2_PROTOCOL_PREFIX);
 	lasso_node_class_add_snippets(nclass, schema_snippets);
-	g_type_class_add_private(G_OBJECT_CLASS(klass), sizeof(LassoSamlp2ExtensionsPrivate));
 }
 
-GType
-lasso_samlp2_extensions_get_type()
-{
-	static GType this_type = 0;
-
-	if (!this_type) {
-		static const GTypeInfo this_info = {
-			sizeof (LassoSamlp2ExtensionsClass),
-			NULL,
-			NULL,
-			(GClassInitFunc) class_init,
-			NULL,
-			NULL,
-			sizeof(LassoSamlp2Extensions),
-			0,
-			NULL,
-			NULL
-		};
-
-		this_type = g_type_register_static(LASSO_TYPE_NODE,
-				"LassoSamlp2Extensions", &this_info, 0);
-	}
-	return this_type;
-}
+void
+lasso_samlp2_extensions_init(LassoSamlp2Extensions *self)
+{}
 
 /**
  * lasso_samlp2_extensions_new:
@@ -138,7 +115,7 @@ lasso_samlp2_extensions_get_any(LassoSamlp2Extensions *extensions)
 {
 	LassoSamlp2ExtensionsPrivate *pv = NULL;
 
-	pv = GET_PRIVATE(extensions);
+	pv = lasso_samlp2_extensions_get_instance_private(extensions);
 
 	return pv->any;
 }
@@ -155,7 +132,7 @@ lasso_samlp2_extensions_set_any(LassoSamlp2Extensions *extensions, GList *any)
 {
 	LassoSamlp2ExtensionsPrivate *pv = NULL;
 
-	pv = GET_PRIVATE(extensions);
+	pv = lasso_samlp2_extensions_get_instance_private(extensions);
 
 	lasso_assign_list_of_xml_node(pv->any, any);
 }
@@ -172,7 +149,7 @@ lasso_samlp2_extensions_get_attributes(LassoSamlp2Extensions *extensions)
 {
 	LassoSamlp2ExtensionsPrivate *pv = NULL;
 
-	pv = GET_PRIVATE(extensions);
+	pv = lasso_samlp2_extensions_get_instance_private(extensions);
 
 	return pv->attributes;
 }
@@ -188,7 +165,7 @@ lasso_samlp2_extensions_set_attributes(LassoSamlp2Extensions *extensions, GHashT
 {
 	LassoSamlp2ExtensionsPrivate *pv = NULL;
 
-	pv = GET_PRIVATE(extensions);
+	pv = lasso_samlp2_extensions_get_instance_private(extensions);
 
 	lasso_assign_table_of_attributes(pv->attributes, attributes);
 }
diff --git a/lasso/xml/saml-2.0/samlp2_logout_request.c b/lasso/xml/saml-2.0/samlp2_logout_request.c
index bb0c9d6e..305facd2 100644
--- a/lasso/xml/saml-2.0/samlp2_logout_request.c
+++ b/lasso/xml/saml-2.0/samlp2_logout_request.c
@@ -54,11 +54,12 @@
  * </figure>
  */
 
-typedef struct _LassoSamlp2LogoutRequestPrivate LassoSamlp2LogoutRequestPrivate;
-
-struct _LassoSamlp2LogoutRequestPrivate {
+typedef struct {
 	GList *SessionIndex;
-};
+} LassoSamlp2LogoutRequestPrivate;
+
+G_DEFINE_TYPE_WITH_PRIVATE(LassoSamlp2LogoutRequest, lasso_samlp2_logout_request,
+		LASSO_TYPE_SAMLP2_REQUEST_ABSTRACT);
 
 /*****************************************************************************/
 /* private methods                                                           */
@@ -87,16 +88,13 @@ static LassoNodeClass *parent_class = NULL;
 
 #define SESSION_INDEX "SessionIndex"
 
-#define GET_PRIVATE(x) G_TYPE_INSTANCE_GET_PRIVATE(x, \
-		LASSO_TYPE_SAMLP2_LOGOUT_REQUEST, LassoSamlp2LogoutRequestPrivate)
-
 static void
 dispose(GObject *object)
 {
 	LassoSamlp2LogoutRequest *logout_request = LASSO_SAMLP2_LOGOUT_REQUEST(object);
 	LassoSamlp2LogoutRequestPrivate *pv;
 
-	pv = GET_PRIVATE(logout_request);
+	pv = lasso_samlp2_logout_request_get_instance_private(logout_request);
 	lasso_release_list_of_strings(pv->SessionIndex);
 	G_OBJECT_CLASS(parent_class)->dispose(G_OBJECT(logout_request));
 }
@@ -128,14 +126,10 @@ get_xmlNode(LassoNode *node, gboolean lasso_dump)
 	lasso_foreach(it, other_session_index) {
 		xmlNode *child = xmlSecAddChild(xmlnode, BAD_CAST SESSION_INDEX,
 				BAD_CAST LASSO_SAML2_PROTOCOL_HREF);
-#if (XMLSEC_MAJOR > 1) || (XMLSEC_MAJOR == 1 && XMLSEC_MINOR > 2) || (XMLSEC_MAJOR == 1 && XMLSEC_MINOR == 2 && XMLSEC_SUBMINOR > 12)
-		xmlSecNodeEncodeAndSetContent(child, BAD_CAST it->data);
-#else
 		xmlChar *content;
 		content = xmlEncodeSpecialChars(child->doc, BAD_CAST it->data);
 		xmlNodeSetContent(child, content);
 		xmlFree(content);
-#endif
 	}
 	((LassoSamlp2LogoutRequest*)node)->SessionIndex = keep_session_index;
 	lasso_release_list_of_strings(other_session_index);
@@ -161,7 +155,8 @@ init_from_xml(LassoNode *node, xmlNode *xmlnode)
 
 	if (rc == 0) {
 
-		pv = GET_PRIVATE(node);
+		pv = lasso_samlp2_logout_request_get_instance_private(
+				LASSO_SAMLP2_LOGOUT_REQUEST(node));
 		child = xmlSecFindChild(xmlnode, BAD_CAST SESSION_INDEX,
 				BAD_CAST LASSO_SAML2_PROTOCOL_HREF);
 		while (child && xmlSecCheckNodeName(child, BAD_CAST SESSION_INDEX,
@@ -182,7 +177,7 @@ init_from_xml(LassoNode *node, xmlNode *xmlnode)
 }
 
 static void
-class_init(LassoSamlp2LogoutRequestClass *klass, void *unused G_GNUC_UNUSED)
+lasso_samlp2_logout_request_class_init(LassoSamlp2LogoutRequestClass *klass)
 {
 	LassoNodeClass *nclass = LASSO_NODE_CLASS(klass);
 
@@ -193,34 +188,12 @@ class_init(LassoSamlp2LogoutRequestClass *klass, void *unused G_GNUC_UNUSED)
 	lasso_node_class_set_nodename(nclass, "LogoutRequest");
 	lasso_node_class_set_ns(nclass, LASSO_SAML2_PROTOCOL_HREF, LASSO_SAML2_PROTOCOL_PREFIX);
 	lasso_node_class_add_snippets(nclass, schema_snippets);
-	g_type_class_add_private(G_OBJECT_CLASS(klass), sizeof(LassoSamlp2LogoutRequestPrivate));
 	G_OBJECT_CLASS(klass)->dispose = dispose;
 }
 
-GType
-lasso_samlp2_logout_request_get_type()
-{
-	static GType this_type = 0;
-
-	if (!this_type) {
-		static const GTypeInfo this_info = {
-			sizeof (LassoSamlp2LogoutRequestClass),
-			NULL,
-			NULL,
-			(GClassInitFunc) class_init,
-			NULL,
-			NULL,
-			sizeof(LassoSamlp2LogoutRequest),
-			0,
-			NULL,
-			NULL
-		};
-
-		this_type = g_type_register_static(LASSO_TYPE_SAMLP2_REQUEST_ABSTRACT,
-				"LassoSamlp2LogoutRequest", &this_info, 0);
-	}
-	return this_type;
-}
+static void
+lasso_samlp2_logout_request_init(LassoSamlp2LogoutRequest* self)
+{}
 
 /**
  * lasso_samlp2_logout_request_get_session_indexes:
@@ -240,7 +213,7 @@ lasso_samlp2_logout_request_get_session_indexes(LassoSamlp2LogoutRequest *logout
 	g_return_val_if_fail(LASSO_IS_SAMLP2_LOGOUT_REQUEST(logout_request), NULL);
 
 	/* Return concatenation of old field + new private field */
-	pv = GET_PRIVATE(logout_request);
+	pv = lasso_samlp2_logout_request_get_instance_private(logout_request);
 	lasso_assign_list_of_strings(ret, pv->SessionIndex);
 	if (logout_request->SessionIndex) {
 		ret = g_list_prepend(ret, g_strdup(logout_request->SessionIndex));
@@ -267,7 +240,7 @@ lasso_samlp2_logout_request_set_session_indexes(LassoSamlp2LogoutRequest *logout
 	g_return_if_fail(LASSO_IS_SAMLP2_LOGOUT_REQUEST(logout_request));
 
 	/* assign rest of the list to the new private field */
-	pv = GET_PRIVATE(logout_request);
+	pv = lasso_samlp2_logout_request_get_instance_private(logout_request);
 	if (! session_index) {
 		lasso_release_string(logout_request->SessionIndex);
 		lasso_release_list_of_strings(pv->SessionIndex);
diff --git a/lasso/xml/saml_attribute_value.c b/lasso/xml/saml_attribute_value.c
index 8d9dd0bc..6f5ff79d 100644
--- a/lasso/xml/saml_attribute_value.c
+++ b/lasso/xml/saml_attribute_value.c
@@ -52,7 +52,7 @@
 /*****************************************************************************/
 
 static struct XmlSnippet schema_snippets[] = {
-	{ "", SNIPPET_LIST_NODES | SNIPPET_ALLOW_TEXT,
+	{ "any", SNIPPET_LIST_NODES | SNIPPET_ANY | SNIPPET_ALLOW_TEXT,
 		G_STRUCT_OFFSET(LassoSamlAttributeValue, any), NULL, NULL, NULL},
 	{NULL, 0, 0, NULL, NULL, NULL}
 };
diff --git a/lasso/xml/tools.c b/lasso/xml/tools.c
index 385858d1..7284a583 100644
--- a/lasso/xml/tools.c
+++ b/lasso/xml/tools.c
@@ -47,6 +47,7 @@
 #include <libxml/xmlIO.h>
 
 #include <openssl/evp.h>
+#include <openssl/pem.h>
 
 #include <xmlsec/base64.h>
 #include <xmlsec/crypto.h>
@@ -63,6 +64,7 @@
 #include <glib.h>
 #include "xml.h"
 #include "xml_enc.h"
+#include "../id-ff/server.h"
 #include "saml-2.0/saml2_assertion.h"
 #include <unistd.h>
 #include "../debug.h"
@@ -308,8 +310,13 @@ xmlSecKeyPtr lasso_get_public_key_from_pem_file(const char *file) {
 			pub_key = lasso_get_public_key_from_pem_cert_file(file);
 			break;
 		case LASSO_PEM_FILE_TYPE_PUB_KEY:
+#if LASSO_XMLSEC_VERSION_NUMBER >= 0x010300
+			pub_key = xmlSecCryptoAppKeyLoadEx(file, xmlSecKeyDataTypePublic | xmlSecKeyDataTypePrivate,
+					xmlSecKeyDataFormatPem, NULL, NULL, NULL);
+#else
 			pub_key = xmlSecCryptoAppKeyLoad(file,
 					xmlSecKeyDataFormatPem, NULL, NULL, NULL);
+#endif
 			break;
 		case LASSO_PEM_FILE_TYPE_PRIVATE_KEY:
 			pub_key = lasso_get_public_key_from_private_key_file(file);
@@ -377,8 +384,13 @@ lasso_get_public_key_from_pem_cert_file(const char *pem_cert_file)
 static xmlSecKeyPtr
 lasso_get_public_key_from_private_key_file(const char *private_key_file)
 {
+#if LASSO_XMLSEC_VERSION_NUMBER >= 0x010300
+	return xmlSecCryptoAppKeyLoadEx(private_key_file, xmlSecKeyDataTypePrivate | xmlSecKeyDataTypePublic,
+			xmlSecKeyDataFormatPem, NULL, NULL, NULL);
+#else
 	return xmlSecCryptoAppKeyLoad(private_key_file,
 			xmlSecKeyDataFormatPem, NULL, NULL, NULL);
+#endif
 }
 
 /**
@@ -1027,12 +1039,12 @@ lasso_saml2_query_verify_signature(const char *query, xmlSecKey *sender_public_k
 		goto_cleanup_with_rc(LASSO_PROFILE_ERROR_INVALID_QUERY);
 	}
 
-	if (! sig_alg) {
-		goto_cleanup_with_rc(LASSO_DS_ERROR_INVALID_SIGALG);
-	}
 	if (! b64_signature) {
 		goto_cleanup_with_rc(LASSO_DS_ERROR_SIGNATURE_NOT_FOUND);
 	}
+	if (! sig_alg) {
+		goto_cleanup_with_rc(LASSO_DS_ERROR_INVALID_SIGALG);
+	}
 	/* build the signed query */
 	if (relaystate) {
 		signed_query = g_strconcat(saml_request_response, "&", relaystate, "&", sig_alg, NULL);
@@ -1249,9 +1261,9 @@ cleanup:
 	if (doc) {
 		xmlRemoveID(doc, id_attr);
 		xmlUnlinkNode(xmlnode);
-		lasso_release_doc(doc);
 		xmlnode->parent = old_parent;
 		xmlSetTreeDoc(xmlnode, NULL);
+		lasso_release_doc(doc);
 	}
 	lasso_release_signature_context(dsig_ctx);
 	return rc;
@@ -1449,7 +1461,14 @@ lasso_concat_url_query(const char *url, const char *query)
 	}
 }
 
-static void structuredErrorFunc (void *userData, xmlErrorPtr error) {
+static void structuredErrorFunc (void *userData,
+#if LIBXML_VERSION >= 21200
+                                        const xmlError *error
+#else
+                                        xmlErrorPtr error
+#endif
+				 )
+{
 		*(int*)userData = error->code;
 }
 
@@ -2542,7 +2561,7 @@ lasso_base64_decode(const char *from, char **buffer, int *buffer_len)
 	xmlSecErrorsDefaultCallbackEnableOutput(TRUE);
 	if (ret == 0) {
 		out[outlen - 1] = 0;
-		lasso_transfer_string(*buffer, *((char**)&out));
+		lasso_transfer_string(*(xmlChar**)buffer, out);
 		*buffer_len = decodedlen;
 	} else {
 		rc = FALSE;
@@ -2554,7 +2573,7 @@ lasso_base64_decode(const char *from, char **buffer, int *buffer_len)
 
 	if (ret >= 0) {
 		out[outlen - 1] = 0;
-		lasso_transfer_string(*buffer, *((char**)&out));
+		lasso_transfer_string(*(xmlChar**)buffer, out);
 		*buffer_len = ret;
 	} else {
 		rc = FALSE;
@@ -2696,7 +2715,7 @@ cleanup:
 xmlSecKeyPtr
 lasso_xmlsec_load_key_info(xmlNode *key_descriptor)
 {
-	xmlSecKeyPtr key, result = NULL;
+	xmlSecKeyPtr key = NULL, result = NULL;
 	xmlNodePtr key_info = NULL;
 	xmlSecKeyInfoCtx ctx = {0};
 	xmlSecKeysMngr *keys_mngr = NULL;
@@ -2730,6 +2749,17 @@ lasso_xmlsec_load_key_info(xmlNode *key_descriptor)
 	ctx.keyReq.keyUsage = xmlSecKeyDataUsageAny;
 	ctx.certsVerificationDepth = 0;
 
+	if((xmlSecPtrListAdd(&ctx.enabledKeyData, BAD_CAST xmlSecKeyDataX509Id) < 0) ||
+		(xmlSecPtrListAdd(&ctx.enabledKeyData, BAD_CAST xmlSecKeyDataValueId) < 0) ||
+		(xmlSecPtrListAdd(&ctx.enabledKeyData, BAD_CAST xmlSecKeyDataRsaId) < 0) ||
+		(xmlSecPtrListAdd(&ctx.enabledKeyData, BAD_CAST xmlSecKeyDataDsaId) < 0) ||
+		(xmlSecPtrListAdd(&ctx.enabledKeyData, BAD_CAST xmlSecKeyDataHmacId) < 0)) {
+		message(G_LOG_LEVEL_CRITICAL, "Could not enable needed KeyData");
+		goto next;
+	}
+
+
+
 	key = xmlSecKeyCreate();
 	if (lasso_flag_pem_public_key) {
 		xmlSecErrorsDefaultCallbackEnableOutput(FALSE);
@@ -3126,7 +3156,7 @@ lasso_xmlnode_add_saml2_signature_template(xmlNode *node, LassoSignatureContext
 				break;
 			case LASSO_SIGNATURE_METHOD_RSA_SHA512:
 			case LASSO_SIGNATURE_METHOD_HMAC_SHA512:
-				digest_method_id = xmlSecTransformSha384Id;
+				digest_method_id = xmlSecTransformSha512Id;
 				break;
 			default:
 				g_assert_not_reached();
@@ -3226,6 +3256,17 @@ cleanup:
 	return saml_message;
 }
 
+static gboolean
+lasso_is_redirect_message(const char *message) {
+	if (lasso_strstartswith(message, LASSO_SAML2_FIELD_REQUEST "=") || lasso_strstartswith(message, LASSO_SAML2_FIELD_RESPONSE "=")) {
+		return TRUE;
+	}
+	if (strstr(message, "&" LASSO_SAML2_FIELD_REQUEST "=") || strstr(message, "&" LASSO_SAML2_FIELD_RESPONSE "=")) {
+		return TRUE;
+	}
+	return FALSE;
+}
+
 /**
  * lasso_xmltextreader_from_message:
  * @message: the HTTP query, POST content or SOAP message
@@ -3235,7 +3276,6 @@ cleanup:
 xmlTextReader *
 lasso_xmltextreader_from_message(const char *message, char **to_free) {
 	size_t len = strlen(message);
-	char *needle;
 	xmlChar **query_fields = NULL;
 	char *decoded_message = NULL;
 	int decoded_message_len = 0;
@@ -3244,9 +3284,8 @@ lasso_xmltextreader_from_message(const char *message, char **to_free) {
 	g_assert(to_free);
 	/* Differentiate SOAP from others */
 	if (message[0] != '<') {
-		needle = strchr(message, '=');
 		/* Differentiate redirect binding from POST */
-		if (needle && message[len-1] != '=') {
+		if (lasso_is_redirect_message(message)) {
 			query_fields = lasso_urlencoded_to_strings(message);
 			message = *to_free = lasso_get_saml_message(query_fields);
 			if (! message) {
diff --git a/lasso/xml/xml.c b/lasso/xml/xml.c
index 0d5c6e31..adf0ba99 100644
--- a/lasso/xml/xml.c
+++ b/lasso/xml/xml.c
@@ -44,6 +44,7 @@
 #include <xmlsec/openssl/crypto.h>
 #include <xmlsec/openssl/x509.h>
 
+#include <config.h>
 #include "xml.h"
 #include "xml_enc.h"
 #include "saml_name_identifier.h"
@@ -358,7 +359,7 @@ lasso_node_export_to_query_with_password(LassoNode *node,
  *
  * Exports @node to an xml message.
  *
- * Return value: an xml export of @node.  The string must be freed by the
+ * Return value:(transfer full): an xml export of @node.  The string must be freed by the
  *      caller.
  **/
 gchar*
@@ -620,6 +621,12 @@ lasso_node_encrypt(LassoNode *lasso_node, xmlSecKey *encryption_public_key,
 		goto cleanup;
 	}
 
+#if LASSO_XMLSEC_VERSION_NUMBER >= 0x010300
+	enc_ctx->keyInfoWriteCtx.flags |= XMLSEC_KEYINFO_FLAGS_LAX_KEY_SEARCH;
+	enc_ctx->keyInfoReadCtx.flags |= XMLSEC_KEYINFO_FLAGS_LAX_KEY_SEARCH;
+	enc_ctx->keyInfoReadCtx.flags |= XMLSEC_KEYINFO_FLAGS_LAX_KEY_SEARCH;
+#endif
+
 	/* generate a symetric key */
 	switch (encryption_sym_key_type) {
 		case LASSO_ENCRYPTION_SYM_KEY_TYPE_AES_256:
diff --git a/lasso/xml/xml.h b/lasso/xml/xml.h
index 27273693..ddc96d9a 100644
--- a/lasso/xml/xml.h
+++ b/lasso/xml/xml.h
@@ -117,35 +117,6 @@ typedef enum {
 	LASSO_SIGNATURE_METHOD_LAST
 } LassoSignatureMethod;
 
-/* signature method and hash strength */
-LassoSignatureMethod lasso_get_default_signature_method();
-
-void lasso_set_default_signature_method(LassoSignatureMethod meth);
-
-LassoSignatureMethod lasso_get_min_signature_method();
-
-void lasso_set_min_signature_method(LassoSignatureMethod meth);
-
-static inline gboolean
-lasso_validate_signature_method(LassoSignatureMethod signature_method)
-{
-	return signature_method > (LassoSignatureMethod)LASSO_SIGNATURE_TYPE_NONE \
-		&& signature_method < (LassoSignatureMethod)LASSO_SIGNATURE_METHOD_LAST;
-}
-
-static inline gboolean
-lasso_allowed_signature_method(LassoSignatureMethod signature_method)
-{
-	return signature_method >= lasso_get_min_signature_method();
-}
-
-static inline gboolean
-lasso_ok_signature_method(LassoSignatureMethod signature_method)
-{
-	return lasso_validate_signature_method(signature_method) \
-	    && lasso_allowed_signature_method(signature_method);
-}
-
 typedef struct _LassoNode LassoNode;
 typedef struct _LassoNodeClass LassoNodeClass;
 typedef struct _LassoNodeClassData LassoNodeClassData;
@@ -242,6 +213,32 @@ LASSO_EXPORT LassoKeyEncryptionMethod lasso_get_default_key_encryption_method();
 
 LASSO_EXPORT void lasso_set_default_key_encryption_method(LassoKeyEncryptionMethod method);
 
+/* signature method and hash strength */
+LASSO_EXPORT LassoSignatureMethod lasso_get_default_signature_method();
+LASSO_EXPORT LassoSignatureMethod lasso_get_min_signature_method();
+
+void lasso_set_min_signature_method(LassoSignatureMethod meth);
+
+static inline gboolean
+lasso_validate_signature_method(LassoSignatureMethod signature_method)
+{
+	return signature_method > (LassoSignatureMethod)LASSO_SIGNATURE_TYPE_NONE \
+		&& signature_method < (LassoSignatureMethod)LASSO_SIGNATURE_METHOD_LAST;
+}
+
+static inline gboolean
+lasso_allowed_signature_method(LassoSignatureMethod signature_method)
+{
+	return signature_method >= lasso_get_min_signature_method();
+}
+
+static inline gboolean
+lasso_ok_signature_method(LassoSignatureMethod signature_method)
+{
+	return lasso_validate_signature_method(signature_method) \
+	    && lasso_allowed_signature_method(signature_method);
+}
+
 #ifdef __cplusplus
 }
 #endif /* __cplusplus */
diff --git a/tests/basic_tests.c b/tests/basic_tests.c
index eaea4c51..65d60b90 100644
--- a/tests/basic_tests.c
+++ b/tests/basic_tests.c
@@ -196,6 +196,53 @@ START_TEST(test09_test_deserialization)
 }
 END_TEST
 
+START_TEST(test09_1_test_new_from_soap_saml1)
+{
+	char *content = NULL;
+	size_t len = 0;
+	LassoSamlpResponse *response;
+	LassoSamlAssertion *assertion;
+	GList *attrs;
+	const char *expt_values[] = {
+		"12345",
+		"\n              uugid=middleware.staff,ou=Groups,dc=vt,dc=edu\n            ",
+		"staff",
+		"ACTIVE"
+	};
+
+	g_file_get_contents(TESTSDATADIR "/response-5", &content, &len, NULL);
+
+	ck_assert_msg(content != NULL, "content should be read");
+	response = (LassoSamlpResponse*)lasso_node_new_from_soap(content);
+	ck_assert_msg(response != NULL, "node should be parsed");
+	ck_assert_msg(g_list_length(response->Assertion) == 1,
+			"Sample contains only 1 Assertion");
+
+	assertion = LASSO_SAML_ASSERTION(response->Assertion->data);
+	attrs = assertion->AttributeStatement->Attribute;
+	ck_assert_msg(g_list_length(attrs) == 4,
+			"Sample contains only 4 Attributes");
+
+	for(int i=0; i<4; i++)
+	{
+		void *data = g_list_nth(attrs, i)->data;
+		LassoSamlAttribute *attr = LASSO_SAML_ATTRIBUTE(data);
+		ck_assert_msg(g_list_length(attr->AttributeValue) == 1,
+				"Attribute contains only 1 AttributeValue");
+		LassoSamlAttributeValue *val = attr->AttributeValue->data;
+		ck_assert_msg(g_list_length(val->any) == 1,
+				"AttributeValue must have only 1 child");
+		LassoMiscTextNode *txt = LASSO_MISC_TEXT_NODE(val->any->data);
+		ck_assert_msg(strcmp(txt->content, expt_values[i]) == 0,
+				"AttributeValue text node do not match expected \
+'%s' != '%s'",
+				txt->content, expt_values[i]);
+	}
+
+	g_object_unref(response);
+	g_free(content);
+}
+
 /* try to test all new functions and their associated deserialization codes */
 START_TEST(test10_test_alldumps)
 {
@@ -1041,6 +1088,22 @@ START_TEST(test16_test_get_issuer)
 }
 END_TEST
 
+START_TEST(test17_test_get_issuer_leading_equal)
+{
+
+	const char *query[2] = {
+		"SAMLRequest=fVHJasMwEP0Vo3tqRXY2YRvcOIFAl9CUHnopwpkkAllyNeMuf1%2FZaSG95PrmLfNmMlSNaWXZ0ck%2BwXsHSNFXYyzKYZCzzlvpFGqUVjWAkmq5K%2B%2FvpLjhsvWOXO0Mu5BcVyhE8KSdZdGmytnbNEmTBV%2Bli9ulKMt5KlbVfDkbizWfcVEmUxa9gMfAz1mQBxFiBxuLpCwFiIvxiE9H48mz4FJMZJq8sqgKHbRVNKhORK2MY71vJzFqezSw00f7GPLXztcw9M7ZQRmE3n0bFtQf8IcUWV9JDqm%2B%2BPXCYNUAqb0ilcWXhOx8zIdQe1NtndH1dx%2FTKLp%2BlR7R%2B9FhoMq2b4wEllhUGuM%2Blx4UhZ3Id8Di4pz5%2F2fFDw%3D%3D&RelayState=fake&SigAlg=http%3A%2F%2Fwww.w3.org%2F2001%2F04%2Fxmldsig-more%23rsa-sha256&Signature=Zfz3DE1VMV3thaV4FWpH0fkWsBMzAFJcfvVWAbo0a3cY48Et%2BXUcbr1nvOJUJmhGoie0pQ4%2BcD9ToQlSk7BbJSBCct%2FQQgn2QNkX%2F1lk4v8RU8p5ptJRJ2iPLb8nC6WZhs81HoihQePSuj7Qe5bRUsDKvnWMq6OkD%2Fe6YO77dMXregTcfmnkrXqRb2T6TFfqyOz9i0%2FjmISsmj%2F3kEEfUzVA4LEbeEgiJDj1hec4XW26gQTih53v0sYukq4Eyb4zS2jVd3apUUxUrjn1NUpr7Z7dZ7w5MQlgZ8aw1xFDE8BkxymvIjwf8ciyx6sfTKbCRsoS9E0pQB1vxvh6OMt1Ww%3D%3D",
+		"SAMLRequest=fVHJasMwEP0Vo3tqRXY2YRvcOIFAl9CUHnopwpkkAllyNeMuf1%2FZaSG95PrmLfNmMlSNaWXZ0ck%2BwXsHSNFXYyzKYZCzzlvpFGqUVjWAkmq5K%2B%2FvpLjhsvWOXO0Mu5BcVyhE8KSdZdGmytnbNEmTBV%2Bli9ulKMt5KlbVfDkbizWfcVEmUxa9gMfAz1mQBxFiBxuLpCwFiIvxiE9H48mz4FJMZJq8sqgKHbRVNKhORK2MY71vJzFqezSw00f7GPLXztcw9M7ZQRmE3n0bFtQf8IcUWV9JDqm%2B%2BPXCYNUAqb0ilcWXhOx8zIdQe1NtndH1dx%2FTKLp%2BlR7R%2B9FhoMq2b4wEllhUGuM%2Blx4UhZ3Id8Di4pz5%2F2fFDw%3D%3D&RelayState="};
+
+	for(int i=0; i<2; i++)
+	{
+		char *issuer = lasso_profile_get_issuer(query[i]);
+		ck_assert_msg(issuer, "Null issuer returned for query[%d]", i);
+		ck_assert_msg(!strcmp(issuer, "http://sp5/metadata"), "Wrong issuer fetched '%s' for query[%d]", issuer, i);
+	}
+}
+END_TEST
+
 Suite*
 basic_suite()
 {
@@ -1088,12 +1151,14 @@ basic_suite()
 	tcase_add_test(tc_registry_functional_mapping, test07_registry_functional_mapping);
 	tcase_add_test(tc_registry_new_from_xmlNode, test08_test_new_from_xmlNode);
 	tcase_add_test(tc_response_new_from_xmlNode, test09_test_deserialization);
+	tcase_add_test(tc_response_new_from_xmlNode, test09_1_test_new_from_soap_saml1);
 	tcase_add_test(tc_all_dumps, test10_test_alldumps);
 	tcase_add_test(tc_get_default_name_id_format, test11_get_default_name_id_format);
 	tcase_add_test(tc_load_metadata, test13_test_lasso_server_load_metadata);
 	tcase_add_test(tc_key, test14_lasso_key);
 	tcase_add_test(tc_key_info, test15_ds_key_info);
 	tcase_add_test(tc_get_issuer, test16_test_get_issuer);
+	tcase_add_test(tc_get_issuer, test17_test_get_issuer_leading_equal);
 	tcase_set_timeout(tc_load_metadata, 10);
 	return s;
 }
diff --git a/tests/data/Makefile.am b/tests/data/Makefile.am
index 2e442f01..a8788d94 100644
--- a/tests/data/Makefile.am
+++ b/tests/data/Makefile.am
@@ -13,7 +13,7 @@ EXTRA_DIST = \
 	lecp2-la lecp2-ssl lecp3-la \
 	lecp3-ssl lecp4-la lecp4-ssl \
 	metadata requests response-1 \
-	response-2 response-3 response-4 \
+	response-2 response-3 response-4 response-5 \
 	sample-identity-dump-1.xml sourceid-2.0beta sp10-512-saml2 \
 	sp11-multikey-saml2 sp1-la sp1-ssl \
 	sp2-la sp2-ssl sp3-la \
diff --git a/tests/data/response-5 b/tests/data/response-5
new file mode 100644
index 00000000..1b9419e4
--- /dev/null
+++ b/tests/data/response-5
@@ -0,0 +1,65 @@
+<!--
+	Example SAML 1.1 validation response
+        from https://github.com/apereo/cas/blob/master/docs/cas-server-documentation/protocol/CAS-Protocol-Specification.md
+-->
+<SOAP-ENV:Envelope xmlns:SOAP-ENV="http://schemas.xmlsoap.org/soap/envelope/">
+  <SOAP-ENV:Header />
+  <SOAP-ENV:Body>
+    <Response xmlns="urn:oasis:names:tc:SAML:1.0:protocol" xmlns:saml="urn:oasis:names:tc:SAML:1.0:assertion"
+    xmlns:samlp="urn:oasis:names:tc:SAML:1.0:protocol" xmlns:xsd="http://www.w3.org/2001/XMLSchema"
+    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" IssueInstant="2008-12-10T14:12:14.817Z"
+    MajorVersion="1" MinorVersion="1" Recipient="https://eiger.iad.vt.edu/dat/home.do"
+    ResponseID="_5c94b5431c540365e5a70b2874b75996">
+      <Status>
+        <StatusCode Value="samlp:Success">
+        </StatusCode>
+      </Status>
+      <Assertion xmlns="urn:oasis:names:tc:SAML:1.0:assertion" AssertionID="_e5c23ff7a3889e12fa01802a47331653"
+      IssueInstant="2008-12-10T14:12:14.817Z" Issuer="localhost" MajorVersion="1"
+      MinorVersion="1">
+        <Conditions NotBefore="2008-12-10T14:12:14.817Z" NotOnOrAfter="2008-12-10T14:12:44.817Z">
+          <AudienceRestrictionCondition>
+            <Audience>
+              https://some-service.example.com/app/
+            </Audience>
+          </AudienceRestrictionCondition>
+        </Conditions>
+        <AttributeStatement>
+          <Subject>
+            <NameIdentifier>johnq</NameIdentifier>
+            <SubjectConfirmation>
+              <ConfirmationMethod>
+                urn:oasis:names:tc:SAML:1.0:cm:artifact
+              </ConfirmationMethod>
+            </SubjectConfirmation>
+          </Subject>
+          <Attribute AttributeName="uid" AttributeNamespace="http://www.ja-sig.org/products/cas/">
+            <AttributeValue>12345</AttributeValue>
+          </Attribute>
+          <Attribute AttributeName="groupMembership" AttributeNamespace="http://www.ja-sig.org/products/cas/">
+            <AttributeValue>
+              uugid=middleware.staff,ou=Groups,dc=vt,dc=edu
+            </AttributeValue>
+          </Attribute>
+          <Attribute AttributeName="eduPersonAffiliation" AttributeNamespace="http://www.ja-sig.org/products/cas/">
+            <AttributeValue>staff</AttributeValue>
+          </Attribute>
+          <Attribute AttributeName="accountState" AttributeNamespace="http://www.ja-sig.org/products/cas/">
+            <AttributeValue>ACTIVE</AttributeValue>
+          </Attribute>
+        </AttributeStatement>
+        <AuthenticationStatement AuthenticationInstant="2008-12-10T14:12:14.741Z"
+        AuthenticationMethod="urn:oasis:names:tc:SAML:1.0:am:password">
+          <Subject>
+            <NameIdentifier>johnq</NameIdentifier>
+            <SubjectConfirmation>
+              <ConfirmationMethod>
+                urn:oasis:names:tc:SAML:1.0:cm:artifact
+              </ConfirmationMethod>
+            </SubjectConfirmation>
+          </Subject>
+        </AuthenticationStatement>
+      </Assertion>
+    </Response>
+  </SOAP-ENV:Body>
+</SOAP-ENV:Envelope>
diff --git a/tests/login_tests_saml2.c b/tests/login_tests_saml2.c
index 9b4caa5a..3b146cff 100644
--- a/tests/login_tests_saml2.c
+++ b/tests/login_tests_saml2.c
@@ -1581,7 +1581,7 @@ START_TEST(test12_ecp)
 }
 END_TEST
 
-void check_digest_method(G_GNUC_UNUSED LassoLogin *idp_login_context, LassoLogin *sp_login_context)
+void check_sha256_digest_method(G_GNUC_UNUSED LassoLogin *idp_login_context, LassoLogin *sp_login_context)
 {
 	char *dump = lasso_node_debug((LassoNode*)sp_login_context->parent.response, 10);
 	check_true(strstr(dump, "<DigestMethod Algorithm=\"http://www.w3.org/2001/04/xmlenc#sha256\"/>") != NULL);
@@ -1604,7 +1604,7 @@ START_TEST(test13_sso_sp_with_rsa_sha256_signatures)
 	test07_make_context(sp_context, "sp6-saml2", LASSO_PROVIDER_ROLE_IDP, "idp6-saml2", key)
 
 	block_lasso_logs;
-	sso_initiated_by_sp(idp_context, sp_context, check_digest_method);
+	sso_initiated_by_sp(idp_context, sp_context, check_sha256_digest_method);
 	unblock_lasso_logs;
 
 	/* Cleanup */
@@ -1614,6 +1614,40 @@ START_TEST(test13_sso_sp_with_rsa_sha256_signatures)
 }
 END_TEST
 
+void check_sha512_digest_method(G_GNUC_UNUSED LassoLogin *idp_login_context, LassoLogin *sp_login_context)
+{
+	char *dump = lasso_node_debug((LassoNode*)sp_login_context->parent.response, 10);
+	check_true(strstr(dump, "<DigestMethod Algorithm=\"http://www.w3.org/2001/04/xmlenc#sha512\"/>") != NULL);
+	lasso_release_string(dump)
+}
+
+START_TEST(test14_sso_sp_with_rsa_sha512_signatures)
+{
+	LassoServer *idp_context = NULL;
+	LassoServer *sp_context = NULL;
+	GList *providers;
+	LassoKey *key = NULL;
+
+	/* Create a key for signature algorithm RSA_SHA256 */
+	key = lasso_key_new_for_signature_from_file(TESTSDATADIR "idp6-saml2/private-key.pem", NULL,
+			LASSO_SIGNATURE_METHOD_RSA_SHA512, NULL);
+	check_true(LASSO_IS_KEY(key));
+
+	test07_make_context(idp_context, "idp6-saml2", LASSO_PROVIDER_ROLE_SP, "sp6-saml2", key)
+	test07_make_context(sp_context, "sp6-saml2", LASSO_PROVIDER_ROLE_IDP, "idp6-saml2", key)
+
+	block_lasso_logs;
+	sso_initiated_by_sp(idp_context, sp_context, check_sha512_digest_method);
+	unblock_lasso_logs;
+
+	/* Cleanup */
+	lasso_release_gobject(idp_context);
+	lasso_release_gobject(sp_context);
+	lasso_release_gobject(key);
+}
+END_TEST
+
+
 Suite*
 login_saml2_suite()
 {
@@ -1647,6 +1681,7 @@ login_saml2_suite()
 	tcase_add_test(tc_ecp, test11_ecp);
 	tcase_add_test(tc_ecp, test12_ecp);
 	tcase_add_test(tc_spLogin, test13_sso_sp_with_rsa_sha256_signatures);
+	tcase_add_test(tc_spLogin, test14_sso_sp_with_rsa_sha512_signatures);
 	return s;
 }
 
diff --git a/tests/random_tests.c b/tests/random_tests.c
index ff60e73b..532989b5 100644
--- a/tests/random_tests.c
+++ b/tests/random_tests.c
@@ -292,6 +292,8 @@ START_TEST(test07_saml2_query_verify_signature)
 	 * changed to ; */
 	const char query2[] = "Signature=Zfz3DE1VMV3thaV4FWpH0fkWsBMzAFJcfvVWAbo0a3cY48Et%2BXUcbr1nvOJUJmhGoie0pQ4%2BcD9ToQlSk7BbJSBCct%2FQQgn2QNkX%2F1lk4v8RU8p5ptJRJ2iPLb8nC6WZhs81HoihQePSuj7Qe5bRUsDKvnWMq6OkD%2Fe6YO77dMXregTcfmnkrXqRb2T6TFfqyOz9i0%2FjmISsmj%2F3kEEfUzVA4LEbeEgiJDj1hec4XW26gQTih53v0sYukq4Eyb4zS2jVd3apUUxUrjn1NUpr7Z7dZ7w5MQlgZ8aw1xFDE8BkxymvIjwf8ciyx6sfTKbCRsoS9E0pQB1vxvh6OMt1Ww%3D%3D;SAMLRequest=fVHJasMwEP0Vo3tqRXY2YRvcOIFAl9CUHnopwpkkAllyNeMuf1%2FZaSG95PrmLfNmMlSNaWXZ0ck%2BwXsHSNFXYyzKYZCzzlvpFGqUVjWAkmq5K%2B%2FvpLjhsvWOXO0Mu5BcVyhE8KSdZdGmytnbNEmTBV%2Bli9ulKMt5KlbVfDkbizWfcVEmUxa9gMfAz1mQBxFiBxuLpCwFiIvxiE9H48mz4FJMZJq8sqgKHbRVNKhORK2MY71vJzFqezSw00f7GPLXztcw9M7ZQRmE3n0bFtQf8IcUWV9JDqm%2B%2BPXCYNUAqb0ilcWXhOx8zIdQe1NtndH1dx%2FTKLp%2BlR7R%2B9FhoMq2b4wEllhUGuM%2Blx4UhZ3Id8Di4pz5%2F2fFDw%3D%3D;RelayState=fake;SigAlg=http%3A%2F%2Fwww.w3.org%2F2001%2F04%2Fxmldsig-more%23rsa-sha256";
 	const char query3[] = "SAMLRequest=fVHJasMwEP0Vo3tqRXY2YRvcOIFAl9CUHnopwpkkAllyNeMuf1%2FZaSG95PrmLfNmMlSNaWXZ0ck%2BwXsHSNFXYyzKYZCzzlvpFGqUVjWAkmq5K%2B%2FvpLjhsvWOXO0Mu5BcVyhE8KSdZdGmytnbNEmTBV%2Bli9ulKMt5KlbVfDkbizWfcVEmUxa9gMfAz1mQBxFiBxuLpCwFiIvxiE9H48mz4FJMZJq8sqgKHbRVNKhORK2MY71vJzFqezSw00f7GPLXztcw9M7ZQRmE3n0bFtQf8IcUWV9JDqm%2B%2BPXCYNUAqb0ilcWXhOx8zIdQe1NtndH1dx%2FTKLp%2BlR7R%2B9FhoMq2b4wEllhUGuM%2Blx4UhZ3Id8Di4pz5%2F2fFDw%3D%3D&RelayState=fake&SigAlg=http%3A%2F%2Fwww.w3.org%2F2001%2F04%2Fxmldsig-more%23rsa-sha256&Signature=rUJ%2B9wVSvdGSmZWGuGXgudAPV5KBxRfxRKraBWGIslBz2XreyNbQjSA47DhIfi%2Bxf0awIIGkKcieN3Qd5sqVn4wvFU8fsmfqrdtouYi46aKsj4W91N19TxJ%2BCgrP7ygVEGDaGdc%2BrCQC3%2FuoYTELXq0gYP7tHaXA%2FCaZHfx5Z159crpRxS6eabZ6BGf4ImxiKhE1FuYzKHeISEV1iSyvgx5%2FE8ydSO%2FSP6yA5Rck4JxVJWH6ImbswCVQ80qfqR4NoJ%2BxiZqilbDJnQaSKZggx%2FgjNVoX%2FMVW1FqEmgJNcZpSjNUQqy9u4veSllpxPc2aB%2FpiUjzpbq9XzyFDOQfkUQ%3D%3D";
+	/* Deleting SigAlg & Signature fields */
+	const char query4[] = "SAMLRequest=fVHJasMwEP0Vo3tqRXY2YRvcOIFAl9CUHnopwpkkAllyNeMuf1%2FZaSG95PrmLfNmMlSNaWXZ0ck%2BwXsHSNFXYyzKYZCzzlvpFGqUVjWAkmq5K%2B%2FvpLjhsvWOXO0Mu5BcVyhE8KSdZdGmytnbNEmTBV%2Bli9ulKMt5KlbVfDkbizWfcVEmUxa9gMfAz1mQBxFiBxuLpCwFiIvxiE9H48mz4FJMZJq8sqgKHbRVNKhORK2MY71vJzFqezSw00f7GPLXztcw9M7ZQRmE3n0bFtQf8IcUWV9JDqm%2B%2BPXCYNUAqb0ilcWXhOx8zIdQe1NtndH1dx%2FTKLp%2BlR7R%2B9FhoMq2b4wEllhUGuM%2Blx4UhZ3Id8Di4pz5%2F2fFDw%3D%3D&RelayState=fake";
 	/* sp5-saml2 key */
 	const char pkey[] = "-----BEGIN CERTIFICATE-----\n\
 MIIDnjCCAoagAwIBAgIBATANBgkqhkiG9w0BAQUFADBUMQswCQYDVQQGEwJGUjEP\n\
@@ -324,6 +326,11 @@ LlTxKnCrWAXftSm1rNtewTsF\n\
 	/* test reordering and semi-colon separator support */
 	ck_assert_msg(lasso_saml2_query_verify_signature(query2, key) == 0, "Disordered signature was not validated");
 	ck_assert_msg(lasso_saml2_query_verify_signature(query3, key) != 0, "Altered signature was validated");
+	/* test missing signature error code */
+	ck_assert_msg(lasso_saml2_query_verify_signature(query3, key) == LASSO_DS_ERROR_INVALID_SIGNATURE,
+			"Altered signature do not lead to invalid signature");
+	ck_assert_msg(lasso_saml2_query_verify_signature(query4, key) == LASSO_DS_ERROR_SIGNATURE_NOT_FOUND,
+			"Bad error code when missing signature");
 	xmlSecKeyDestroy(key);
 }
 END_TEST
diff --git a/tools/api.py b/tools/api.py
index aa03223a..1052e2bd 100644
--- a/tools/api.py
+++ b/tools/api.py
@@ -2,7 +2,6 @@ import sys
 import os.path
 sys.path.append(os.path.join(os.path.dirname(__file__),'../bindings'))
 import bindings
-from six import print_
 
 
 def main(args):
@@ -29,16 +28,16 @@ def main(args):
     l = sorted(d.keys())
     for x in l:
         if isinstance(d[x], bindings.Function):
-            print_(d[x].return_type, " ",)
-            print_(x, end='')
-            print_('(', ', '.join(map(lambda x: x[0] + ' ' + x[1], d[x].args)), ')')
+            print(d[x].return_type, " ",)
+            print(x, end='')
+            print('(', ', '.join(map(lambda x: x[0] + ' ' + x[1], d[x].args)), ')')
         elif isinstance(d[x], bindings.Struct):
-            print_('struct', x, '{ ',)
-            print_(', '.join(map(lambda x: x[0] + ' ' + x[1], d[x].members)),
+            print('struct', x, '{ ',)
+            print(', '.join(map(lambda x: x[0] + ' ' + x[1], d[x].members)),
                    end='')
-            print_(' }')
+            print(' }')
         else:
-            print_(x)
+            print(x)
 
 if __name__ == "__main__":
     main(sys.argv)
diff --git a/tools/check-lasso-sections.py b/tools/check-lasso-sections.py
index 34b0f715..391ff517 100755
--- a/tools/check-lasso-sections.py
+++ b/tools/check-lasso-sections.py
@@ -3,10 +3,9 @@
 import sys
 import os.path
 import re
-from six import print_
 
 if len(sys.argv) < 3:
-    print_("Usage: check-lasso-sections.py "
+    print("Usage: check-lasso-sections.py "
            "lasso docs/referenrece/lasso/lasso-sections.txt",
            file=sys.stderr)
     sys.exit(1)
@@ -34,13 +33,13 @@ for dirpath, dirnames, filenames in os.walk(source):
 
 lasso_sections_txt=file(lasso_sections_txt).read()
 
-print_(' = Methods missing from lasso-sections.txt =\n')
+print(' = Methods missing from lasso-sections.txt =\n')
 for method in methods:
     if not method in lasso_sections_txt:
-        print_(method)
+        print(method)
 
-print_(' = Methods in lasso-sections.txt which does not exist anymore = \n')
+print(' = Methods in lasso-sections.txt which does not exist anymore = \n')
 for line in lasso_sections_txt.splitlines():
     if line.startswith('lasso_'):
         if line not in methods:
-            print_(line)
+            print(line)
diff --git a/tools/format-suppressions.py b/tools/format-suppressions.py
index f621fbee..78e3e846 100644
--- a/tools/format-suppressions.py
+++ b/tools/format-suppressions.py
@@ -1,7 +1,6 @@
 import re
-from six import print_
 
-valgrind_log = open('log','r').read()
+valgrind_log = open('log').read()
 
 inblock = False
 l = 0
@@ -34,11 +33,11 @@ for line in valgrind_log.splitlines():
 i = 43
 for x in keep:
     block = keep[x]
-    print_("{")
-    print_("   suppression", i)
+    print("{")
+    print("   suppression", i)
     for x in block[1:]:
-        print_(x)
+        print(x)
         if re.search(limit_re, x):
             break
-    print_('}')
+    print('}')
     i += 1
